-- MySQL dump 10.13  Distrib 5.5.32, for debian-linux-gnu (x86_64)
--
-- Host: localhost    Database: mmailmm8_data
-- ------------------------------------------------------
-- Server version	5.5.32-0ubuntu0.13.04.1

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `articles`
--

DROP TABLE IF EXISTS `articles`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `articles` (
  `id_` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(128) NOT NULL,
  `title_menu` varchar(128) NOT NULL,
  `title_page` varchar(128) NOT NULL,
  `description` varchar(128) NOT NULL DEFAULT '',
  `category_id` int(11) DEFAULT NULL,
  `text` text NOT NULL,
  `enabled` tinyint(4) NOT NULL DEFAULT '1',
  `ord` int(11) NOT NULL DEFAULT '0',
  PRIMARY KEY (`id_`)
) ENGINE=MyISAM AUTO_INCREMENT=10 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `articles`
--

LOCK TABLES `articles` WRITE;
/*!40000 ALTER TABLE `articles` DISABLE KEYS */;
INSERT INTO `articles` VALUES (2,'Работа с консолью','Работа с консолью','Работа с консолью','',2,' Для того чтобы писать приложения на <b>C#</b> совсем не обязательно скачивать тяжеловесную <b>Visual Studio 2010</b>, вполне хватит и <b>Express</b> версии,\r\nкоторая является бесплатной (в том числе и для коммерческой разработки) весит в 6 раз меньше и отличается от полноценной студии \r\nлишь отсутствием некоторых встроенных инструментов, которыми вы скорее всего никогда (по крайне мере в студенческой жизни) не воспользуетесь.\r\nСкачать можно отсюда \r\n<a href=\"http://download.microsoft.com/download/1/E/5/1E5F1C0A-0D5B-426A-A603-1798B951DDAE/VS2010Express1.iso\">Visual Studio 2010 Express All-in-One ISO</a>.\r\nВообще говоря можно скачать и <b>Visual Studio 2012 Express</b>, но я не уверен запустятся ли ваши программы на машинах что стоят в аудитории.\r\n<p>\r\nСкачав образ диска его можно записать на диск, либо примонтировать с помощью например <b>DaemonTools</b>. И установить <b>Visual C# 2010 Express</b>.\r\nСтоит отметить что установленную программу надо зарегистрировать. Скорее всего программа сама предложит это вам через некоторое время.\r\nПри регистрации придется указать свой <b>email</b>. Я указал одну из своих вполне рабочих почт, и за 3 года никакого спама не было. \r\nПри регистрации вам выдадут ключик.\r\n<hr>\r\n<p>\r\nЛюбая программа на <b>C#</b> имеет следующую базовую конструкцию\r\n<pre class=\"brush: csharp\">\r\nusing System;\r\nusing КакойТоВторойПакет;\r\nusing КакойТоТретийПакет;\r\n...\r\nusing КакойТо100500ыйПакет;\r\n\r\n\r\nnamespace Some_Namespace_Name\r\n{\r\n    // Любая программа является классом\r\n    class Some_Program\r\n    {\r\n        // тут начинается исполнение программы\r\n        static void Main(string[] args)\r\n        {\r\n            ...\r\n        }\r\n    }\r\n}\r\n</pre>\r\n<div class=\"note\">\r\nСоздавая новую программу, <b>VisualStudio</b> автоматически создает так называемое пространство имен (в нашем случае <b>Some_Namespace_Name</b>), \r\nкоторое можно использовать при разработке другого приложения с помощью тех же операторов <b>using</b>, что у нас идут в самом начале программы.\r\n</div>\r\n<p>\r\nТут я покажу как в <b>C#</b> приложении запросить у пользователя список чисел, \r\nи в качестве результата вывести на экран четные числа из этого списка.\r\n<pre class=\"brush: csharp\">\r\nusing System;   // подключение пространства имен для использования основных типов данных\r\n                // int, String, String[], int[] и т.д. а также объекта Console\r\n\r\nnamespace ConsoleApplication1\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            /* все что находится между открывающей и закрывающей  \r\n               фиугрными скобками называется телом функции */\r\n            ...\r\n        }\r\n    }\r\n}\r\n</pre>\r\nВесь последующий код надо записывать в тело функции <b>static void Main(string[] args)</b>\r\n<p>\r\nСначала нам надо выделить переменные которые мы будем использовать для хранения\r\nстроки введенной пользователем, и под массив подстрок на которые мы разобьем введенную строку.\r\n<pre class=\"brush: csharp\">\r\n// сюда сохраним строку введенную пользователем\r\nString strNumbers; \r\n// это массив для подстрок входящих в строку\r\nString[] strNumbersList;\r\n</pre>\r\n\r\nЧерный экран консоли с серыми буквами уж больно депрессивен, \r\nтак что почему бы и не добавить в него капельку радости:\r\n<pre class=\"brush: csharp\">\r\n// установим заголовок консоли\r\nConsole.Title = \"Я заголовок этой мрачной консоли T_T\";\r\n// меняем цвет текста на голубой\r\nConsole.ForegroundColor = ConsoleColor.Cyan;\r\n// меняем цвет фона текста на темно-синий\r\nConsole.BackgroundColor = ConsoleColor.DarkBlue;\r\n</pre>\r\nЗапрос данных у пользователя:\r\n<pre class=\"brush: csharp\">\r\n// выводим на экран предложение ввести числа\r\nConsole.WriteLine(\"Введите числа через пробел:\");\r\n\r\n/* \r\n   приостанавливаем выполнения до тех пор пока пользователь не введет \r\n   некоторый текст и не нажмет ENTER,\r\n   введенную строку сохраним в переменную strNumbers\r\n*/\r\nstrNumbers = Console.ReadLine();\r\n</pre>\r\nНу вроде строку текста от пользователя получили, теперь не плохо бы чего-нибудь с ней сделать.\r\nТак как предполагается что пользователь ввел нам список чисел через пробел, мы разобьем пробелами нашу\r\nстроку на подстроки. Разбивается строка функцией <b>Split</b>. \r\n\r\n<pre class=\"brush: csharp\">\r\n// разобьем введенную пользователем сторку пробелами на подстроки\r\nstrNumbersList = strNumbers.Split(\' \');\r\n</pre>\r\n\r\n<div class=\"note\">\r\nВсе переменный типа <b>String</b> обладают функцией <b>Split</b>,\r\nв качестве результат она возвращает массив строк, полученный разбиением строки разделителем указанным в качестве параметра.\r\n<pre class=\"brush: csharp\">\r\nsome_variable.Split(\' \');\r\n</pre>\r\nЕсли хочется использовать более одного разделителя (например пробел и запятую) придется написать уже вот-такое заклинание\r\n<pre class=\"brush: csharp\">\r\nsome_variable.Split( new Char[]{\' \' , \',\'} );\r\n\r\n// или так, указывать тип массива не обязательно, в данном случае компилятор сам догадается по содержимому\r\nsome_variable.Split( new []{\' \' , \',\'} );\r\n\r\n// или так чтобы убрать пустые строки которые возникают, если у нас например два пробела подряд\r\nsome_variable.Split( new []{\' \' , \',\'}, StringSplitOptions.RemoveEmptyEntries );\r\n</pre>\r\n</div>\r\n<p>\r\nИногда вам захочется сбросить цвета в консоли на те что идут по умолчанию, для этого у объекта <b>Console</b>\r\nесть метод <b>ResetColor</b>. Я сброшу цвета консоли на те унылые, что были по умолчанию и выведу сообщение о том,\r\nчто я сейчас я собираюсь вывести список четных чисел:\r\n<pre class=\"brush: csharp\">\r\n// сбрасываем цвет фона и текста на скучные >_>\r\nConsole.ResetColor();\r\n// выводим на экран сообщение; это хорошая практика всегда держать пользователя в курсе событий\r\nConsole.WriteLine(\"Среди введенных чисел, следующие числа являются четными:\");\r\n</pre>\r\nНу а теперь собственно то ради всего и затевалось, это вывод четных чисел на экран, каждое число в своей строчке.\r\n<br>Перво наперво я верну свои веселые цвета:\r\n<pre class=\"brush: csharp\">\r\n// меняем цвет текста на голубой\r\nConsole.ForegroundColor = ConsoleColor.Cyan;\r\n// меняем цвет фона на темно-синий\r\nConsole.BackgroundColor = ConsoleColor.DarkBlue; \r\n</pre>\r\nНу и вторым шагом собственно сам вывод\r\n<pre class=\"brush: csharp\">\r\n// проход по всем элементам массива strNumbersList, \r\n// свойство Length, очевидно, содержит количество элементов в массиве\r\nfor (int i = 0; i < strNumbersList.Length; ++i)\r\n{\r\n    // преобразуем подстроку в целое число\r\n    int num1 = int.Parse( strNumbersList[i] );  /* для доступа к i-му элементу массива\r\n                                                   используется операция индексации\r\n                                                   проще говоря чтобы узнать значение \r\n                                                   i-го элемента надо написать \r\n                                                   что-то вроде some_array[i], \r\n                                                  \r\n                                                   для 1-го элемента some_array[0]\r\n                                                   для 2-го элемента some_array[1]\r\n                                                   ...\r\n                                                   для последнего some_array[ some_array.Length - 1 ]\r\n                                                   да да нумерация с начинается с нуля!\r\n                                                */\r\n                                                \r\n    // проверяем делиться ли число на 2 без остатка, то есть по сути проверка на четность\r\n    if (num1 % 2 == 0)\r\n    {\r\n        // если так выведем на экран это число\r\n        Console.WriteLine(num1);\r\n    }\r\n}\r\n</pre>\r\n<div class=\"note\">\r\nВ C# четыре вида циклов:\r\n<pre class=\"brush: csharp\">\r\n// 1. Стандартный сишный цикл. Перебор i от 0 до max_value - 1\r\nfor ( i=0; i < max_value; i++ ) \r\n{\r\n    ...\r\n}\r\n\r\n// 2. Цикл для работы с массивами и коллекциями. Проходит по всем элементам коллекции.\r\n// Не позволяет изменять значения коллекции, только смотреть их значение.\r\nforeach (SomeType value in some_array) \r\n{\r\n    ...\r\n}\r\n\r\n// ну и условные циклы\r\n\r\n// 3. С предусловием, запуститься только если условие истинно\r\nwhile( %some_condition_is_true% ) \r\n{\r\n    ...\r\n}\r\n\r\n// 4. С постусловием, обязательно сделает один тик, и только\r\n// потом пойдет проверять истинность условия\r\ndo\r\n{\r\n    ...\r\n}\r\nwhile( %some_condition_is_true% ) \r\n</pre>\r\nА вот цикла вида <b>do ... until</b> - нет. Ну и пусть.\r\n<br> Мы будем использовать в основном циклы вида 1 и 2. \r\n</div>  \r\n<p>\r\nНу и последним шагом надо дать возможность пользователю рассмотреть выведенные числа.\r\nДля этого мы приостановим программу до тех пор пока пользователь не нажмет какую-нибудь клавишу.\r\n<pre class=\"brush: csharp\">\r\n// Иначе консоль автоматически закроется\r\n// и весь вывод улетит в небытие...\r\nConsole.ReadKey();\r\n</pre>\r\nВот и весь код \\(^_^)/\r\n<hr>\r\n<h2>Результат работы:</h2>\r\n<div class=\"console\"> \r\n<span style=\"background:DarkBlue;color:Cyan\">\r\nВведите числа через пробел:<br>\r\n12 123 78 3 2<br>\r\n</span>\r\nСреди введенных чисел, следующие числа являются четными:<br>\r\n<span style=\"background:DarkBlue;color:Cyan\">\r\n12<br>\r\n78<br>\r\n2\r\n</span>\r\n</div>\r\n<hr>\r\n<h2>Полный листинг:</h2>\r\n\r\n<pre class=\"brush: csharp;\">\r\nusing System;\r\nusing System.Linq;\r\n\r\nnamespace ConsoleApplication1\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            // сюда сохраним строку введенную пользователем\r\n            String strNumbers; \r\n            // это массив для подстрок входящих в строку\r\n            String[] strNumbersList; \r\n\r\n            Console.Title = \"Я заголовок этой мрачной консоли T_T\";\r\n\r\n            // меняем цвет текста на голубой\r\n            Console.ForegroundColor = ConsoleColor.Cyan;\r\n            // меняем цвет фона на темно-синий\r\n            Console.BackgroundColor = ConsoleColor.DarkBlue;\r\n\r\n            // выводим на экран предложение ввести числа\r\n            Console.WriteLine(\"Введите числа через пробел:\");\r\n            // приостанавиливаем выполнения до тех пор пока пользователь не введет \r\n            // некоторый текст и не нажмет ENTER,\r\n            // введенную строку сохраним в переменную strNumbers\r\n            strNumbers = Console.ReadLine();\r\n\r\n            // разобьем введенную пользователем сторку пробелами на подстроки\r\n            strNumbersList = strNumbers.Split(\' \');\r\n\r\n            // сбрасываем цвет фона и текста на те что идут по умолчанию\r\n            Console.ResetColor();\r\n            // выводим на экран сообщение\r\n            Console.WriteLine(\"Среди введенных чисел, следующие числа являются четными:\");\r\n\r\n            // меняем цвет текста на голубой\r\n            Console.ForegroundColor = ConsoleColor.Cyan;\r\n            // меняем цвет фона на темно-синий\r\n            Console.BackgroundColor = ConsoleColor.DarkBlue; \r\n\r\n            /// перебираем все элементы массива, нумерация элементов массива начинается от 0\r\n            for (int i = 0; i < strNumbersList.Length; ++i)\r\n            {\r\n                // преобразуем подстроку в целое число\r\n                int num1 = int.Parse(strNumbersList[i]);\r\n                // проверяем является число делиться ли оно на 2 без остатка\r\n                if (num1 % 2 == 0)\r\n                {\r\n                    // если так выведем на экран это число\r\n                    Console.WriteLine(num1);\r\n                }\r\n            }\r\n            // Иначе консоль автоматически закроется\r\n            // и весь вывод улетит в небытие...\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}\r\n</pre>\r\n<hr>\r\n<h2>Альтернативные варианты:</h2>\r\nВообще говоря получить тот же результат можно еще как минимум 5 способами, я их на всякий пожарный оставлю здесь \r\nвдруг пригодится:\r\n<p>\r\n<div class=\"note\">\r\n<h3>Способ #2.</h3>\r\n С использованием цикла <b>foreach</b>. Наверное самый лучший способ в подобной ситуации. Я б использовал именно его.\r\n<pre class=\"brush: csharp\">\r\nforeach (String subString in strNumbersList)\r\n{\r\n    // преобразуем подстроку в целое число\r\n    int num2 = int.Parse(subString);\r\n    // проверяем делиться ли число на 2 без остатка\r\n    if (num2 % 2 == 0)\r\n    {\r\n        // если так выведем на экран это число\r\n        Console.WriteLine(num2);\r\n    }\r\n}\r\n</pre>\r\n<h3>Способ #3.</h3>\r\nБолее хитрый способ с использованием встроенного языка <b>Linq</b>. \r\nГлавное не забыть вверху подключить пространство имен System.Linq:\r\n<pre class=\"brush: csharp\">\r\nusing System;\r\nusing System.Linq; // для использования функции Select\r\n\r\n...\r\n\r\n// формируем из массива подстрок массив целых чисел,\r\n// для этого используется функция Select\r\n// ей в качестве параметра передается функция которая применяется\r\n// к каждому элементу массива strNumbersList.\r\n// ToArray() - необходимо чтобы преобразовать резульат функции Select в массив\r\nint[] intArray = strNumbersList.Select(int.Parse).ToArray();\r\nforeach (int num3 in intArray)\r\n{\r\n    // проверяем делиться ли число на 2 без остатка\r\n    if (num3 % 2 == 0)\r\n    {\r\n        // если так выведем на экран это число\r\n        Console.WriteLine(num3);\r\n    }\r\n}\r\n\r\n</pre>\r\n<h3>Способ #4.</h3> Еще более хитрый способ с использованием лямбда выражений (это та часть что \"<b>x => x % 2 == 0</b>\"). \r\nОказывается за один шаг можно преобразовать массив строк в массив целых чисел и сразу же отсеять нечетные числа:\r\n<pre class=\"brush: csharp\">\r\nint[] evenNumbers = strNumbersList.Select(int.Parse).Where(x => x % 2 == 0).ToArray();\r\nforeach (int num4 in evenNumbers)\r\n{\r\n        // выведем на экран число\r\n        Console.WriteLine(num4);\r\n}\r\n</pre>\r\n<h3>Способ #5.</h3> \r\nБез использования цикла. С использованием функции <b>Join</b>. Функция <b>Join</b> является обратной для функции <b>Split</b>\r\nи позволяет склеить массив строк в одну строку. Между каждыми элементами массива можно указать разделитель. \r\nОказывается строку можно вывести как несколько строк для этого надо каждую подстроку отделить от другой \r\nсимволом перехода на новую строку <b>\"\\n\"</b> (в <b>VBS</b> это была константа <b>VbCrLf</b>). Например:<br>\r\nСтрока <span class=\"consoleIn\">\"Пожалуй хватит\\nна сегодня сишарпа\"</span> в консоли будет выведена как:\r\n<div class=\"console\">\r\nПожалуй хватит<br>\r\nна сегодня сишарпа\r\n</div>\r\nСпособ выглядит вот так:\r\n<pre class=\"brush: csharp\">\r\n// здесь мы одной строкой преобразовываем все подстроки к числам,\r\n// и среди этих чисел выбираем четные числа\r\nint[] evenNumbers2 = strNumbersList.Select(int.Parse).Where(x => x % 2 == 0).ToArray();\r\n\r\n// из массива целых чисел формируем массив строк\r\nString[] evenNumbersStr = evenNumbers2.Select(x => x.ToString()).ToArray();\r\n\r\n// склеиваем все элементы масива строк в одну большую строку outputString\r\n// String.Join(%разделитель строк%, %массив_строк%) возвращает объедененую строку\r\n// \"\\n\" - знак обозначает переход на новую строку\r\nString outputString = String.Join(\"\\n\", evenNumbersStr);\r\n\r\n// выводи эту строку на экран\r\nConsole.WriteLine(outputString);\r\n</pre>\r\n<h3>Способ #6.</h3> \r\nСтоит отметить, что способ 5 умещается в одну длинную мультикоманду.\r\nНе рекомендуется к использованию, так как сильно затрудняет восприятие кода,\r\n\r\n<pre class=\"brush: csharp\">\r\nConsole.WriteLine(String.Join(\"\\n\",strNumbersList.Select(int.Parse).Where(x => x % 2 == 0).Select(x => x.ToString()).ToArray()));\r\n</pre>\r\n</div>',1,1),(3,'Коллекции','Коллекции','Коллекции','',2,'Коллекции являются своего рода динамическим массивами. Я собираюсь рассмотреть работу с коллекциями \r\nна примере списков (List) и словарей (Dictionary).\r\nСоздадим обыкновенное консольное приложение\r\n<pre class=\"brush: csharp\">\r\nusing System; // подключим пространство имен для работы с онсновными типами и консолью\r\nusing System.Collections.Generic; // для работы с коллекциями\r\nusing System.Linq; // для использование встроенного языка Linq\r\n\r\nnamespace ConsoleApplication1\r\n{\r\n	class Program\r\n	{\r\n		static void Main(string[] args)\r\n		{\r\n            \r\n		}\r\n	}\r\n}\r\n</pre>\r\nОпять же весь код ниже надо будет вписать в тело функции <b>static void Main(string[] args).</b>\r\n<p>\r\nВ данном приложении я для ускорения процесса, \"захардкодю\" строку ввода, чтобы не вводить ее по 100 раз.\r\nИ хотя работать я собираюсь сегодня со списком чисел, я намерено добавлю паразитных элементов в строку.\r\n<pre class=\"brush: csharp\">\r\n/* \r\n	чтобы положить чего то в строку совсем необязательно \r\n	запорашивать это \"чего-то\" от пользователя, можно явно указать строку\r\n*/\r\nString strNumbers = \"123 bz 12, 53, asd 7 91 15\";\r\n</pre>\r\nЧтобы разбить строку на подстроки, а тут в качестве разделителей используется не только пробелы но и запятые,\r\nпридется использовать усложненную версию функции <b>Split</b>\r\n<pre class=\"brush: csharp\">\r\n// массив разделителей\r\nChar[] separators = new Char[] { \' \', \',\' };\r\n\r\n/* \r\n	Создаем переменную для хранения списка строк, \r\n	полученных путем разбиения сторки strNumbers \r\n	разделителями из массива separators.\r\n\r\n	Второй параметр устанавливаем на StringSplitOptions.RemoveEmptyEntries\r\n	чтобы избежать появления пустых строк в массиве strNumbersArray,\r\n	которые возникают если два разделителя стоят рядом (например два подряд идущих пробела) \r\n*/\r\nString[] strNumbersArray = strNumbers.Split(separators, StringSplitOptions.RemoveEmptyEntries);\r\n</pre>\r\n<hr>\r\n<h2>Списки. Тип List&#60;int&#62;</h2>\r\nТак как нашей целью является изучить возможности работы со списками, необходимо этот список создать.\r\nДля большинства объектов (типов) с которыми вы столкнетесь необходимо будет использование оператор new.\r\n<pre class=\"brush: csharp\">\r\n/* \r\n	Данное предложение читается справа налево, т.е. \r\n	создать в памяти объект типа List&ltint&gt (список целых чисел),\r\n	и установить numbers как ссылку на этот объект\r\n*/\r\nList&ltint&gtnumbers = new List&ltint&gt();\r\n</pre>\r\nТеперь этот список надо наполнить числами полученные преобразованием элементов массива <b>strNumbersArray</b> в числа.\r\nОчевидно что не все элементы массива <b>strNumbersArray</b> являются числами, если вывести сейчас массив <b>strNumbersArray</b> на экран \r\nто мы увидим примерно следующую картину:\r\n<div class=\"console\">\r\n123<br>\r\nbz<br>\r\n12<br>\r\n53<br>\r\nasd<br>\r\n7<br>\r\n91<br>\r\n15<br>\r\n</div>\r\nОчевидно, что <span class=\"consoleIn\">bz</span> и <span class=\"consoleIn\">asd</span> не являются числами.\r\nДля заполнения списка числами мы будем использовать цикл <b>foreach</b> внутри которого будет вызываться функция\r\n<b>TryParse </b>которая позволяет проверить строку на ее возможность преобразования в число, если такая возможность\r\nесть то в она возвращает true и во второй параметр передает результат преобразования.\r\n\r\n<pre class=\"brush: csharp\">\r\n// проходим по всем подстрокам\r\nforeach (Strig strNumber in strNumbersArray)\r\n{\r\n	int num;\r\n	/*\r\n		тут мы проверяем можно ли преобразовать строку в число\r\n		если преобразование возможно то результат преобразования\r\n		будет положен в переменную num, которую мы создали шагом выше\r\n	*/\r\n	if ( int.TryParse(strNumber, out num) == true )\r\n	{\r\n		numbers.Add(num);\r\n	}\r\n}\r\n</pre>\r\n\r\n<div class=\"note\">\r\nФункция объекта <b>int</b> по имени <b>TryParse</b> представляет собой функцию возвращающая сразу два значение \r\n<pre class=\"brush: csharp\">\r\nint.TryParse(strNumber, out num)\r\n</pre>\r\nПервое значение мы используем когда сравниваем значения функции с константой <b>true</b>\r\n<pre class=\"brush: csharp\">\r\n// не обращаем внимание на многоточие\r\nif ( int.TryParse( ... ) == true )\r\n...\r\n// можно было записать это и так выделив дополнительную переменную \r\n// для сохранения результата функции\r\nbool tryParseResult = int.TryParse( ... );\r\nif ( tryParseResult == true )\r\n...\r\n</pre>\r\nЭта же функция в случае успешной конвертации возвращает еще одно значение, \r\nоно передается во второй параметр. Чтобы получить к нему доступ необходимо \r\nсоздать дополнительную переменную и передать ее в качестве второго параметра \r\nвместе с ключевым словом <b>out</b>:\r\n<pre class=\"brush: csharp\">\r\n...\r\n// создаем переменную для хранения результата преобразования\r\nint num;\r\n// пытаемся преобразовать строку some_string в число\r\nif ( int.TryParse(some_string, out num) ) \r\n{\r\n	// если преобразование было успешным то выводим на экран это число	\r\n	Console.WriteLine(num);\r\n} \r\nelse \r\n{\r\n	// в случае неудачи сообщим что данная строка не является числом	\r\n	Console.WriteLine(some_string + \" не является числом >_>\");\r\n}\r\n</pre>\r\nТо есть должно быть очевидно, что если <b>some_string == \"123\"</b>, \r\nна консоле увидим:\r\n<div class=\"console\">\r\n123\r\n</div>\r\nЕсли же <b>some_string == \"фонарик\"</b>, на консоле увидим:\r\n<div class=\"console\">\r\nфонарик не является числом >_>\r\n</div>\r\n</div>\r\n<p>\r\nПосле выполнения всех этих операций список <b>numbers</b> будет содержать \r\nчисла, (если быть точным, то с учетом того какую строку мы задали \r\nв списке будут числа <b>123, 12, 53, 7, 91, 15</b>, именно в таком порядке)\r\n<p>\r\nТеперь выведем их на экран\r\n<pre class=\"brush: csharp\">\r\n// сообщим пользователю о том что собираемся показать все числа в списке\r\nConsole.WriteLine(\"Исходный список:\");\r\n\r\n// выведем список на экран\r\nforeach(int number in numbers) Console.Write(number + \" \");\r\n\r\n/*\r\n	так как фукнция Console.Write в отличие от Console.WriteLine \r\n	не переводит курсор на новую строку, то я вызову функцию Console.WriteLine \r\n	чтобы такое переход осуществить собственноручно\r\n*/\r\nConsole.WriteLine();\r\n</pre>\r\nУпорядочивание элементов в C# -- милое дело, все делается в одну-две команды\r\n<h4>Сортировка по возрастанию</h4>\r\n<pre class=\"brush: csharp\">\r\n// функция Sort сортирует элементы списка в порядке возрастания\r\nnumbers.Sort();\r\n\r\n// вывод на экран\r\nConsole.WriteLine(\"Упорядоченный по возрастанию:\");\r\nforeach(int number in numbers) Console.Write(number + \" \");\r\nConsole.WriteLine();\r\n</pre>\r\n\r\n<h4>Сортировка по убыванию</h4>\r\n<pre class=\"brush: csharp\">\r\n// сначала отсортируем по возрастанию \r\nnumbers.Sort();\r\n// а потом развернем список \r\n// вообще не самый эффективный способ, \r\n// но вполне пригодный для небольших списков\r\nnumbers.Reverse();\r\n\r\n// вывод на экран\r\nConsole.WriteLine(\"Упорядоченный по возрастанию:\");\r\nforeach(int number in numbers) Console.Write(number + \" \");\r\nConsole.WriteLine();\r\n</pre>\r\n<div class=\"note\">\r\nБолее эффективным способом упорядочения списка по убыванию, заключается в явном указании функции сортировки:\r\n<pre class=\"brush: csharp\">\r\nnumbers.Sort( (num1, num2) => num2.CompareTo(num1) );\r\n</pre>\r\nЗдесь используется лямбда-выражение, которым реализуется функция от двух параметров \r\nвозвращающая<br>\r\n<b>-1</b> если <b>num1 > num2</b>,<br>\r\n<b>1</b> если <b>num1 < num2</b><br> \r\n<b>0</b> если они совпадают.\r\n</div>\r\n<h4>Количество элементов в списке</h4>\r\n<pre class=\"brush: csharp\">\r\nConsole.Write\"Количество элементов в списке: \");\r\n// используем свойстве списка count\r\nConsole.WriteLine(numbers.count);\r\n</pre>\r\n\r\n<h4>Минимальный элемент</h4>\r\n<pre class=\"brush: csharp\">\r\n/*\r\n	в отличие от количества элементов, под минимальный элемент\r\n	лучше создать переменную, так как при каждом вызове функции Min\r\n	этот элемент ищется заново\r\n*/\r\nint minimum = numbers.Min();\r\n\r\nConsole.Write(\"Минимальный элемент: \");\r\nConsole.WriteLine(minimum);\r\n</pre>\r\n\r\n<h4>Максимальный элемент</h4>\r\n<pre class=\"brush: csharp\">\r\n/*\r\n	и под максимальный элемент лучше создать переменную, \r\n	так как при каждом вызове функции Max\r\n	этот элемент также ищется заново.\r\n*/\r\nint maximum = numbers.Max();\r\n\r\nConsole.Write(\"Максимальный элемент: \");\r\nConsole.WriteLine(maximum);\r\n</pre>\r\n<hr>\r\n<h2>Словари. Тип Dictionary&#60;String, String&#62;</h2>\r\nСловари позволяют нам хранить пары вида (ключ, значение). Наилучшим примером объекта типа словарь,\r\nявляется, как бы это странно это не звучало, обычный словарь. Например русско-английский. Я продемонстрирую\r\nкак сделать словарь который будет переводить предложения не хуже печально известного Промта. \r\n<p>\r\nКак и любой объект сложнее <b>int</b> (ну или <b>String</b>, <b>float</b>, <b>long</b> и т.п.), словарь надо создавать с помощью оператора <b>new</b>:\r\n<pre class=\"brush: csharp\">\r\nDictionary&lt;String, String&gt; dictionary = new Dictionary&lt;string, string&gt;();\r\n/*\r\n	не обязательно указывать тип явно можно написать и так\r\n	var dictionary = new Dictionary&lt;string, string&gt;();\r\n*/\r\n</pre>\r\n\r\nТеперь добавим несколько слов в наш словарь\r\n<pre class=\"brush: csharp\">\r\n// первый параметр функции Add это ключ, второй - значение\r\ndictionary.Add(\"яблоко\", \"apple\");\r\ndictionary.Add(\"мороженое\", \"icecream\");\r\ndictionary.Add(\"чай\", \"tea\");\r\n</pre>\r\nВыводим содержимое словаря на экран\r\n<pre class=\"brush: csharp\">\r\nforeach (var pair in dictionary)\r\n{\r\n	/*\r\n	  Тут мы используем форматирование выводимого текста\r\n	  {0} - будет заменено на второй параметр функции WriteLine (т.е на значение pair.Key)\r\n	  {1} - будет заменено на третий параметр функции WriteLine (т.е на значение pair.Value)\r\n	  \r\n	  Аналогично можно добавить {2} - если у нас вдруг появиться какой-то третий параметр \r\n	*/	\r\n	Console.WriteLine(\"{0} по-английски {1}\", pair.Key, pair.Value);\r\n}\r\n</pre>\r\nДобавим следующее приложение:\r\n<pre class=\"brush: csharp\">\r\nString sentence = \"Я пожалуй возьму яблоко, мороженое и чай\";\r\n</pre>\r\nИ воспользуемся нашим словарем для перевода (так как в нашем словаре только три слова,\r\nследовательно и перевести мы сможем  только три слова, ну для начала и так не плохо :D \r\n<pre class=\"brush: csharp\">\r\n// сначала покажем исходное предложение\r\nConsole.WriteLine(sentence);\r\n\r\n/*\r\n	собственно тут и осуществляется перевод,\r\n	для упрощения, я вместо того чтобы искать \r\n	слова из текста в словаре, будут искать \r\n	слова из словаря в тексте. \r\n	\r\n	Нелогично, зато код во много раз проще,\r\n	иначе бы мне пришлось разбивать текст \r\n	на слова, искать каждое слово в словаре,\r\n	а потом еще эти слова уже склеивать обратно\r\n	в предложение, что, вообще говоря, является\r\n	нетривиальной задачей.\r\n*/\r\n\r\nforeach (var wordPair in dictionary)\r\n{\r\n	/*\r\n	  Функция Replace ищет в строке для которой она вызывается\r\n	  значение первого параметра и заменяет его значением второго параметра.\r\n	  \r\n	  В качестве результата  возвращает новую строку которая является\r\n	  преобразованным предложением.\r\n	  \r\n	  Тут мы присваиваем значение функции самой строке, чтобы на следующей\r\n	  итерации цикла уже использовалось новое предложение \r\n	  в котором часть слов уже переведена\r\n	*/	 \r\n	 sentence = sentence.Replace(wordPair.Key, wordPair.Value);\r\n}\r\n\r\n// вывод на экран переведенного предложения\r\nConsole.WriteLine(sentence);\r\n</pre>\r\nНу и последним шагов приостанавливаем работу программы в ожидании нажатия любой клавиши\r\nпользователем, иначе консолька автоматически закроется.\r\n<pre class=\"brush: csharp\">\r\n// ожидаем нажатия любой клавиши пользователем\r\nConsole.ReadKey();\r\n</pre>\r\n\r\n<hr>\r\n<h2>Результат работы:</h2>\r\n<div class =\"console\">\r\nИсходный список:<br>\r\n123 12 53 7 91 15<br>\r\nУпорядоченный по возрастанию:<br>\r\n7 12 15 53 91 123 <br>\r\nУпорядоченный по убыванию:<br>\r\n123 91 53 15 12 7 <br>\r\nКоличество элементов: 6<br>\r\nМинимальный элемент: 7<br>\r\nМаксимальный элемент: 123<br>\r\nмороженое по-английски icecream<br>\r\nчай по-английски tea<br>\r\nяблоко по-английски apple<br>\r\nЯ пожалуй возьму яблоко, мороженое и чай<br>\r\nЯ пожалуй возьму apple, icecream и tea<br>\r\n_\r\n</div>\r\n<hr>\r\n<h2>Полный листинг:</h2>\r\n<pre class=\"brush: csharp\">\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\n\r\n\r\nclass Program\r\n{\r\n    static void Main(string[] args)\r\n    {\r\n        // чтобы положить чего то в строку совсем необязательно \r\n        // заправшивать чего-то от пользователя, можно явно указать строку\r\n        String strNumbers = &quot;123 bz 12, 53, asd 7 91 15&quot;;\r\n\r\n        // разбиваем строку запятыми и пробелами, и убираем за одно пустые строки\r\n        Char[] separators = new Char[] { &apos; &apos;, &apos;,&apos; };\r\n        String[] strNumbersArray = strNumbers.Split(separators, StringSplitOptions.RemoveEmptyEntries);\r\n\r\n        List&lt;int&gt; numbers = new List&lt;int&gt;(); // создаем динамический список\r\n\r\n        // проходим по всем подстрокам\r\n        foreach (String strNumber in strNumbersArray)\r\n        {\r\n            int num;\r\n            // тут мы проверяем можно ли преобразовать строку в число\r\n            if (int.TryParse(strNumber, out num))\r\n            {\r\n                numbers.Add(num);\r\n            }\r\n        }\r\n\r\n        Console.WriteLine(&quot;Исходный список:&quot;);\r\n        foreach(int number in numbers) Console.Write(number + \" \");\r\n        Console.WriteLine();\r\n\r\n        // функция Sort сортирует элменты массива в порядке возрастания\r\n        numbers.Sort();\r\n        \r\n        Console.WriteLine(&quot;Упорядоченный по возрастанию:&quot;);\r\n        foreach(int number in numbers) Console.Write(number + \" \");\r\n        // чтобы не слипалось со следующем выводом\r\n        Console.WriteLine();\r\n\r\n        // упорядочим список по убыванию\r\n        numbers.Sort();\r\n        numbers.Reverse();\r\n        \r\n        Console.WriteLine(&quot;Упорядоченный по убыванию:&quot;);\r\n        foreach(int number in numbers) Console.Write(number + \" \");\r\n        Console.WriteLine();\r\n\r\n		  Console.Write(&quot;Количество элементов: &quot;);\r\n        Console.WriteLine(numbers.Count);\r\n\r\n        int minimum = numbers.Min();\r\n        Console.Write(&quot;Минимальный элемент: &quot;);\r\n        Console.WriteLine(minimum);\r\n\r\n        int maximum = numbers.Max();\r\n        Console.Write(&quot;Максимальный элемент: &quot;);\r\n        Console.WriteLine(maximum);\r\n\r\n        Dictionary&lt;String, String&gt; dictionary = new Dictionary&lt;string, string&gt;();\r\n        dictionary.Add(&quot;яблоко&quot;, &quot;apple&quot;);\r\n        dictionary.Add(&quot;мороженое&quot;, &quot;icecream&quot;);\r\n        dictionary.Add(&quot;чай&quot;, &quot;tea&quot;);\r\n\r\n        dictionary = dictionary.OrderBy(pair =&gt; pair.Key).ToDictionary(pair =&gt; pair.Key, pair =&gt; pair.Value);\r\n\r\n        foreach (var pair in dictionary)\r\n        {\r\n            Console.WriteLine(&quot;{0} по-английски {1}&quot;, pair.Key, pair.Value);\r\n        }\r\n\r\n\r\n        String sentence = &quot;Я пожалуй возьму яблоко, мороженое и чай&quot;;\r\n\r\n        Console.WriteLine(sentence);\r\n        foreach (var wordPair in dictionary)\r\n        {\r\n            sentence = sentence.Replace(wordPair.Key, wordPair.Value);\r\n        }\r\n        Console.WriteLine(sentence);\r\n		\r\n\r\n        Console.ReadKey();\r\n    }\r\n}\r\n</pre>',1,2),(4,'Работа с файлами','Работа с файлами','Работа с файлами','',2,'В качестве файла для экспериментов я возьму текст книги <a href=\"files/%D0%90%D0%BB%D0%B8%D1%81%D0%B0%20%D0%B2%20%D0%97%D0%B0%D0%B7%D0%B5%D1%80%D0%BA%D0%B0%D0%BB%D1%8C%D0%B5.txt\">\"Алиса в Зазеркалье\"</a>, вы можете\nиспользовать этот файл либо какой-нибудь свой, главное чтобы это был простой текст (<b>*.txt</b>).\n<p>\nСоздадим простое консольное приложение:\n<pre class=\"brush: csharp\">\nusing System; 		 // базовые типы\nusing System.Text; // для работы с кодировками\nusing System.IO;	 // для работы с фалами\nusing System.Collections.Generic; // для работы с коллекциями\nusing System.Linq; // \nдля использования конструкций языка Linq\n\nnamespace ConsoleApplication1\n{\n	class MainClass\n	{\n		public static void Main (string[] args)\n		{\n		}\n	}\n}\n</pre>\nВозможны вы уже обратили внимание что у функции <b>public static void Main (string[] args)</b>. \nПрисутствует параметр <b>string[] args</b>. Это так называемые аргументы командной строки, их используют\nдля того чтобы контролировать поведение консольных приложений. Их количество и вид определяет разработчик программы.\nНапример команду <b>copy</b> консольной оболочки Windows (чтобы запустить консоль нажмите <b>Win+R</b>, введите <b>cmd</b> и нажмите <b>ENTER</b>) , можно вызвать следующим образом:\n<div class=\"console\">\ncopy somefile.txt d:\\Texts\n</div>\nПрограмме <b>copy</b> передается два аргумента (аргументы отделяются друг от друга пробелами, если параметр может содержать пробелы его надо заключить в кавычки, например: <b>copy \"Some file with spaces in name.txt\" d:\\Texts</b> ):<br>\n<b>somefile.txt</b> &mdash; файл для копирования <br>\n<b>d:\\Texts</b> &mdash; папка назначения, туда куда скопируется файл <br>\nЕсли бы мы были разработчиками программы <b>copy</b>, то мы могли бы обратиться к этим аргументам через параметр <b>string[] args</b>.<br>\n<ul>\n<li><b>args</b> &mdash; это массив строк</li>\n<li><b>args[0]</b> &mdash; хранит первый аргумент переданный в командную строку \n(т.е. для данного примера он содержал <b>\"somefile.txt\"</b>)</li>\n<li><b>args[1]</b> &mdash; хранит второй аргумент переданный в командную строку \n(т.е. для данного примера он содержал <b>\"d:\\Texts\"</b>)</li>\n<li>и т.д.</li>\n</ul>\n<p>\nВ нашем приложении мы тоже будем использовать два параметра: для указания файла с текстом \nи для папки куда мы будем сохранять результаты обработки текста. Но мы же не собираемся запускать \nпрограмму из консоли, мы просто тыкаем <b>F5</b> и все делается на автомате. Чтобы передать параметры\nприложению необходимо сделать небольшие манипуляции.\n<br>Открыть свойства проекта:\n<img src=\"images/project_properties.png\" />\nВыбрать вкладку Debug (отладка):\n<img src=\"images/project_properties_debug.png\" />\nИ прописать туда параметры через пробел, как видите так как путь к книге \"Алиса в Зазеркалье\" содержит\nпробелы я заключаю его в двойные кавычки.\n<p>\nМожно закрыть вкладку свойств и перейти к написанию кода, как обычно весь код помещаем \nв тело функции <b>public static void Main (string[] args)</b>\n<p>\nСоздадим две переменные для хранения первого и второго аргумента (вообще говоря это необязательно,\nмы могли бы просто использовать <b>args[0]</b> и <b>args[1]</b>, но они имена не несут никакой смысловой\nнагрузке, и через неделю другую вам будет достаточно тяжело вспомнить для чего и какой аргумент использовался.\n<pre class=\"brush: csharp\">\nString inputFile = args [0]; // файл с текстом\nString outputDir = args [1]; // папка куда будем сохранять файл\n</pre>\nТеперь сделаем небольшую проверку, вдруг пользователь подсунет нам файл которого\nне существует или и вовсе какую ерунду. Для этого воспользуемся методом <b>Exists</b> класса <b>File</b>, \nкоторый возвращает <b>true</b> если файл существует и <b>false</b> в обратном случае. \n<pre class=\"brush: csharp\">\n// если файл не существует\nif ( !File.Exists (inputFile) ) {\n\n	// сообщить об этом пользователю\n	Console.WriteLine(\"файла \\\"\" + inputFile + \"\\\" не существует!\");\n	\n	// дать возможность прочитать сообщение	\n	Console.ReadKey();\n	\n	// завершить программу\n	return;\n}\n</pre>\n<div class=\"note\">\nВозможно вы обратили внимание что мы используем <b>\\</b> для того что выводить кавычки. \n<pre class=\"brush: csharp\">\n... \nConsole.WriteLine(\"файла \\\"\" + inputFile + \"\\\" не существует!\");\n...\n</pre>\nСвязанно это с тем, что кавычки являются зарезервированным символом поэтому чтобы вывести сроку содержащую\nкавычки необходимо кавычки в ней \"экранировать\" с помощью обратного слеша. Таким образом, чтобы создать строку содержащую\nнеобходимо \nделать так:\n<pre class=\"brush: csharp\">\nString some_string = \"\\\"\"; // с одним символом двойных кавычек\n...\nString another_string = \"\\\"\\\"\";// с двумя символами двойных кавычек\n...\nString other_string = \"\\\\\"; // с обратным слешом\n...\nString freak_string = \"\\\\\\\"\\\\\"; // с символом двойных кавычек, между двумя обратными слэшами \n</pre>\nПоследняя строка уж совсем страшная.<br>\n<b>C#</b> предлагает нам альтернативный способ задания строк\nсодержащих много экранированных символов. С использованием символа <b>@</b> (at - по-английски). \nС помощью <b>@</b> последняя строка может быть записана как\n<pre class=\"brush: csharp\">\nString freak_string = @\"\\\"\"\\\"; \n/*\n  кавычки все равно приходится экранировать, повторяя их два раза\n    \n  два раза повторенная двойная кавычка \n  будет выведена как один символ двойной кавычки\n*/\n</pre>\nВ основном символ используют для задания путей в <b>Windows</b> (в <b>UNIX</b> подобных системах, в путях используется прямой слэш\nи таких проблем там не возникает):\n<pre class=\"brush: csharp\">\n// без @:\nString path1 = \"C:\\\\somedir\\\\anotherdir\\\\somefile.jpeg\";\n\n// с использованием @:\nString path2 = @\"C:\\somedir\\anotherdir\\somefile.jpeg\";\n\n// вывести строки на экран\nConsole.WriteLine(path1);\nConsole.WriteLine(path2);\n</pre>\nВыведутся на консоль обе строки абсолютно одинаково.\n<div class=\"console\">\nC:\\somedir\\anotherdir\\somefile.jpeg<br>\nC:\\somedir\\anotherdir\\somefile.jpeg\n</div>\n</div>\n<p>\nТеперь считаем содержимое файла в и сохраним в строку\n<pre class=\"brush: csharp\">\n/*\n	Кодировки это большая головная боль\n	если у вас вместо букв вылезут вопросики\n	попробуйте в качестве второго параметра \n	один из следующих вариантов:\n	\n	Encoding.GetEncoding (1251)\n	Encoding.Default;\n	Encoding.UTF8\n*/\nString fullText = File.ReadAllText (inputFile, Encoding.GetEncoding (1251));\n/*\n	выведем текст на экран,\n	кстати если текст достаточно большой\n	то в консоль он весь не влезет (даже с учетом прокрутки)\n*/\nConsole.Write(fullText);\n</pre>\nЯ хочу провести частотный анализ появления слов в тексте, для этого мне надо\nпрежде всего текст разбить на слова. Я воспользуюсь уже знакомой с прошлых уроков функцией\n<b>Split</b>, а в качестве разделителей выберу следующие символы:\n<pre class=\"brush: csharp\">\n/*\n	этот далеко не полный список разделителей, но и такой пойдет\n	обратите внимание на два последних символа,\n	\'\\n\' - символ перехода на новую строку\n	\'\\r\' - символ возврата каретки\n	эти символы не являются печатными, \n	но тем не менее в тексте присутствуют.\n*/\nChar[] separators = {\' \', \',\', \'.\', \'-\', \'!\', \'?\', \'\\\"\', \'\\n\', \'\\r\' };\n</pre>\nСформируем список слов:\n<pre class=\"brush: csharp\">\nString[] wordsArray = fullText.Split (separators, StringSplitOptions.RemoveEmptyEntries);\n</pre>\nТеперь я хочу создать новый список состоящий из пар: слово + кол-во появлений слова в тексте.\nДля этого как нельзя лучше подходят класс <b>Dictionary</b>. \nВ прошлом уроке я использовал словарь типа <b>Dictionary&lt;String, String&gt;</b>. \n<p>Сегодня я буду использовать словарь вида <b>Dictionary&lt;String, int&gt;</b>. Создам его:\n<pre class=\"brush: csharp\">\n/*\n	мне лень явно указывать тип переменной\n	к тому же он вполне очевиден из правой части \n*/\nvar dictWords = new Dictionary&lt;String, int&gt; ();\n</pre> \nА теперь мне надо заполнить этот словарь элементами. Для этого я организую цикл по всем словам из списка слов текста:\n<pre class=\"brush: csharp\">\n// для каждого слова из списка слов\nforeach (var word in wordsArray) \n{\n	// если словарь не содержит слово	\n	if (!dictWords.ContainsKey (word)) \n	{\n		/*\n			добавляем слово в качестве ключа в словарь,\n			его значение устанавливаем единичкой,\n			что означает &mdash; слово один раз в тексте встречалось,\n			таки так оно \nи есть\n		*/		\n		dictWords.Add (word, 1);\n	} \n	else  // а если встречалось\n	{\n		/*\n			в таком случае добавлять слово с словарь не надо\n			но надо увеличить значение для слова на 1 \n		*/\n		dictWords [word] += 1;\n	}\n}\n</pre>\n<div class=\"note\">\nВ таком виде программа различает слова начинающиеся с большой и маленькой буквы, т.е. <b>алиса</b> и <b>Алиса</b> будут восприняты как два разных слова, вообще говоря такое поведение не логично, чтобы поправить ситуацию можно например переписать так:\n<pre class=\"brush: csharp\">\nforeach (var word in wordsArray) \n{\n	/*\n		введем дополнительную переменную, которая все слова будет переводить\n		в нижний регистр и уже для этого слова мы будем решать\n		добавлять его в словарь или изменять его значение\n	*/  	\n	String lowerWord = word.ToLower(); 	\n	\n	// если словарь не содержит слово	\n	if (!dictWords.ContainsKey (lowerWord)) \n	{\n		/*\n			добавляем слово в качестве ключа в словарь,\n			его значение устанавливаем единичкой,\n			что означает &mdash; слово один раз в тексте встречалось,\n			таки так оно и есть\n		*/		\n		dictWords.Add (lowerWord, 1);\n	} \n	else  // а если встречалось\n	{\n		/*\n			в таком случае добавлять слово с словарь не надо\n			но надо увеличить значение для слова на 1 \n		*/\n		dictWords [lowerWord] += 1;\n	}\n}\n</pre>\n</div>\nНу а теперь самое интересное, мы могли бы вывести на экран какое слово сколько раз\nвстречалось, но вместо этого, мы будем производить вывод в файл. Для этого создадим объект\n<b>StreamWriter</b> который позволяет производить операции записи над файлом указанном\nв качестве параметра при его инициализации. \n<pre class=\"brush: csharp\">\nStreamWriter writer = new  StreamWriter(outputDir + @\"\\words.txt\");\n</pre>\nА теперь запишем информацию о нашем анализе в текстовый файл:\n<pre class=\"brush: csharp\">\n/*\n	Я воспользуюсь возможностью упорядочения на лету\n	с помощью функции OrderBy, \n	и укажу что хочу упорядочить по значению\n*/\nforeach (var pair in dictWords.OrderBy( x => x.Value ) ) \n{\n	/*\n		Напоминаю что \"{0,-14}: {1}\" &mdash; это шаблон форматирования строки\n		сам шаблон означает вывести первый аргумент, если строковое значение\n		первого аргумента длиной меньше 14 символов добавить к нему справа пробелов \n		чтобы она равнялась 14 (если б стояло просто 14, то обозначало бы добавить слева), \n		\n		нарисовать двоеточие, \n		вывести второй аргумент\n		\n		все данные записываются в файл\n	*/	\n	writer.WriteLine(\"{0,-14}: {1}\", pair.Key, pair.Value);\n}\n\n// так как мы больше ничего не собираемся делать с этим файлом, его необходимо закрыть\nwriter.Close();\n</pre>\nМожно открыть файл и полюбоваться результатом. Вот несколько строчек из моего файла:\n<div class=\"console\">\nКоролева&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;168<br>\nа&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;170<br>\nто&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;170<br>\nтак&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;178<br>\nИ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;185<br>\nА&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;189<br>\nон&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;219<br>\nэто&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;219<br>\nя&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;243<br>\nкак&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;291<br>\nс&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;304<br>\nона&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;327<br>\nАлиса&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;488<br>\nчто&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;492<br>\nна&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;516<br>\nне&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;654<br>\nв&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;692<br>\nи&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;936\n</div>\nЕсли уже забыли, то в первой колонке у нас слова, а в правой то сколько раз они встретились в тексте. \n<p>Теперь попробуем сделать частотный анализ букв, в отличие от слов, для этого разбивать текст не надо, достаточно использовать исходный текст, мы можем обращаться к символом текста через операцию индексации. Но сначала создадим новый словарь. В качестве ключа будем использовать букву, а в качестве значения, то сколько раз она встречалась в тексте.\n<pre class=\"brush: csharp\">\nvar dictChars = new Dictionary&lt;Char, int&gt;();\n</pre>\nТеперь организуем цикл по всем символам текста:\n<pre class=\"brush: csharp\">\n// проходим по всем символам в тексте \nforeach (Char ch in fullText) {\n	/*\n		нас интересует лишь частотный анализ букв\n		поэтому мы использую статический метод IsLetter\n		класса Char, проверяем является ли символ буквой\n	*/ \n	if ( Char.IsLetter(ch) ) \n	{\n		// если такой буквы нет в словаре		\n		if ( !dictChars.ContainsKey (ch) ) \n		{\n			// добавляем ее в словарь, устанавливаем ее значение на 1\n			dictChars.Add (ch, 1);			\n		} \n		else  // а если есть\n		{\n			// увеличиваем значение буквы на один			\n			dictChars [ch] += 1;\n		}\n	}\n}\n</pre>\nПосле выполнения этого цикла наш словарь будет содержать информацию о том сколько раз\nкаждая буква встречалась в тексте.\n<p>Теперь рассмотрим альтернативный способ записи текста в файл.\nФункция <b>WriteAllText</b> класса <b>File</b>, позволяет записать строку в файл, за\nодин шаг, главное чтобы строка к этому моменту была сформирована. Формировать строку очень \nудобно с помощью объекта <b>StringBuilder</b>.\n<pre class=\"brush: csharp\">\n// создадим объект для формирования строк\nStringBuilder outString = new StringBuilder ();\n/*\n  для каждой пары: буква - кол-во появлений в тексте\n  как и в предыдущем примере я упорядочиваю на лету по значению\n*/\nforeach (var pair in dictChars.OrderBy( x => x.Value ) ) \n{\n	// рассчитываем долю появления буквы к количеству символов в тексте \n	// это число очевидно меньше единицы 	\n	double freq = (double) pair.Value / fullText.Length;\n\n	/* \n		добавляю строку\n		{0,-3} - выделить три символа с выравниванием влево под символ буквы \n		{1:0.000%} - вывести долю в процентах, с точностью до третьего знака после запятой\n	*/ \n	outString.AppendFormat(\"{0,-3}: {1:0.000%}\", pair.Key, freq);\n	\n	// добавить символ перехода на новую строку\n	outString.AppendLine();\n}\n</pre>\n<div class=\"note\">\nСтоит отметить что тут (<b>double freq = (double) pair.Value / fullText.Length</b>) \nмы сравниваем частоту появления буквы относительно количества символов в тексте\n(не только букв, но и знаков препинания, пробелов, цифр и т.д.), более правильно было бы\nвместо <b>fullText.Length</b>, ввести дополнительную переменную хранящую кол-во букв в тексте\n<pre class=\"brush: csharp\">\n/*\n	Тут мы используем Linq-функцию Count которая возвращает кол-во элементов в массиве,\n	для которых функция, указанная в качестве параметра, возвращает true\n*/\nint lettersCount = fullText.Count(Char.IsLetter);\n/*\n	равносильная запись \n	int lettersCount = fullText.Count( ch => Char.IsLetter(ch));\n*/\n</pre>\nНу и заменить пересчет доли\n<pre class=\"brush: csharp\">\n...\ndouble freq = (double) pair.Value / lettersCount;\n...\n</pre>\n</div>\n<p>\nНу а теперь мы эту строку сформированную объектом <b>outString</b> типа <b>StringBuilder</b> сохраним в файл:\n<pre class=\"brush: csharp\">\n/*\n	Так как StringBuilder не является строкой,\n \n	а является чем то вроде контейнера для хранения строки\n	строку надо извлечь с помощью метода ToString(), \n	\n	кстати методом ToString() обладают абсолютно все объекты в C#	\n*/\nFile.WriteAllText(outputDir + @\"\\chars.txt\" ,outString.ToString());\n</pre>\nВот несколько строк из моего файла:\n<div class=\"console\">\nь&nbsp;&nbsp;:&nbsp;1.503%<br>\nп&nbsp;&nbsp;:&nbsp;1.814%<br>\nу&nbsp;&nbsp;:&nbsp;1.967%<br>\nд&nbsp;&nbsp;:&nbsp;1.982%<br>\nм&nbsp;&nbsp;:&nbsp;2.101%<br>\nк&nbsp;&nbsp;:&nbsp;2.497%<br>\nв&nbsp;&nbsp;:&nbsp;2.823%<br>\nр&nbsp;&nbsp;:&nbsp;3.268%<br>\nс&nbsp;&nbsp;:&nbsp;3.901%<br>\nл&nbsp;&nbsp;:&nbsp;4.145%<br>\nн&nbsp;&nbsp;:&nbsp;4.286%<br>\nт&nbsp;&nbsp;:&nbsp;4.379%<br>\nи&nbsp;&nbsp;:&nbsp;4.496%<br>\nе&nbsp;&nbsp;:&nbsp;5.931%<br>\nа&nbsp;&nbsp;:&nbsp;6.579%<br>\nо&nbsp;&nbsp;:&nbsp;8.126%<br>\n</div>\n для интереса слазайте <a href=\"http://ru.wikipedia.org/wiki/%D0%A7%D0%B0%D1%81%D1%82%D0%BE%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C\" target=\"_blank\">сюда</a> и сравните порядок букв с тем что в вашем файле\n(напомню что буквы я упорядочил по частоте появления в тексте)\nНу напоследок откроем созданные файлы программно, мы конечно могли бы\nдойти до папки и в ручную открыть их, но ведь нам лень .__.\n<pre class=\"brush: csharp\">\n// открываем первый файл\nSystem.Diagnostics.Process.Start(outputDir + @\"/chars.txt\");\n// открываем второй файл\nSystem.Diagnostics.Process.Start(outputDir + @\"/words.txt\");\n</pre>\nЕсли в качестве стандартного приложения для работы с *.txt файлами у вас стоит блокнот,\nто у вас должно открыться два блокнота.\n<div class=\"note\">\nкстати <b>System.Diagnostics.Process</b> на самом деле просто класс <b>Process</b> для управления процессами операционной системы, если б мы подключили вверху программы пространство имен <b>System.Diagnostics</b>, можно было написать и так:\n<pre class=\"brush: csharp\">\n...\nusing System.Diagnostics;\n...\n\n// открываем первый файл\nProcess.Start(outputDir + @\"/chars.txt\");\n// открываем второй файл\nProcess.Start(outputDir + @\"/words.txt\");\n</pre>\n</div>\n<p>\nНу и напоследок дадим рассмотреть пользователю чего у нас на консоль выведено:\n<pre class=\"brush: csharp\">\n// приостановка, в ожидании нажатия пользователем любой клавиши\nConsole.ReadKey();\n</pre>\n<hr>\n<h2>Полный листинг:</h2>\n<pre class=\"brush: csharp\">\nusing System;\nusing System.Text;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ConsoleApplication1\n{\n	class MainClass\n	{\n		public static void Main (string[] args)\n		{\n			String inputFile = args [0];\n			String outputDir = args [1];\n\n			if (!File.Exists (inputFile)) \n			{\n				Console.WriteLine (&quot;файла \\&quot;&quot; + inputFile + &quot;\\&quot; не существует!&quot;);\n				Console.ReadKey ();\n				return;\n			}\n\n			String fullText = File.ReadAllText (inputFile, Encoding.GetEncoding (1251));\n			Console.WriteLine (fullText);\n\n			Char[] separators = {&apos; &apos;, &apos;,&apos;, &apos;.&apos;, &apos;-&apos;, &apos;\\n&apos;, &apos;!&apos;, &apos;?&apos;, &apos;\\&quot;&apos;, &apos;\\r&apos; };\n			String[] wordsArray = fullText.Split (separators, StringSplitOptions.RemoveEmptyEntries);\n\n			var dictWords = new Dictionary&lt;string, int&gt; ();\n			foreach (var word in wordsArray) \n			{\n				if (!dictWords.ContainsKey (word)) \n				{\n					dictWords.Add (word, 1);\n				} \n				else \n				{\n					dictWords [word] += 1;\n				}\n			}\n\n			StreamWriter writer = new  StreamWriter (outputDir + @&quot;\\words.txt&quot;);\n\n			foreach (var pair in dictWords.OrderBy( x =&gt; x.Value )) \n			{\n				writer.WriteLine (&quot;{0,-14}: {1}&quot;, pair.Key, pair.Value);\n			}\n			writer.Close ();\n\n			var dictChars = new Dictionary&lt;Char, int&gt; ();\n			foreach (Char ch in fullText) \n			{\n				if (Char.IsLetter (ch)) \n				{\n				\n	if (dictChars.ContainsKey (ch)) \n					{\n						dictChars [ch] += 1;\n					} \n					else \n					{\n						dictChars.Add (ch, 1);\n					}\n				}\n			}\n\n			StringBuilder outString = new StringBuilder ();\n			foreach (var pair in dictChars.OrderBy( x =&gt; x.Value ) ) \n			{\n				double freq = (double) pair.Value / fullText.Length;\n				outString.AppendFormat(&quot;{0,-3}: {1:0.000%}&quot;, pair.Key, freq);\n				outString.AppendLine();\n			}\n			File.WriteAllText(outputDir + @&quot;\\chars.txt&quot; ,outString.ToString());\n\n			System.Diagnostics.Process.Start(outputDir + @&quot;\\chars.txt&quot;);\n			System.Diagnostics.Process.Start(outputDir + @&quot;\\words.txt&quot;);\n\n			Console.ReadKey();\n		}\n	}\n}\n</pre>',1,3),(5,'Формы','Формы','Формы','',2,'Создадим <b>Windows Form Application</b>. Для этого выбираем <b>Файл / Создать / Проект</b>,\nи в качестве шаблона указываем <b>Приложение Windows Forms</b>.\nВ реультате увидим примерно следующую картинку:\n<img src=\"images/csharp-04-01.png\" />\nЕсли у вас вдруг отсутствует левая (<b>панель элементов (toolbox)</b>) или правая панелька (<b>свойства (properties)</b>),\nих можно включить через меню <b>Вид (view)</b>\n<p>\nДобавим на форму пару элементов, пока нам хватит <b>Button</b> и <b>RichTextBox</b>. Чтобы добавить компонент его надо\nперетянуть с панели инструментов на форму. Должно получиться что-то в этом роде:\n<img src=\"images/csharp-04-02.png\">\nВыделим кнопку (кликнув на нее один раз), и поменяем ее имя (свойство <b>Name</b>) на <b>btnShowText</b>, \nи надпись на кнопке (свойство <b>Text</b>) на <b>Показать текст</b> \n<img src=\"images/csharp-04-03.png\">\n<div class=\"note\">\nКаждый объект на форме, включаю саму форму, обладает набором свойств, изменяя которые можно изменять\nповедение и вид объекта. Самое простое, но в тоже время самое важное свойства - это свойство <b>Name</b>. \nС помощью него мы обращаемся к объекту. То есть если кнопка имеет имя <b>RedButton</b>, то для\nтого чтобы программно нажать на эту кнопку надо будет написать\n<pre class=\"brush: csharp\">\nRedButton.Click();\n</pre>\nА если нам вдруг захочется узнать какая надпись на кнопке, и присвоить это значение какой-нибудь переменной мы напишем\n<pre class=\"brush: csharp\">\nstring labeltext = RedButton.Text;\n</pre>\n</div>\n<p>\nВыделим объект типа <b>RichTextBox</b> и поменяем его имя на <b>txtMain</b>.<br>\n<b>RichTextBox</b> позволяет отображать форматированный текст и редактировать его. \nЕсли сейчас запустить приложение (<b>F5</b>), то можно написать чего нибудь в текстовом поле,\nможно понажимать на кнопку, правда все это пока не принесет ни какой пользы. \n<p>\nЕсли приложение запущенно, то закроем его и вернемся к редактированию формы. Щелкнем два раза на\nнашу кнопку <b>btnShowText</b>. По идее мы должны оказаться в режиме редактирования кода. Увидим мы примерно следующее:\n\n<pre class=\"brush: csharp\">\n/*\n	В отличие от консольных приложений здесь уже намного \n	больше компонентов подключено по умолчанию.\n	Часть из них предназначена для работы с объектами на форме\n*/\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Data;\nusing System.Drawing;\nusing System.Linq;\nusing System.Text;\nusing System.Windows.Forms;\n\nnamespace WindowsFormsApplication1\n{ \n    /*\n    	Создавая форму, мы формируем новый объект формы на\n    	базе самой простой, на что и указывает \n    	...  class Form1 : Form ...\n    	\n    	Часто класс формы содержит очень много функций\n    	слово partial, позволяет разбивать код для класса\n    	на несколько подфайлов \n    */  \n    public partial class Form1 : Form\n    {\n        // это конструктор формы, он вызывается всего один раз\n        // когда форма создается в памяти впервые        \n        public Form1()\n        {\n            /*\n            	на самом деле данный файл содержит не весь код формы\n   \n         	часть кода содержится в файле Form1.Designer.cs\n            	метод InitializeComponent описан в том файле, \n            	и код в нем генерируется автоматически\n            	в соответствии с тем какие объекты вы добавляете на форму,\n            	и как меняете их свойства\n            */\n            InitializeComponent();\n        }\n        \n        \n        /*\n        	эта функция возникла автоматически когда мы два раза щелкнули\n        	на кнопку btnShowText, в нем мы пропишем код \n        	который будет запускаться каждый раз \n        	когда во время исполнения программы \n        	на кнопку будут нажимать\n        */  \n        private void btnShowText_Click(object sender, EventArgs e)\n        {\n\n        }\n    }\n}\n</pre>\nНаша кнопка будет показывать текстовое сообщение, в котором будет содержаться текст\nиз <b>txtMain</b>. Для этого <b>.Net</b> предлагает нам класс <b>MessageBox</b>.\n<pre class=\"brush: csharp\">\n...\nprivate void btnShowText_Click(object sender, EventArgs e)\n{\n	// сохраним содержимое текстового поля\n	// в переменную	\n	String textFromTxtMain = txtMain.Text;\n	\n	// покажем значение переменной в окне MessageBox\n	MessageBox.Show(textFromTxtMain);\n}\n...\n</pre>\nЕстественно, чтобы в окне что-то было, это что-то надо ввести в текстовое поле.\nНо каждый раз вводить лень, так что вернемся в режим редактирования формы, и изменим значение\nсвойства <b>Text</b> объекта <b>txtMain</b> например на следующий текст:\n<div class=\"text\">\n Шалтай-Болтай взял книжку и уставился в нее.<br>\n - Кажется, здесь нет ошиб... - начал он.<br>\n - Вы ее держите вверх ногами, - прервала его Алиса.<br>\n - Ну, конечно, - весело заметил Шалтай-Болтай и взял перевернутую Алисой книжку. - То-то я смотрю, как странно все это выглядит! Поэтому я и сказал: \"_Кажется_, здесь нет ошибки!\", - хоть я и не успел разобраться как следует... Значит, так: триста шестьдесят четыре дня в году ты можешь получать подарки на день нерожденья.<br>\n - Совершенно верно, - сказала Алиса.<br>\n - И только _один_ раз на день рожденья! Вот тебе и слава!<br>\n - Я не понимаю, при чем здесь \"слава\"? - спросила Алиса.\n</div>\nЧтобы ввести этот текст, его можно скопировать и нажать на стрелочку справа от имени свойства,\nчто позволит нам работать с многострочным текстом:\n<img src=\"images/csharp-04-04.png\">\nТеперь если запустить приложение, текстовое поле сразу будет содержать текст.\n<p>\nДобавим еще два элемента на форму. \n<ul>\n<li>Добавим кнопку, назовем ее (свойство <b>Name</b>) <b>btnShowLine</b>, и поменяем текст надписи (свойство <b>Text</b>)\nна <b>ПоказатьСтроку</b>.</li>\n<li>Добавим счетчик, назовем его <b>edtLineIndex</b>.\n</ul>\nПолучим что-то в этом роде:\n<img src=\"images/csharp-04-05.png\">\nЩелкнем дважды на кнопку <b>btnShowLine</b> и пропишем обработчик события нажатия на кнопку.\nПо нажатию на эту кнопку должно будет выскакивать <b>MessageBox</b> в котором будет содержаться\nтекст строки из поля <b>txtMain</b> под номером указанным в <b>edtLineIndex</b>.\n<pre class=\"brush: csharp\">\nprivate void btnShowLine_Click(object sender, EventArgs e)\n{\n	// считываем выбранный в edtLineIndex значение	\n	int lineIndex = (int)edtLineIndex.Value;\n	\n	// с помощью свойства Lines объекта txtMain, считываем значение выбранной строки\n	// и сохраняем его в новую переменную\n	string lineText = txtMain.Lines[lineIndex];\n	\n	//выводим значение переменной на экран\n	MessageBox.Show(lineText);\n}\n</pre>\n<div class=\"note\">\nБолее правильно было бы добавить проверку на корректность указанного номера строки,\nвдруг пользователь выберет слишком большое значение. Такая ситуация может привести к\nпадению программы, поэтому правильнее будет написать так:\n<pre class=\"brush: csharp\">\nprivate void btnShowLine_Click(object sender, EventArgs e)\n{\n	// считываем выбранный в edtLineIndex значение	\n	int lineIndex = (int)edtLineIndex.\nValue;\n	\n	// проверяем на допустимость значения индекса строки\n	if ( lineIndex >= 0 && lineIndex < txtMain.Lines.Length)\n	{\n		// с помощью свойства Lines объекта txtMain, считываем значение выбранной строки\n		// и сохраняем его в новую переменную\n		string lineText = txtMain.Lines[lineIndex];\n		\n		//выводим значение переменной на экран\n		MessageBox.Show(lineText);\n	}\n}\n</pre>\n</div>\n<p>\nДобавим еще две кнопки, \n<ul>\n<li>Первую назовем <b>btnHighlightSep</b>, и поменяем ее надпись на <b>знаки</b>. С помощью этой\nкнопки мы сможем подсветить все знаки препинания в поле ввода</li>\n<li>вторую - <b>btnResetColor</b>, и поменяем ее надпись на <b>сбросить</b>.\nС помощью этой кнопки мы сможем снять подсветку текста.</li>\n</ul>\n<img src=\"images/csharp-04-06.png\">\nКак я уже выше упомянул, текстовое поле позволяет форматировать текст, \nт.е. менять цвет, шрифт у подстрок в тексте. Для этого используется функция <b>Select</b>.\nФункция позволяет выделить подстроку в тексте. После того как кусок текста выделен, мы используя свойства вида <b>Selection*</b>\nможем изменять цвета и прочие характеристики выделенного текста.\n<p>\nНапишем обработчик события клика для кнопки <b>btnHighlightSep</b>, для этого как обычно щелкнем на нее дважды.\n<pre class=\"brush: csharp\">\nprivate void btnHighlightSep_Click(object sender, EventArgs e)\n{\n	// прощелкиваем счетчик i от 0 до кол-ва символов в тексте	\n	for (int i=0; i&lt;txtMain.TextLength; ++i)\n	{\n		 // если символ на i-ой позиции, является знаком препинания	    \n	    if (Char.IsPunctuation(txtMain.Text[i]))\n	    {\n		    /* \n		  	  выделяем этот символ, функция \n		  	  Select(начальная_позиция_выделения, количество_символов для выделения)       \n		    */ \n	        txtMain.Select(i, 1);\n	        // устанавливаем цвет фона для выделенного текста на желтый \n	        txtMain.SelectionBackColor = Color.Yellow;\n	        // устанавливаем цвет выделенного текста на красный \n	        txtMain.SelectionColor = Color.Red;\n	    }\n	}\n}\n</pre>\nТеперь можно нажать на кнопку и полюбоваться на результат.\n<br>Правда реакция на нажатие кнопки видна только при первом нажатии. Чтобы исправить \nданную ситуация, пропишем кнопке с надписью <b>сбросить</b> обработчик события клика - кликнем на нее дважды.\n<pre class=\"brush: csharp\">\nprivate void btnResetColor_Click(object sender, EventArgs e)\n{\n	// выделяем весь текст	\n	txtMain.SelectAll();\n	\n	// сбрасываем цвет фона выделенного текста на тот что по умолчанию\n	txtMain.SelectionBackColor = txtMain.BackColor;\n	\n	// сбрасываем цвет выделенного текста на тот что по умолчанию\n	txtMain.SelectionColor = txtMain.ForeColor;\n}\n</pre>\nДобавим еще одну кнопку, которая, ради смеха, позволит нам разукрасить текст в произвольные цвета.\n<ul>\n<li>Назовем ее <b>btnRandomColor</b>, и сменим ее надпись на <b>Разукрасить буквы</b></li>\n</ul>\n<img src=\"images/csharp-04-07.png\">\nНапишем обработчик события клика для новой кнопки\n<pre class=\"brush: csharp\">\nprivate void btnRandomColor_Click(object sender, EventArgs e)\n{\n	/*\n		создадим новый генератор случайных чисел\n		в соответствии с названием \n		он генерирует случайные числа\n		с помощью функции Next\n	*/	\n	Random rndGen = new Random();\n	\n	// снова пройдем счетчиком i от 0 до кол-ва символов в тексте\n	for (int i = 0; i < txtMain.TextLength; ++i)\n	{\n	    // выделяем i-ый символ	    \n	    txtMain.Select(i, 1);\n	    \n	    /*\n	    	сгенерируем новый цвет,\n	    	цвет состоит из 3-х компонент, \n	    	красной (1-ый параметр), принимаемое значение от 0 до 255\n			зеленый (2-ый параметр), принимаемое значение от 0 до 255\n			синий (3-ый параметр), принимаемое значение от 0 до 255\n			\n			rndGen.Next(256) - сгенерирует случайное число от 0 до 255\n			установив 0 для синей компоненты цвета, мы получим красно-зеленую\n			осеннюю раскраску\n		 */\n	    Color newRandomColor = \nColor.FromArgb(rndGen.Next(256), rndGen.Next(256), 0);\n\n	    // установим цвет выделенного символа на значене ново-сгенерируемого цвета\n	    txtMain.SelectionColor = newRandomColor;\n	}\n}\n</pre>\nНи и напоследок. Тут у меня фрагмент текста из книги Алиса в Зазеркалье, я просто\nчувствую себя обязанным чего-нибудь отзеркалить. Я буквы конечно вверх ногами не переверну, но продемонстрирую\nвозможность переноса текста из элемента в другой. Итак, добавим два новых элемента \n<ul>\n<li>Кнопку, назовем ее <b>btnMirror</b>, и подпишем <b>отзеркалить текст</b></li>\n<li>Поле для ввода текста (<b>RichTextBox</b>), и назовем его <b>txtMirrored</b></li>\n</ul>\n<img src=\"images/csharp-04-08.png\">\nПытаясь имитировать зеркало, мы развернем порядок букв в тексте. \nВообще говоря развернуть текст можно следующим трюком:\n<pre class=\"brush: csharp\">\n// формируем массив символов из строки\nchar[] charsArray = txtMain.Text.ToCharArray();\n// инвертируем массив символов\nArray.Reverse(charsArray);\n// формируем новую строку на основе инвертированного массива символов\ntxtMirrored.Text = new String(charsArray);\n</pre>\nНо нам кроме инвертирования самого текста хотелось бы еще сохранить и цвет, соответствующих символов, \nдля этого реализуем посимвольную раскраску текста. Пропишем обработчик события клика для кнопки <b>btnMirror</b>\n<pre class=\"brush: csharp\">\nprivate void btnMirror_Click(object sender, EventArgs e)\n{\n	// скопируем инвертированный текст из 	txtMain в txtMirrored\n	char[] charsArray = txtMain.Text.ToCharArray();\n	Array.Reverse(charsArray);\n	txtMirrored.Text = new String(charsArray);\n	\n	// пройдем счетчиком i от 0 до кол-ва символов в тексте txtMain\n	for (int i = 0; i < txtMain.TextLength; ++i)\n	{\n		 // выделяем текст в txtMirrored    \n	    txtMirrored.Select(i, 1);\n	    /*\n	    	выделяем соответствующий символ в txtMain;\n	    	напоминаю, что текст у нас развернут\n	    	и первый символ txtMirrored соответствует \n	    	последнему символу txtMain\n	    */\n	    txtMain.Select(txtMain.TextLength - i -1, 1);\n	    \n	    // копируем значения соответствующих цветов\n	    txtMirrored.SelectionColor = txtMain.SelectionColor;\n	    txtMirrored.SelectionBackColor = txtMain.SelectionBackColor;\n	}\n}\n</pre>\nСтоит отметить что посимвольное копирование цвета ОООООЧЕНЬ медленное, и если \nвы вдруг закинули в поле для текста какой-нибудь (пусть даже небольшой рассказик),\nто самым разумным будет нажать <b>Shift+F5</b>\n<div class=\"note\">\nКстати, если вы хотите наглядно видеть как происходит процесс перекраски текста, добавьте следующую\nстрочку в тело цикла:\n<pre class=\"brush: csharp\">\n	 ...\n    txtMirrored.SelectionColor = txtMain.SelectionColor;\n    txtMirrored.SelectionBackColor = txtMain.SelectionBackColor;\n	  \n	 /*\n	 	с помощью этой строчки на каждой итерации цикла,\n	 	txtMirrored будет перерисовывать себя,\n	 	(в общем случае обрабатывать сообщения от операционной системы)\n	 	это сильно замедлит программу \n	 	но зато добавит в нее вау-эффект\n	 */\n    Application.DoEvents();\n}\n</pre>\n</div>\n<hr>\n<h2>Полный листинг:</h2>\nВ отличие от консольных приложений здесь недостаточно будет\nпросто скопировать текст в редактор текста <b>Visual Studio</b>,\nтут таки придется еще и нарисовать форму, и правильно назвать все компоненты.\n<pre class=\"brush: csharp\">\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Data;\nusing System.Drawing;\nusing System.Linq;\nusing System.Text;\nusing System.Windows.Forms;\n\nnamespace WindowsFormsApplication1\n{\n    public partial class Form1 : Form\n    {\n        public Form1()\n        {\n            InitializeComponent();\n        }\n\n        private void btnShowText_Click(object sender, EventArgs e)\n        {\n            String textFromTxtMain = txtMain.Text;\n            MessageBox.Show(\ntextFromTxtMain);\n        }\n\n        private void btnShowLine_Click(object sender, EventArgs e)\n        {\n            int lineIndex = (int)edtLineIndex.Value;\n            String lineText = txtMain.Lines[lineIndex];\n            MessageBox.Show(lineText);\n        }\n\n        private void btnHighlightSep_Click(object sender, EventArgs e)\n        {\n            for (int i=0; i&lt;txtMain.TextLength; ++i)\n            {\n                if (Char.IsPunctuation(txtMain.Text[i]))\n                {\n                    txtMain.Select(i, 1);\n                    txtMain.SelectionBackColor = Color.Yellow;\n                    txtMain.SelectionColor = Color.Red;\n                }\n            }\n        }\n\n        private void btnResetColor_Click(object sender, EventArgs e)\n        {\n            txtMain.SelectAll();\n            txtMain.SelectionBackColor = txtMain.BackColor;\n            txtMain.SelectionColor = txtMain.ForeColor;\n        }\n\n        private void btnRandomColor_Click(object sender, EventArgs e)\n        {\n            Random rndGen = new Random();\n            for (int i = 0; i &lt; txtMain.TextLength; ++i)\n            {\n                txtMain.Select(i, 1);\n                Color newRandomColor\n                    = Color.FromArgb(rndGen.Next(256), rndGen.Next(256), 0);\n                txtMain.SelectionColor = newRandomColor;\n            }\n        }\n\n        private void btnMirror_Click(object sender, EventArgs e)\n        {\n            char[] charsArray = txtMain.Text.ToCharArray();\n            Array.Reverse(charsArray);\n            txtMirrored.Text = new String(charsArray);\n            for (int i = 0; i &lt; txtMain.TextLength; ++i)\n            {\n                txtMirrored.Select(i, 1);\n                txtMain.Select(txtMain.TextLength - i -1, 1);\n                txtMirrored.SelectionColor = txtMain.SelectionColor;\n                txtMirrored.SelectionBackColor = txtMain.SelectionBackColor;\n\n                Application.DoEvents();\n            }\n            \n        }\n    }\n}\n</pre>',0,4),(6,'Вопросы к колоквиуму','Вопросы к колоквиуму','Вопросы к колоквиуму','',4,'<ol>\n<li>Отличный вопрос</li>\n<li>Приличный вопрос</li>\n<li>Неприличный вопрос</li>\n<li>Сложный</li>\n<li>Так себе</li>\n</ol>',0,1),(7,'<center> \n<a style=\"text-decoration:none;\" \nhref=\"http://tealeaf.su\">&#9679;</a> \n</center>','Tealeaf','Tealeaf','',NULL,'<p align=center>\n<a href=\"../index.php/lessons/inside\" style=\"cursor:default;\"><img alt=\"watch you\" src=\"images/main_1.gif\"/></a>',1,0),(9,'Вопросы к первому коллоквиуму','Вопросы к первому коллоквиуму','Пока его у меня нет','',4,'<ol>\r\n<li>Множества (пустое множество,  подмножество, операции над множествами, парадокс Рассела, теорема о мощности булеана множества).</li>\r\n<li>Отношения (свойства бинарных, эквивалентность отношений и функций).</li>\r\n<li>Отношение эквивалентности (свойства, разбиение на классы эквивалентности).</li>\r\n<li>Пропозициональные связки. Таблицы истинности. Формулы.</li>\r\n<li>Тавтологии. Противоречия.</li>\r\n<li>Полные системы связок (примеры полных систем состоящих из 2-х связок, из 1-ой связки).</li>\r\n<li>Аксиоматическая теория L (определение, аксиомы).</li>\r\n<li>Вывод в формулах исчисления высказываний (ФИВ).</li>\r\n<li>Теорема дедукции в ФИВ.</li>\r\n</ol>',1,1);
/*!40000 ALTER TABLE `articles` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `categories`
--

DROP TABLE IF EXISTS `categories`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `categories` (
  `id_` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(128) NOT NULL,
  `title_menu` varchar(128) NOT NULL,
  `title_page` varchar(128) NOT NULL,
  `description` varchar(128) NOT NULL DEFAULT '',
  `controller` tinytext NOT NULL,
  `parent_id` int(11) DEFAULT NULL,
  `ord` int(11) NOT NULL DEFAULT '0',
  PRIMARY KEY (`id_`),
  UNIQUE KEY `id_` (`id_`),
  KEY `id__2` (`id_`),
  KEY `id__3` (`id_`)
) ENGINE=MyISAM AUTO_INCREMENT=11 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `categories`
--

LOCK TABLES `categories` WRITE;
/*!40000 ALTER TABLE `categories` DISABLE KEYS */;
INSERT INTO `categories` VALUES (1,'','Занятия','','','lessons',-1,0),(2,'Практикум по C#','&#9632;&#9632;&#9632;','','C# ','lessons/csharp',NULL,2),(4,'Математическая логика','&#x25B2;&#x25B2;','','Математическая логика','lessons/mlogic',NULL,1),(5,'','Контрольные Работы','','','',-1,0),(6,'','Скрипты','','','',-1,0),(8,'','Вопросы к колоквиуму','','','coloclvium',-1,0),(9,'','&#x25B2;','','Главная страница','',NULL,0);
/*!40000 ALTER TABLE `categories` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2013-10-03 22:08:38
