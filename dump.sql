-- phpMyAdmin SQL Dump
-- version 3.5.2.2
-- http://www.phpmyadmin.net
--
-- Хост: 192.168.100.102:3306
-- Время создания: Окт 14 2013 г., 18:56
-- Версия сервера: 5.1.69
-- Версия PHP: 5.4.8

SET SQL_MODE="NO_AUTO_VALUE_ON_ZERO";
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;

--
-- База данных: `mmailmm8_data`
--
DROP DATABASE `mmailmm8_data`;
CREATE DATABASE `mmailmm8_data` DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;
USE `mmailmm8_data`;

-- --------------------------------------------------------

--
-- Структура таблицы `articles`
--

DROP TABLE IF EXISTS `articles`;
CREATE TABLE IF NOT EXISTS `articles` (
  `id_` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(128) NOT NULL,
  `title_menu` varchar(128) NOT NULL,
  `title_page` varchar(128) NOT NULL,
  `description` varchar(128) NOT NULL DEFAULT '',
  `category_id` int(11) DEFAULT NULL,
  `text` text NOT NULL,
  `enabled` tinyint(4) NOT NULL DEFAULT '1',
  `ord` int(11) NOT NULL DEFAULT '0',
  PRIMARY KEY (`id_`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=14 ;

--
-- Дамп данных таблицы `articles`
--

INSERT INTO `articles` (`id_`, `title`, `title_menu`, `title_page`, `description`, `category_id`, `text`, `enabled`, `ord`) VALUES
(2, 'Работа с консолью', 'Работа с консолью', 'Работа с консолью', '', 2, ' Для того чтобы писать приложения на <b>C#</b> совсем не обязательно скачивать тяжеловесную <b>Visual Studio 2010</b>, вполне хватит и <b>Express</b> версии,\r\nкоторая является бесплатной (в том числе и для коммерческой разработки) весит в 6 раз меньше и отличается от полноценной студии \r\nлишь отсутствием некоторых встроенных инструментов, которыми вы скорее всего никогда (по крайне мере в студенческой жизни) не воспользуетесь.\r\nСкачать можно отсюда \r\n<a href="http://download.microsoft.com/download/1/E/5/1E5F1C0A-0D5B-426A-A603-1798B951DDAE/VS2010Express1.iso">Visual Studio 2010 Express All-in-One ISO</a>.\r\nВообще говоря можно скачать и <b>Visual Studio 2012 Express</b>, но я не уверен запустятся ли ваши программы на машинах что стоят в аудитории.\r\n<p>\r\nСкачав образ диска его можно записать на диск, либо примонтировать с помощью например <b>DaemonTools</b>. И установить <b>Visual C# 2010 Express</b>.\r\nСтоит отметить что установленную программу надо зарегистрировать. Скорее всего программа сама предложит это вам через некоторое время.\r\nПри регистрации придется указать свой <b>email</b>. Я указал одну из своих вполне рабочих почт, и за 3 года никакого спама не было. \r\nПри регистрации вам выдадут ключик.\r\n<hr>\r\n<p>\r\nЛюбая программа на <b>C#</b> имеет следующую базовую конструкцию\r\n<pre class="brush: csharp">\r\nusing System;\r\nusing КакойТоВторойПакет;\r\nusing КакойТоТретийПакет;\r\n...\r\nusing КакойТо100500ыйПакет;\r\n\r\n\r\nnamespace Some_Namespace_Name\r\n{\r\n    // Любая программа является классом\r\n    class Some_Program\r\n    {\r\n        // тут начинается исполнение программы\r\n        static void Main(string[] args)\r\n        {\r\n            ...\r\n        }\r\n    }\r\n}\r\n</pre>\r\n<div class="note">\r\nСоздавая новую программу, <b>VisualStudio</b> автоматически создает так называемое пространство имен (в нашем случае <b>Some_Namespace_Name</b>), \r\nкоторое можно использовать при разработке другого приложения с помощью тех же операторов <b>using</b>, что у нас идут в самом начале программы.\r\n</div>\r\n<p>\r\nТут я покажу как в <b>C#</b> приложении запросить у пользователя список чисел, \r\nи в качестве результата вывести на экран четные числа из этого списка.\r\n<pre class="brush: csharp">\r\nusing System;   // подключение пространства имен для использования основных типов данных\r\n                // int, String, String[], int[] и т.д. а также объекта Console\r\n\r\nnamespace ConsoleApplication1\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            /* все что находится между открывающей и закрывающей  \r\n               фиугрными скобками называется телом функции */\r\n            ...\r\n        }\r\n    }\r\n}\r\n</pre>\r\nВесь последующий код надо записывать в тело функции <b>static void Main(string[] args)</b>\r\n<p>\r\nСначала нам надо выделить переменные которые мы будем использовать для хранения\r\nстроки введенной пользователем, и под массив подстрок на которые мы разобьем введенную строку.\r\n<pre class="brush: csharp">\r\n// сюда сохраним строку введенную пользователем\r\nString strNumbers; \r\n// это массив для подстрок входящих в строку\r\nString[] strNumbersList;\r\n</pre>\r\n\r\nЧерный экран консоли с серыми буквами уж больно депрессивен, \r\nтак что почему бы и не добавить в него капельку радости:\r\n<pre class="brush: csharp">\r\n// установим заголовок консоли\r\nConsole.Title = "Я заголовок этой мрачной консоли T_T";\r\n// меняем цвет текста на голубой\r\nConsole.ForegroundColor = ConsoleColor.Cyan;\r\n// меняем цвет фона текста на темно-синий\r\nConsole.BackgroundColor = ConsoleColor.DarkBlue;\r\n</pre>\r\nЗапрос данных у пользователя:\r\n<pre class="brush: csharp">\r\n// выводим на экран предложение ввести числа\r\nConsole.WriteLine("Введите числа через пробел:");\r\n\r\n/* \r\n   приостанавливаем выполнения до тех пор пока пользователь не введет \r\n   некоторый текст и не нажмет ENTER,\r\n   введенную строку сохраним в переменную strNumbers\r\n*/\r\nstrNumbers = Console.ReadLine();\r\n</pre>\r\nНу вроде строку текста от пользователя получили, теперь не плохо бы чего-нибудь с ней сделать.\r\nТак как предполагается что пользователь ввел нам список чисел через пробел, мы разобьем пробелами нашу\r\nстроку на подстроки. Разбивается строка функцией <b>Split</b>. \r\n\r\n<pre class="brush: csharp">\r\n// разобьем введенную пользователем сторку пробелами на подстроки\r\nstrNumbersList = strNumbers.Split('' '');\r\n</pre>\r\n\r\n<div class="note">\r\nВсе переменный типа <b>String</b> обладают функцией <b>Split</b>,\r\nв качестве результат она возвращает массив строк, полученный разбиением строки разделителем указанным в качестве параметра.\r\n<pre class="brush: csharp">\r\nsome_variable.Split('' '');\r\n</pre>\r\nЕсли хочется использовать более одного разделителя (например пробел и запятую) придется написать уже вот-такое заклинание\r\n<pre class="brush: csharp">\r\nsome_variable.Split( new Char[]{'' '' , '',''} );\r\n\r\n// или так, указывать тип массива не обязательно, в данном случае компилятор сам догадается по содержимому\r\nsome_variable.Split( new []{'' '' , '',''} );\r\n\r\n// или так чтобы убрать пустые строки которые возникают, если у нас например два пробела подряд\r\nsome_variable.Split( new []{'' '' , '',''}, StringSplitOptions.RemoveEmptyEntries );\r\n</pre>\r\n</div>\r\n<p>\r\nИногда вам захочется сбросить цвета в консоли на те что идут по умолчанию, для этого у объекта <b>Console</b>\r\nесть метод <b>ResetColor</b>. Я сброшу цвета консоли на те унылые, что были по умолчанию и выведу сообщение о том,\r\nчто я сейчас я собираюсь вывести список четных чисел:\r\n<pre class="brush: csharp">\r\n// сбрасываем цвет фона и текста на скучные >_>\r\nConsole.ResetColor();\r\n// выводим на экран сообщение; это хорошая практика всегда держать пользователя в курсе событий\r\nConsole.WriteLine("Среди введенных чисел, следующие числа являются четными:");\r\n</pre>\r\nНу а теперь собственно то ради всего и затевалось, это вывод четных чисел на экран, каждое число в своей строчке.\r\n<br>Перво наперво я верну свои веселые цвета:\r\n<pre class="brush: csharp">\r\n// меняем цвет текста на голубой\r\nConsole.ForegroundColor = ConsoleColor.Cyan;\r\n// меняем цвет фона на темно-синий\r\nConsole.BackgroundColor = ConsoleColor.DarkBlue; \r\n</pre>\r\nНу и вторым шагом собственно сам вывод\r\n<pre class="brush: csharp">\r\n// проход по всем элементам массива strNumbersList, \r\n// свойство Length, очевидно, содержит количество элементов в массиве\r\nfor (int i = 0; i < strNumbersList.Length; ++i)\r\n{\r\n    // преобразуем подстроку в целое число\r\n    int num1 = int.Parse( strNumbersList[i] );  /* для доступа к i-му элементу массива\r\n                                                   используется операция индексации\r\n                                                   проще говоря чтобы узнать значение \r\n                                                   i-го элемента надо написать \r\n                                                   что-то вроде some_array[i], \r\n                                                  \r\n                                                   для 1-го элемента some_array[0]\r\n                                                   для 2-го элемента some_array[1]\r\n                                                   ...\r\n                                                   для последнего some_array[ some_array.Length - 1 ]\r\n                                                   да да нумерация с начинается с нуля!\r\n                                                */\r\n                                                \r\n    // проверяем делиться ли число на 2 без остатка, то есть по сути проверка на четность\r\n    if (num1 % 2 == 0)\r\n    {\r\n        // если так выведем на экран это число\r\n        Console.WriteLine(num1);\r\n    }\r\n}\r\n</pre>\r\n<div class="note">\r\nВ C# четыре вида циклов:\r\n<pre class="brush: csharp">\r\n// 1. Стандартный сишный цикл. Перебор i от 0 до max_value - 1\r\nfor ( i=0; i < max_value; i++ ) \r\n{\r\n    ...\r\n}\r\n\r\n// 2. Цикл для работы с массивами и коллекциями. Проходит по всем элементам коллекции.\r\n// Не позволяет изменять значения коллекции, только смотреть их значение.\r\nforeach (SomeType value in some_array) \r\n{\r\n    ...\r\n}\r\n\r\n// ну и условные циклы\r\n\r\n// 3. С предусловием, запуститься только если условие истинно\r\nwhile( %some_condition_is_true% ) \r\n{\r\n    ...\r\n}\r\n\r\n// 4. С постусловием, обязательно сделает один тик, и только\r\n// потом пойдет проверять истинность условия\r\ndo\r\n{\r\n    ...\r\n}\r\nwhile( %some_condition_is_true% ) \r\n</pre>\r\nА вот цикла вида <b>do ... until</b> - нет. Ну и пусть.\r\n<br> Мы будем использовать в основном циклы вида 1 и 2. \r\n</div>  \r\n<p>\r\nНу и последним шагом надо дать возможность пользователю рассмотреть выведенные числа.\r\nДля этого мы приостановим программу до тех пор пока пользователь не нажмет какую-нибудь клавишу.\r\n<pre class="brush: csharp">\r\n// Иначе консоль автоматически закроется\r\n// и весь вывод улетит в небытие...\r\nConsole.ReadKey();\r\n</pre>\r\nВот и весь код \\(^_^)/\r\n<hr>\r\n<h2>Результат работы:</h2>\r\n<div class="console"> \r\n<span style="background:DarkBlue;color:Cyan">\r\nВведите числа через пробел:<br>\r\n12 123 78 3 2<br>\r\n</span>\r\nСреди введенных чисел, следующие числа являются четными:<br>\r\n<span style="background:DarkBlue;color:Cyan">\r\n12<br>\r\n78<br>\r\n2\r\n</span>\r\n</div>\r\n<hr>\r\n<h2>Полный листинг:</h2>\r\n\r\n<pre class="brush: csharp;">\r\nusing System;\r\nusing System.Linq;\r\n\r\nnamespace ConsoleApplication1\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            // сюда сохраним строку введенную пользователем\r\n            String strNumbers; \r\n            // это массив для подстрок входящих в строку\r\n            String[] strNumbersList; \r\n\r\n            Console.Title = "Я заголовок этой мрачной консоли T_T";\r\n\r\n            // меняем цвет текста на голубой\r\n            Console.ForegroundColor = ConsoleColor.Cyan;\r\n            // меняем цвет фона на темно-синий\r\n            Console.BackgroundColor = ConsoleColor.DarkBlue;\r\n\r\n            // выводим на экран предложение ввести числа\r\n            Console.WriteLine("Введите числа через пробел:");\r\n            // приостанавиливаем выполнения до тех пор пока пользователь не введет \r\n            // некоторый текст и не нажмет ENTER,\r\n            // введенную строку сохраним в переменную strNumbers\r\n            strNumbers = Console.ReadLine();\r\n\r\n            // разобьем введенную пользователем сторку пробелами на подстроки\r\n            strNumbersList = strNumbers.Split('' '');\r\n\r\n            // сбрасываем цвет фона и текста на те что идут по умолчанию\r\n            Console.ResetColor();\r\n            // выводим на экран сообщение\r\n            Console.WriteLine("Среди введенных чисел, следующие числа являются четными:");\r\n\r\n            // меняем цвет текста на голубой\r\n            Console.ForegroundColor = ConsoleColor.Cyan;\r\n            // меняем цвет фона на темно-синий\r\n            Console.BackgroundColor = ConsoleColor.DarkBlue; \r\n\r\n            /// перебираем все элементы массива, нумерация элементов массива начинается от 0\r\n            for (int i = 0; i < strNumbersList.Length; ++i)\r\n            {\r\n                // преобразуем подстроку в целое число\r\n                int num1 = int.Parse(strNumbersList[i]);\r\n                // проверяем является число делиться ли оно на 2 без остатка\r\n                if (num1 % 2 == 0)\r\n                {\r\n                    // если так выведем на экран это число\r\n                    Console.WriteLine(num1);\r\n                }\r\n            }\r\n            // Иначе консоль автоматически закроется\r\n            // и весь вывод улетит в небытие...\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}\r\n</pre>\r\n<hr>\r\n<h2>Альтернативные варианты:</h2>\r\nВообще говоря получить тот же результат можно еще как минимум 5 способами, я их на всякий пожарный оставлю здесь \r\nвдруг пригодится:\r\n<p>\r\n<div class="note">\r\n<h3>Способ #2.</h3>\r\n С использованием цикла <b>foreach</b>. Наверное самый лучший способ в подобной ситуации. Я б использовал именно его.\r\n<pre class="brush: csharp">\r\nforeach (String subString in strNumbersList)\r\n{\r\n    // преобразуем подстроку в целое число\r\n    int num2 = int.Parse(subString);\r\n    // проверяем делиться ли число на 2 без остатка\r\n    if (num2 % 2 == 0)\r\n    {\r\n        // если так выведем на экран это число\r\n        Console.WriteLine(num2);\r\n    }\r\n}\r\n</pre>\r\n<h3>Способ #3.</h3>\r\nБолее хитрый способ с использованием встроенного языка <b>Linq</b>. \r\nГлавное не забыть вверху подключить пространство имен System.Linq:\r\n<pre class="brush: csharp">\r\nusing System;\r\nusing System.Linq; // для использования функции Select\r\n\r\n...\r\n\r\n// формируем из массива подстрок массив целых чисел,\r\n// для этого используется функция Select\r\n// ей в качестве параметра передается функция которая применяется\r\n// к каждому элементу массива strNumbersList.\r\n// ToArray() - необходимо чтобы преобразовать резульат функции Select в массив\r\nint[] intArray = strNumbersList.Select(int.Parse).ToArray();\r\nforeach (int num3 in intArray)\r\n{\r\n    // проверяем делиться ли число на 2 без остатка\r\n    if (num3 % 2 == 0)\r\n    {\r\n        // если так выведем на экран это число\r\n        Console.WriteLine(num3);\r\n    }\r\n}\r\n\r\n</pre>\r\n<h3>Способ #4.</h3> Еще более хитрый способ с использованием лямбда выражений (это та часть что "<b>x => x % 2 == 0</b>"). \r\nОказывается за один шаг можно преобразовать массив строк в массив целых чисел и сразу же отсеять нечетные числа:\r\n<pre class="brush: csharp">\r\nint[] evenNumbers = strNumbersList.Select(int.Parse).Where(x => x % 2 == 0).ToArray();\r\nforeach (int num4 in evenNumbers)\r\n{\r\n        // выведем на экран число\r\n        Console.WriteLine(num4);\r\n}\r\n</pre>\r\n<h3>Способ #5.</h3> \r\nБез использования цикла. С использованием функции <b>Join</b>. Функция <b>Join</b> является обратной для функции <b>Split</b>\r\nи позволяет склеить массив строк в одну строку. Между каждыми элементами массива можно указать разделитель. \r\nОказывается строку можно вывести как несколько строк для этого надо каждую подстроку отделить от другой \r\nсимволом перехода на новую строку <b>"\\n"</b> (в <b>VBS</b> это была константа <b>VbCrLf</b>). Например:<br>\r\nСтрока <span class="consoleIn">"Пожалуй хватит\\nна сегодня сишарпа"</span> в консоли будет выведена как:\r\n<div class="console">\r\nПожалуй хватит<br>\r\nна сегодня сишарпа\r\n</div>\r\nСпособ выглядит вот так:\r\n<pre class="brush: csharp">\r\n// здесь мы одной строкой преобразовываем все подстроки к числам,\r\n// и среди этих чисел выбираем четные числа\r\nint[] evenNumbers2 = strNumbersList.Select(int.Parse).Where(x => x % 2 == 0).ToArray();\r\n\r\n// из массива целых чисел формируем массив строк\r\nString[] evenNumbersStr = evenNumbers2.Select(x => x.ToString()).ToArray();\r\n\r\n// склеиваем все элементы масива строк в одну большую строку outputString\r\n// String.Join(%разделитель строк%, %массив_строк%) возвращает объедененую строку\r\n// "\\n" - знак обозначает переход на новую строку\r\nString outputString = String.Join("\\n", evenNumbersStr);\r\n\r\n// выводи эту строку на экран\r\nConsole.WriteLine(outputString);\r\n</pre>\r\n<h3>Способ #6.</h3> \r\nСтоит отметить, что способ 5 умещается в одну длинную мультикоманду.\r\nНе рекомендуется к использованию, так как сильно затрудняет восприятие кода,\r\n\r\n<pre class="brush: csharp">\r\nConsole.WriteLine(String.Join("\\n",strNumbersList.Select(int.Parse).Where(x => x % 2 == 0).Select(x => x.ToString()).ToArray()));\r\n</pre>\r\n</div>', 1, 1),
(3, 'Коллекции', 'Коллекции', 'Коллекции', '', 2, 'Коллекции являются своего рода динамическим массивами. Я собираюсь рассмотреть работу с коллекциями \r\nна примере списков (List) и словарей (Dictionary).\r\nСоздадим обыкновенное консольное приложение\r\n<pre class="brush: csharp">\r\nusing System; // подключим пространство имен для работы с онсновными типами и консолью\r\nusing System.Collections.Generic; // для работы с коллекциями\r\nusing System.Linq; // для использование встроенного языка Linq\r\n\r\nnamespace ConsoleApplication1\r\n{\r\n	class Program\r\n	{\r\n		static void Main(string[] args)\r\n		{\r\n            \r\n		}\r\n	}\r\n}\r\n</pre>\r\nОпять же весь код ниже надо будет вписать в тело функции <b>static void Main(string[] args).</b>\r\n<p>\r\nВ данном приложении я для ускорения процесса, "захардкодю" строку ввода, чтобы не вводить ее по 100 раз.\r\nИ хотя работать я собираюсь сегодня со списком чисел, я намерено добавлю паразитных элементов в строку.\r\n<pre class="brush: csharp">\r\n/* \r\n	чтобы положить чего то в строку совсем необязательно \r\n	запорашивать это "чего-то" от пользователя, можно явно указать строку\r\n*/\r\nString strNumbers = "123 bz 12, 53, asd 7 91 15";\r\n</pre>\r\nЧтобы разбить строку на подстроки, а тут в качестве разделителей используется не только пробелы но и запятые,\r\nпридется использовать усложненную версию функции <b>Split</b>\r\n<pre class="brush: csharp">\r\n// массив разделителей\r\nChar[] separators = new Char[] { '' '', '','' };\r\n\r\n/* \r\n	Создаем переменную для хранения списка строк, \r\n	полученных путем разбиения сторки strNumbers \r\n	разделителями из массива separators.\r\n\r\n	Второй параметр устанавливаем на StringSplitOptions.RemoveEmptyEntries\r\n	чтобы избежать появления пустых строк в массиве strNumbersArray,\r\n	которые возникают если два разделителя стоят рядом (например два подряд идущих пробела) \r\n*/\r\nString[] strNumbersArray = strNumbers.Split(separators, StringSplitOptions.RemoveEmptyEntries);\r\n</pre>\r\n<hr>\r\n<h2>Списки. Тип List&#60;int&#62;</h2>\r\nТак как нашей целью является изучить возможности работы со списками, необходимо этот список создать.\r\nДля большинства объектов (типов) с которыми вы столкнетесь необходимо будет использование оператор new.\r\n<pre class="brush: csharp">\r\n/* \r\n	Данное предложение читается справа налево, т.е. \r\n	создать в памяти объект типа List&ltint&gt (список целых чисел),\r\n	и установить numbers как ссылку на этот объект\r\n*/\r\nList&ltint&gtnumbers = new List&ltint&gt();\r\n</pre>\r\nТеперь этот список надо наполнить числами полученные преобразованием элементов массива <b>strNumbersArray</b> в числа.\r\nОчевидно что не все элементы массива <b>strNumbersArray</b> являются числами, если вывести сейчас массив <b>strNumbersArray</b> на экран \r\nто мы увидим примерно следующую картину:\r\n<div class="console">\r\n123<br>\r\nbz<br>\r\n12<br>\r\n53<br>\r\nasd<br>\r\n7<br>\r\n91<br>\r\n15<br>\r\n</div>\r\nОчевидно, что <span class="consoleIn">bz</span> и <span class="consoleIn">asd</span> не являются числами.\r\nДля заполнения списка числами мы будем использовать цикл <b>foreach</b> внутри которого будет вызываться функция\r\n<b>TryParse </b>которая позволяет проверить строку на ее возможность преобразования в число, если такая возможность\r\nесть то в она возвращает true и во второй параметр передает результат преобразования.\r\n\r\n<pre class="brush: csharp">\r\n// проходим по всем подстрокам\r\nforeach (Strig strNumber in strNumbersArray)\r\n{\r\n	int num;\r\n	/*\r\n		тут мы проверяем можно ли преобразовать строку в число\r\n		если преобразование возможно то результат преобразования\r\n		будет положен в переменную num, которую мы создали шагом выше\r\n	*/\r\n	if ( int.TryParse(strNumber, out num) == true )\r\n	{\r\n		numbers.Add(num);\r\n	}\r\n}\r\n</pre>\r\n\r\n<div class="note">\r\nФункция объекта <b>int</b> по имени <b>TryParse</b> представляет собой функцию возвращающая сразу два значение \r\n<pre class="brush: csharp">\r\nint.TryParse(strNumber, out num)\r\n</pre>\r\nПервое значение мы используем когда сравниваем значения функции с константой <b>true</b>\r\n<pre class="brush: csharp">\r\n// не обращаем внимание на многоточие\r\nif ( int.TryParse( ... ) == true )\r\n...\r\n// можно было записать это и так выделив дополнительную переменную \r\n// для сохранения результата функции\r\nbool tryParseResult = int.TryParse( ... );\r\nif ( tryParseResult == true )\r\n...\r\n</pre>\r\nЭта же функция в случае успешной конвертации возвращает еще одно значение, \r\nоно передается во второй параметр. Чтобы получить к нему доступ необходимо \r\nсоздать дополнительную переменную и передать ее в качестве второго параметра \r\nвместе с ключевым словом <b>out</b>:\r\n<pre class="brush: csharp">\r\n...\r\n// создаем переменную для хранения результата преобразования\r\nint num;\r\n// пытаемся преобразовать строку some_string в число\r\nif ( int.TryParse(some_string, out num) ) \r\n{\r\n	// если преобразование было успешным то выводим на экран это число	\r\n	Console.WriteLine(num);\r\n} \r\nelse \r\n{\r\n	// в случае неудачи сообщим что данная строка не является числом	\r\n	Console.WriteLine(some_string + " не является числом >_>");\r\n}\r\n</pre>\r\nТо есть должно быть очевидно, что если <b>some_string == "123"</b>, \r\nна консоле увидим:\r\n<div class="console">\r\n123\r\n</div>\r\nЕсли же <b>some_string == "фонарик"</b>, на консоле увидим:\r\n<div class="console">\r\nфонарик не является числом >_>\r\n</div>\r\n</div>\r\n<p>\r\nПосле выполнения всех этих операций список <b>numbers</b> будет содержать \r\nчисла, (если быть точным, то с учетом того какую строку мы задали \r\nв списке будут числа <b>123, 12, 53, 7, 91, 15</b>, именно в таком порядке)\r\n<p>\r\nТеперь выведем их на экран\r\n<pre class="brush: csharp">\r\n// сообщим пользователю о том что собираемся показать все числа в списке\r\nConsole.WriteLine("Исходный список:");\r\n\r\n// выведем список на экран\r\nforeach(int number in numbers) Console.Write(number + " ");\r\n\r\n/*\r\n	так как фукнция Console.Write в отличие от Console.WriteLine \r\n	не переводит курсор на новую строку, то я вызову функцию Console.WriteLine \r\n	чтобы такое переход осуществить собственноручно\r\n*/\r\nConsole.WriteLine();\r\n</pre>\r\nУпорядочивание элементов в C# -- милое дело, все делается в одну-две команды\r\n<h4>Сортировка по возрастанию</h4>\r\n<pre class="brush: csharp">\r\n// функция Sort сортирует элементы списка в порядке возрастания\r\nnumbers.Sort();\r\n\r\n// вывод на экран\r\nConsole.WriteLine("Упорядоченный по возрастанию:");\r\nforeach(int number in numbers) Console.Write(number + " ");\r\nConsole.WriteLine();\r\n</pre>\r\n\r\n<h4>Сортировка по убыванию</h4>\r\n<pre class="brush: csharp">\r\n// сначала отсортируем по возрастанию \r\nnumbers.Sort();\r\n// а потом развернем список \r\n// вообще не самый эффективный способ, \r\n// но вполне пригодный для небольших списков\r\nnumbers.Reverse();\r\n\r\n// вывод на экран\r\nConsole.WriteLine("Упорядоченный по возрастанию:");\r\nforeach(int number in numbers) Console.Write(number + " ");\r\nConsole.WriteLine();\r\n</pre>\r\n<div class="note">\r\nБолее эффективным способом упорядочения списка по убыванию, заключается в явном указании функции сортировки:\r\n<pre class="brush: csharp">\r\nnumbers.Sort( (num1, num2) => num2.CompareTo(num1) );\r\n</pre>\r\nЗдесь используется лямбда-выражение, которым реализуется функция от двух параметров \r\nвозвращающая<br>\r\n<b>-1</b> если <b>num1 > num2</b>,<br>\r\n<b>1</b> если <b>num1 < num2</b><br> \r\n<b>0</b> если они совпадают.\r\n</div>\r\n<h4>Количество элементов в списке</h4>\r\n<pre class="brush: csharp">\r\nConsole.Write"Количество элементов в списке: ");\r\n// используем свойстве списка count\r\nConsole.WriteLine(numbers.count);\r\n</pre>\r\n\r\n<h4>Минимальный элемент</h4>\r\n<pre class="brush: csharp">\r\n/*\r\n	в отличие от количества элементов, под минимальный элемент\r\n	лучше создать переменную, так как при каждом вызове функции Min\r\n	этот элемент ищется заново\r\n*/\r\nint minimum = numbers.Min();\r\n\r\nConsole.Write("Минимальный элемент: ");\r\nConsole.WriteLine(minimum);\r\n</pre>\r\n\r\n<h4>Максимальный элемент</h4>\r\n<pre class="brush: csharp">\r\n/*\r\n	и под максимальный элемент лучше создать переменную, \r\n	так как при каждом вызове функции Max\r\n	этот элемент также ищется заново.\r\n*/\r\nint maximum = numbers.Max();\r\n\r\nConsole.Write("Максимальный элемент: ");\r\nConsole.WriteLine(maximum);\r\n</pre>\r\n<hr>\r\n<h2>Словари. Тип Dictionary&#60;String, String&#62;</h2>\r\nСловари позволяют нам хранить пары вида (ключ, значение). Наилучшим примером объекта типа словарь,\r\nявляется, как бы это странно это не звучало, обычный словарь. Например русско-английский. Я продемонстрирую\r\nкак сделать словарь который будет переводить предложения не хуже печально известного Промта. \r\n<p>\r\nКак и любой объект сложнее <b>int</b> (ну или <b>String</b>, <b>float</b>, <b>long</b> и т.п.), словарь надо создавать с помощью оператора <b>new</b>:\r\n<pre class="brush: csharp">\r\nDictionary&lt;String, String&gt; dictionary = new Dictionary&lt;string, string&gt;();\r\n/*\r\n	не обязательно указывать тип явно можно написать и так\r\n	var dictionary = new Dictionary&lt;string, string&gt;();\r\n*/\r\n</pre>\r\n\r\nТеперь добавим несколько слов в наш словарь\r\n<pre class="brush: csharp">\r\n// первый параметр функции Add это ключ, второй - значение\r\ndictionary.Add("яблоко", "apple");\r\ndictionary.Add("мороженое", "icecream");\r\ndictionary.Add("чай", "tea");\r\n</pre>\r\nВыводим содержимое словаря на экран\r\n<pre class="brush: csharp">\r\nforeach (var pair in dictionary)\r\n{\r\n	/*\r\n	  Тут мы используем форматирование выводимого текста\r\n	  {0} - будет заменено на второй параметр функции WriteLine (т.е на значение pair.Key)\r\n	  {1} - будет заменено на третий параметр функции WriteLine (т.е на значение pair.Value)\r\n	  \r\n	  Аналогично можно добавить {2} - если у нас вдруг появиться какой-то третий параметр \r\n	*/	\r\n	Console.WriteLine("{0} по-английски {1}", pair.Key, pair.Value);\r\n}\r\n</pre>\r\nДобавим следующее приложение:\r\n<pre class="brush: csharp">\r\nString sentence = "Я пожалуй возьму яблоко, мороженое и чай";\r\n</pre>\r\nИ воспользуемся нашим словарем для перевода (так как в нашем словаре только три слова,\r\nследовательно и перевести мы сможем  только три слова, ну для начала и так не плохо :D \r\n<pre class="brush: csharp">\r\n// сначала покажем исходное предложение\r\nConsole.WriteLine(sentence);\r\n\r\n/*\r\n	собственно тут и осуществляется перевод,\r\n	для упрощения, я вместо того чтобы искать \r\n	слова из текста в словаре, будут искать \r\n	слова из словаря в тексте. \r\n	\r\n	Нелогично, зато код во много раз проще,\r\n	иначе бы мне пришлось разбивать текст \r\n	на слова, искать каждое слово в словаре,\r\n	а потом еще эти слова уже склеивать обратно\r\n	в предложение, что, вообще говоря, является\r\n	нетривиальной задачей.\r\n*/\r\n\r\nforeach (var wordPair in dictionary)\r\n{\r\n	/*\r\n	  Функция Replace ищет в строке для которой она вызывается\r\n	  значение первого параметра и заменяет его значением второго параметра.\r\n	  \r\n	  В качестве результата  возвращает новую строку которая является\r\n	  преобразованным предложением.\r\n	  \r\n	  Тут мы присваиваем значение функции самой строке, чтобы на следующей\r\n	  итерации цикла уже использовалось новое предложение \r\n	  в котором часть слов уже переведена\r\n	*/	 \r\n	 sentence = sentence.Replace(wordPair.Key, wordPair.Value);\r\n}\r\n\r\n// вывод на экран переведенного предложения\r\nConsole.WriteLine(sentence);\r\n</pre>\r\nНу и последним шагов приостанавливаем работу программы в ожидании нажатия любой клавиши\r\nпользователем, иначе консолька автоматически закроется.\r\n<pre class="brush: csharp">\r\n// ожидаем нажатия любой клавиши пользователем\r\nConsole.ReadKey();\r\n</pre>\r\n\r\n<hr>\r\n<h2>Результат работы:</h2>\r\n<div class ="console">\r\nИсходный список:<br>\r\n123 12 53 7 91 15<br>\r\nУпорядоченный по возрастанию:<br>\r\n7 12 15 53 91 123 <br>\r\nУпорядоченный по убыванию:<br>\r\n123 91 53 15 12 7 <br>\r\nКоличество элементов: 6<br>\r\nМинимальный элемент: 7<br>\r\nМаксимальный элемент: 123<br>\r\nмороженое по-английски icecream<br>\r\nчай по-английски tea<br>\r\nяблоко по-английски apple<br>\r\nЯ пожалуй возьму яблоко, мороженое и чай<br>\r\nЯ пожалуй возьму apple, icecream и tea<br>\r\n_\r\n</div>\r\n<hr>\r\n<h2>Полный листинг:</h2>\r\n<pre class="brush: csharp">\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\n\r\n\r\nclass Program\r\n{\r\n    static void Main(string[] args)\r\n    {\r\n        // чтобы положить чего то в строку совсем необязательно \r\n        // заправшивать чего-то от пользователя, можно явно указать строку\r\n        String strNumbers = &quot;123 bz 12, 53, asd 7 91 15&quot;;\r\n\r\n        // разбиваем строку запятыми и пробелами, и убираем за одно пустые строки\r\n        Char[] separators = new Char[] { &apos; &apos;, &apos;,&apos; };\r\n        String[] strNumbersArray = strNumbers.Split(separators, StringSplitOptions.RemoveEmptyEntries);\r\n\r\n        List&lt;int&gt; numbers = new List&lt;int&gt;(); // создаем динамический список\r\n\r\n        // проходим по всем подстрокам\r\n        foreach (String strNumber in strNumbersArray)\r\n        {\r\n            int num;\r\n            // тут мы проверяем можно ли преобразовать строку в число\r\n            if (int.TryParse(strNumber, out num))\r\n            {\r\n                numbers.Add(num);\r\n            }\r\n        }\r\n\r\n        Console.WriteLine(&quot;Исходный список:&quot;);\r\n        foreach(int number in numbers) Console.Write(number + " ");\r\n        Console.WriteLine();\r\n\r\n        // функция Sort сортирует элменты массива в порядке возрастания\r\n        numbers.Sort();\r\n        \r\n        Console.WriteLine(&quot;Упорядоченный по возрастанию:&quot;);\r\n        foreach(int number in numbers) Console.Write(number + " ");\r\n        // чтобы не слипалось со следующем выводом\r\n        Console.WriteLine();\r\n\r\n        // упорядочим список по убыванию\r\n        numbers.Sort();\r\n        numbers.Reverse();\r\n        \r\n        Console.WriteLine(&quot;Упорядоченный по убыванию:&quot;);\r\n        foreach(int number in numbers) Console.Write(number + " ");\r\n        Console.WriteLine();\r\n\r\n		  Console.Write(&quot;Количество элементов: &quot;);\r\n        Console.WriteLine(numbers.Count);\r\n\r\n        int minimum = numbers.Min();\r\n        Console.Write(&quot;Минимальный элемент: &quot;);\r\n        Console.WriteLine(minimum);\r\n\r\n        int maximum = numbers.Max();\r\n        Console.Write(&quot;Максимальный элемент: &quot;);\r\n        Console.WriteLine(maximum);\r\n\r\n        Dictionary&lt;String, String&gt; dictionary = new Dictionary&lt;string, string&gt;();\r\n        dictionary.Add(&quot;яблоко&quot;, &quot;apple&quot;);\r\n        dictionary.Add(&quot;мороженое&quot;, &quot;icecream&quot;);\r\n        dictionary.Add(&quot;чай&quot;, &quot;tea&quot;);\r\n\r\n        dictionary = dictionary.OrderBy(pair =&gt; pair.Key).ToDictionary(pair =&gt; pair.Key, pair =&gt; pair.Value);\r\n\r\n        foreach (var pair in dictionary)\r\n        {\r\n            Console.WriteLine(&quot;{0} по-английски {1}&quot;, pair.Key, pair.Value);\r\n        }\r\n\r\n\r\n        String sentence = &quot;Я пожалуй возьму яблоко, мороженое и чай&quot;;\r\n\r\n        Console.WriteLine(sentence);\r\n        foreach (var wordPair in dictionary)\r\n        {\r\n            sentence = sentence.Replace(wordPair.Key, wordPair.Value);\r\n        }\r\n        Console.WriteLine(sentence);\r\n		\r\n\r\n        Console.ReadKey();\r\n    }\r\n}\r\n</pre>', 1, 2);
INSERT INTO `articles` (`id_`, `title`, `title_menu`, `title_page`, `description`, `category_id`, `text`, `enabled`, `ord`) VALUES
(4, 'Работа с файлами', 'Работа с файлами', 'Работа с файлами', '', 2, 'В качестве файла для экспериментов я возьму текст книги <a href="files/%D0%90%D0%BB%D0%B8%D1%81%D0%B0%20%D0%B2%20%D0%97%D0%B0%D0%B7%D0%B5%D1%80%D0%BA%D0%B0%D0%BB%D1%8C%D0%B5.txt">"Алиса в Зазеркалье"</a>, вы можете\nиспользовать этот файл либо какой-нибудь свой, главное чтобы это был простой текст (<b>*.txt</b>).\n<p>\nСоздадим простое консольное приложение:\n<pre class="brush: csharp">\nusing System; 		 // базовые типы\nusing System.Text; // для работы с кодировками\nusing System.IO;	 // для работы с фалами\nusing System.Collections.Generic; // для работы с коллекциями\nusing System.Linq; // \nдля использования конструкций языка Linq\n\nnamespace ConsoleApplication1\n{\n	class MainClass\n	{\n		public static void Main (string[] args)\n		{\n		}\n	}\n}\n</pre>\nВозможны вы уже обратили внимание что у функции <b>public static void Main (string[] args)</b>. \nПрисутствует параметр <b>string[] args</b>. Это так называемые аргументы командной строки, их используют\nдля того чтобы контролировать поведение консольных приложений. Их количество и вид определяет разработчик программы.\nНапример команду <b>copy</b> консольной оболочки Windows (чтобы запустить консоль нажмите <b>Win+R</b>, введите <b>cmd</b> и нажмите <b>ENTER</b>) , можно вызвать следующим образом:\n<div class="console">\ncopy somefile.txt d:\\Texts\n</div>\nПрограмме <b>copy</b> передается два аргумента (аргументы отделяются друг от друга пробелами, если параметр может содержать пробелы его надо заключить в кавычки, например: <b>copy "Some file with spaces in name.txt" d:\\Texts</b> ):<br>\n<b>somefile.txt</b> &mdash; файл для копирования <br>\n<b>d:\\Texts</b> &mdash; папка назначения, туда куда скопируется файл <br>\nЕсли бы мы были разработчиками программы <b>copy</b>, то мы могли бы обратиться к этим аргументам через параметр <b>string[] args</b>.<br>\n<ul>\n<li><b>args</b> &mdash; это массив строк</li>\n<li><b>args[0]</b> &mdash; хранит первый аргумент переданный в командную строку \n(т.е. для данного примера он содержал <b>"somefile.txt"</b>)</li>\n<li><b>args[1]</b> &mdash; хранит второй аргумент переданный в командную строку \n(т.е. для данного примера он содержал <b>"d:\\Texts"</b>)</li>\n<li>и т.д.</li>\n</ul>\n<p>\nВ нашем приложении мы тоже будем использовать два параметра: для указания файла с текстом \nи для папки куда мы будем сохранять результаты обработки текста. Но мы же не собираемся запускать \nпрограмму из консоли, мы просто тыкаем <b>F5</b> и все делается на автомате. Чтобы передать параметры\nприложению необходимо сделать небольшие манипуляции.\n<br>Открыть свойства проекта:\n<img src="images/project_properties.png" />\nВыбрать вкладку Debug (отладка):\n<img src="images/project_properties_debug.png" />\nИ прописать туда параметры через пробел, как видите так как путь к книге "Алиса в Зазеркалье" содержит\nпробелы я заключаю его в двойные кавычки.\n<p>\nМожно закрыть вкладку свойств и перейти к написанию кода, как обычно весь код помещаем \nв тело функции <b>public static void Main (string[] args)</b>\n<p>\nСоздадим две переменные для хранения первого и второго аргумента (вообще говоря это необязательно,\nмы могли бы просто использовать <b>args[0]</b> и <b>args[1]</b>, но они имена не несут никакой смысловой\nнагрузке, и через неделю другую вам будет достаточно тяжело вспомнить для чего и какой аргумент использовался.\n<pre class="brush: csharp">\nString inputFile = args [0]; // файл с текстом\nString outputDir = args [1]; // папка куда будем сохранять файл\n</pre>\nТеперь сделаем небольшую проверку, вдруг пользователь подсунет нам файл которого\nне существует или и вовсе какую ерунду. Для этого воспользуемся методом <b>Exists</b> класса <b>File</b>, \nкоторый возвращает <b>true</b> если файл существует и <b>false</b> в обратном случае. \n<pre class="brush: csharp">\n// если файл не существует\nif ( !File.Exists (inputFile) ) {\n\n	// сообщить об этом пользователю\n	Console.WriteLine("файла \\"" + inputFile + "\\" не существует!");\n	\n	// дать возможность прочитать сообщение	\n	Console.ReadKey();\n	\n	// завершить программу\n	return;\n}\n</pre>\n<div class="note">\nВозможно вы обратили внимание что мы используем <b>\\</b> для того что выводить кавычки. \n<pre class="brush: csharp">\n... \nConsole.WriteLine("файла \\"" + inputFile + "\\" не существует!");\n...\n</pre>\nСвязанно это с тем, что кавычки являются зарезервированным символом поэтому чтобы вывести сроку содержащую\nкавычки необходимо кавычки в ней "экранировать" с помощью обратного слеша. Таким образом, чтобы создать строку содержащую\nнеобходимо \nделать так:\n<pre class="brush: csharp">\nString some_string = "\\""; // с одним символом двойных кавычек\n...\nString another_string = "\\"\\"";// с двумя символами двойных кавычек\n...\nString other_string = "\\\\"; // с обратным слешом\n...\nString freak_string = "\\\\\\"\\\\"; // с символом двойных кавычек, между двумя обратными слэшами \n</pre>\nПоследняя строка уж совсем страшная.<br>\n<b>C#</b> предлагает нам альтернативный способ задания строк\nсодержащих много экранированных символов. С использованием символа <b>@</b> (at - по-английски). \nС помощью <b>@</b> последняя строка может быть записана как\n<pre class="brush: csharp">\nString freak_string = @"\\""\\"; \n/*\n  кавычки все равно приходится экранировать, повторяя их два раза\n    \n  два раза повторенная двойная кавычка \n  будет выведена как один символ двойной кавычки\n*/\n</pre>\nВ основном символ используют для задания путей в <b>Windows</b> (в <b>UNIX</b> подобных системах, в путях используется прямой слэш\nи таких проблем там не возникает):\n<pre class="brush: csharp">\n// без @:\nString path1 = "C:\\\\somedir\\\\anotherdir\\\\somefile.jpeg";\n\n// с использованием @:\nString path2 = @"C:\\somedir\\anotherdir\\somefile.jpeg";\n\n// вывести строки на экран\nConsole.WriteLine(path1);\nConsole.WriteLine(path2);\n</pre>\nВыведутся на консоль обе строки абсолютно одинаково.\n<div class="console">\nC:\\somedir\\anotherdir\\somefile.jpeg<br>\nC:\\somedir\\anotherdir\\somefile.jpeg\n</div>\n</div>\n<p>\nТеперь считаем содержимое файла в и сохраним в строку\n<pre class="brush: csharp">\n/*\n	Кодировки это большая головная боль\n	если у вас вместо букв вылезут вопросики\n	попробуйте в качестве второго параметра \n	один из следующих вариантов:\n	\n	Encoding.GetEncoding (1251)\n	Encoding.Default;\n	Encoding.UTF8\n*/\nString fullText = File.ReadAllText (inputFile, Encoding.GetEncoding (1251));\n/*\n	выведем текст на экран,\n	кстати если текст достаточно большой\n	то в консоль он весь не влезет (даже с учетом прокрутки)\n*/\nConsole.Write(fullText);\n</pre>\nЯ хочу провести частотный анализ появления слов в тексте, для этого мне надо\nпрежде всего текст разбить на слова. Я воспользуюсь уже знакомой с прошлых уроков функцией\n<b>Split</b>, а в качестве разделителей выберу следующие символы:\n<pre class="brush: csharp">\n/*\n	этот далеко не полный список разделителей, но и такой пойдет\n	обратите внимание на два последних символа,\n	''\\n'' - символ перехода на новую строку\n	''\\r'' - символ возврата каретки\n	эти символы не являются печатными, \n	но тем не менее в тексте присутствуют.\n*/\nChar[] separators = {'' '', '','', ''.'', ''-'', ''!'', ''?'', ''\\"'', ''\\n'', ''\\r'' };\n</pre>\nСформируем список слов:\n<pre class="brush: csharp">\nString[] wordsArray = fullText.Split (separators, StringSplitOptions.RemoveEmptyEntries);\n</pre>\nТеперь я хочу создать новый список состоящий из пар: слово + кол-во появлений слова в тексте.\nДля этого как нельзя лучше подходят класс <b>Dictionary</b>. \nВ прошлом уроке я использовал словарь типа <b>Dictionary&lt;String, String&gt;</b>. \n<p>Сегодня я буду использовать словарь вида <b>Dictionary&lt;String, int&gt;</b>. Создам его:\n<pre class="brush: csharp">\n/*\n	мне лень явно указывать тип переменной\n	к тому же он вполне очевиден из правой части \n*/\nvar dictWords = new Dictionary&lt;String, int&gt; ();\n</pre> \nА теперь мне надо заполнить этот словарь элементами. Для этого я организую цикл по всем словам из списка слов текста:\n<pre class="brush: csharp">\n// для каждого слова из списка слов\nforeach (var word in wordsArray) \n{\n	// если словарь не содержит слово	\n	if (!dictWords.ContainsKey (word)) \n	{\n		/*\n			добавляем слово в качестве ключа в словарь,\n			его значение устанавливаем единичкой,\n			что означает &mdash; слово один раз в тексте встречалось,\n			таки так оно \nи есть\n		*/		\n		dictWords.Add (word, 1);\n	} \n	else  // а если встречалось\n	{\n		/*\n			в таком случае добавлять слово с словарь не надо\n			но надо увеличить значение для слова на 1 \n		*/\n		dictWords [word] += 1;\n	}\n}\n</pre>\n<div class="note">\nВ таком виде программа различает слова начинающиеся с большой и маленькой буквы, т.е. <b>алиса</b> и <b>Алиса</b> будут восприняты как два разных слова, вообще говоря такое поведение не логично, чтобы поправить ситуацию можно например переписать так:\n<pre class="brush: csharp">\nforeach (var word in wordsArray) \n{\n	/*\n		введем дополнительную переменную, которая все слова будет переводить\n		в нижний регистр и уже для этого слова мы будем решать\n		добавлять его в словарь или изменять его значение\n	*/  	\n	String lowerWord = word.ToLower(); 	\n	\n	// если словарь не содержит слово	\n	if (!dictWords.ContainsKey (lowerWord)) \n	{\n		/*\n			добавляем слово в качестве ключа в словарь,\n			его значение устанавливаем единичкой,\n			что означает &mdash; слово один раз в тексте встречалось,\n			таки так оно и есть\n		*/		\n		dictWords.Add (lowerWord, 1);\n	} \n	else  // а если встречалось\n	{\n		/*\n			в таком случае добавлять слово с словарь не надо\n			но надо увеличить значение для слова на 1 \n		*/\n		dictWords [lowerWord] += 1;\n	}\n}\n</pre>\n</div>\nНу а теперь самое интересное, мы могли бы вывести на экран какое слово сколько раз\nвстречалось, но вместо этого, мы будем производить вывод в файл. Для этого создадим объект\n<b>StreamWriter</b> который позволяет производить операции записи над файлом указанном\nв качестве параметра при его инициализации. \n<pre class="brush: csharp">\nStreamWriter writer = new  StreamWriter(outputDir + @"\\words.txt");\n</pre>\nА теперь запишем информацию о нашем анализе в текстовый файл:\n<pre class="brush: csharp">\n/*\n	Я воспользуюсь возможностью упорядочения на лету\n	с помощью функции OrderBy, \n	и укажу что хочу упорядочить по значению\n*/\nforeach (var pair in dictWords.OrderBy( x => x.Value ) ) \n{\n	/*\n		Напоминаю что "{0,-14}: {1}" &mdash; это шаблон форматирования строки\n		сам шаблон означает вывести первый аргумент, если строковое значение\n		первого аргумента длиной меньше 14 символов добавить к нему справа пробелов \n		чтобы она равнялась 14 (если б стояло просто 14, то обозначало бы добавить слева), \n		\n		нарисовать двоеточие, \n		вывести второй аргумент\n		\n		все данные записываются в файл\n	*/	\n	writer.WriteLine("{0,-14}: {1}", pair.Key, pair.Value);\n}\n\n// так как мы больше ничего не собираемся делать с этим файлом, его необходимо закрыть\nwriter.Close();\n</pre>\nМожно открыть файл и полюбоваться результатом. Вот несколько строчек из моего файла:\n<div class="console">\nКоролева&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;168<br>\nа&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;170<br>\nто&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;170<br>\nтак&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;178<br>\nИ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;185<br>\nА&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;189<br>\nон&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;219<br>\nэто&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;219<br>\nя&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;243<br>\nкак&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;291<br>\nс&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;304<br>\nона&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;327<br>\nАлиса&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;488<br>\nчто&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;492<br>\nна&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;516<br>\nне&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;654<br>\nв&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;692<br>\nи&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;936\n</div>\nЕсли уже забыли, то в первой колонке у нас слова, а в правой то сколько раз они встретились в тексте. \n<p>Теперь попробуем сделать частотный анализ букв, в отличие от слов, для этого разбивать текст не надо, достаточно использовать исходный текст, мы можем обращаться к символом текста через операцию индексации. Но сначала создадим новый словарь. В качестве ключа будем использовать букву, а в качестве значения, то сколько раз она встречалась в тексте.\n<pre class="brush: csharp">\nvar dictChars = new Dictionary&lt;Char, int&gt;();\n</pre>\nТеперь организуем цикл по всем символам текста:\n<pre class="brush: csharp">\n// проходим по всем символам в тексте \nforeach (Char ch in fullText) {\n	/*\n		нас интересует лишь частотный анализ букв\n		поэтому мы использую статический метод IsLetter\n		класса Char, проверяем является ли символ буквой\n	*/ \n	if ( Char.IsLetter(ch) ) \n	{\n		// если такой буквы нет в словаре		\n		if ( !dictChars.ContainsKey (ch) ) \n		{\n			// добавляем ее в словарь, устанавливаем ее значение на 1\n			dictChars.Add (ch, 1);			\n		} \n		else  // а если есть\n		{\n			// увеличиваем значение буквы на один			\n			dictChars [ch] += 1;\n		}\n	}\n}\n</pre>\nПосле выполнения этого цикла наш словарь будет содержать информацию о том сколько раз\nкаждая буква встречалась в тексте.\n<p>Теперь рассмотрим альтернативный способ записи текста в файл.\nФункция <b>WriteAllText</b> класса <b>File</b>, позволяет записать строку в файл, за\nодин шаг, главное чтобы строка к этому моменту была сформирована. Формировать строку очень \nудобно с помощью объекта <b>StringBuilder</b>.\n<pre class="brush: csharp">\n// создадим объект для формирования строк\nStringBuilder outString = new StringBuilder ();\n/*\n  для каждой пары: буква - кол-во появлений в тексте\n  как и в предыдущем примере я упорядочиваю на лету по значению\n*/\nforeach (var pair in dictChars.OrderBy( x => x.Value ) ) \n{\n	// рассчитываем долю появления буквы к количеству символов в тексте \n	// это число очевидно меньше единицы 	\n	double freq = (double) pair.Value / fullText.Length;\n\n	/* \n		добавляю строку\n		{0,-3} - выделить три символа с выравниванием влево под символ буквы \n		{1:0.000%} - вывести долю в процентах, с точностью до третьего знака после запятой\n	*/ \n	outString.AppendFormat("{0,-3}: {1:0.000%}", pair.Key, freq);\n	\n	// добавить символ перехода на новую строку\n	outString.AppendLine();\n}\n</pre>\n<div class="note">\nСтоит отметить что тут (<b>double freq = (double) pair.Value / fullText.Length</b>) \nмы сравниваем частоту появления буквы относительно количества символов в тексте\n(не только букв, но и знаков препинания, пробелов, цифр и т.д.), более правильно было бы\nвместо <b>fullText.Length</b>, ввести дополнительную переменную хранящую кол-во букв в тексте\n<pre class="brush: csharp">\n/*\n	Тут мы используем Linq-функцию Count которая возвращает кол-во элементов в массиве,\n	для которых функция, указанная в качестве параметра, возвращает true\n*/\nint lettersCount = fullText.Count(Char.IsLetter);\n/*\n	равносильная запись \n	int lettersCount = fullText.Count( ch => Char.IsLetter(ch));\n*/\n</pre>\nНу и заменить пересчет доли\n<pre class="brush: csharp">\n...\ndouble freq = (double) pair.Value / lettersCount;\n...\n</pre>\n</div>\n<p>\nНу а теперь мы эту строку сформированную объектом <b>outString</b> типа <b>StringBuilder</b> сохраним в файл:\n<pre class="brush: csharp">\n/*\n	Так как StringBuilder не является строкой,\n \n	а является чем то вроде контейнера для хранения строки\n	строку надо извлечь с помощью метода ToString(), \n	\n	кстати методом ToString() обладают абсолютно все объекты в C#	\n*/\nFile.WriteAllText(outputDir + @"\\chars.txt" ,outString.ToString());\n</pre>\nВот несколько строк из моего файла:\n<div class="console">\nь&nbsp;&nbsp;:&nbsp;1.503%<br>\nп&nbsp;&nbsp;:&nbsp;1.814%<br>\nу&nbsp;&nbsp;:&nbsp;1.967%<br>\nд&nbsp;&nbsp;:&nbsp;1.982%<br>\nм&nbsp;&nbsp;:&nbsp;2.101%<br>\nк&nbsp;&nbsp;:&nbsp;2.497%<br>\nв&nbsp;&nbsp;:&nbsp;2.823%<br>\nр&nbsp;&nbsp;:&nbsp;3.268%<br>\nс&nbsp;&nbsp;:&nbsp;3.901%<br>\nл&nbsp;&nbsp;:&nbsp;4.145%<br>\nн&nbsp;&nbsp;:&nbsp;4.286%<br>\nт&nbsp;&nbsp;:&nbsp;4.379%<br>\nи&nbsp;&nbsp;:&nbsp;4.496%<br>\nе&nbsp;&nbsp;:&nbsp;5.931%<br>\nа&nbsp;&nbsp;:&nbsp;6.579%<br>\nо&nbsp;&nbsp;:&nbsp;8.126%<br>\n</div>\n для интереса слазайте <a href="http://ru.wikipedia.org/wiki/%D0%A7%D0%B0%D1%81%D1%82%D0%BE%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C" target="_blank">сюда</a> и сравните порядок букв с тем что в вашем файле\n(напомню что буквы я упорядочил по частоте появления в тексте)\nНу напоследок откроем созданные файлы программно, мы конечно могли бы\nдойти до папки и в ручную открыть их, но ведь нам лень .__.\n<pre class="brush: csharp">\n// открываем первый файл\nSystem.Diagnostics.Process.Start(outputDir + @"/chars.txt");\n// открываем второй файл\nSystem.Diagnostics.Process.Start(outputDir + @"/words.txt");\n</pre>\nЕсли в качестве стандартного приложения для работы с *.txt файлами у вас стоит блокнот,\nто у вас должно открыться два блокнота.\n<div class="note">\nкстати <b>System.Diagnostics.Process</b> на самом деле просто класс <b>Process</b> для управления процессами операционной системы, если б мы подключили вверху программы пространство имен <b>System.Diagnostics</b>, можно было написать и так:\n<pre class="brush: csharp">\n...\nusing System.Diagnostics;\n...\n\n// открываем первый файл\nProcess.Start(outputDir + @"/chars.txt");\n// открываем второй файл\nProcess.Start(outputDir + @"/words.txt");\n</pre>\n</div>\n<p>\nНу и напоследок дадим рассмотреть пользователю чего у нас на консоль выведено:\n<pre class="brush: csharp">\n// приостановка, в ожидании нажатия пользователем любой клавиши\nConsole.ReadKey();\n</pre>\n<hr>\n<h2>Полный листинг:</h2>\n<pre class="brush: csharp">\nusing System;\nusing System.Text;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ConsoleApplication1\n{\n	class MainClass\n	{\n		public static void Main (string[] args)\n		{\n			String inputFile = args [0];\n			String outputDir = args [1];\n\n			if (!File.Exists (inputFile)) \n			{\n				Console.WriteLine (&quot;файла \\&quot;&quot; + inputFile + &quot;\\&quot; не существует!&quot;);\n				Console.ReadKey ();\n				return;\n			}\n\n			String fullText = File.ReadAllText (inputFile, Encoding.GetEncoding (1251));\n			Console.WriteLine (fullText);\n\n			Char[] separators = {&apos; &apos;, &apos;,&apos;, &apos;.&apos;, &apos;-&apos;, &apos;\\n&apos;, &apos;!&apos;, &apos;?&apos;, &apos;\\&quot;&apos;, &apos;\\r&apos; };\n			String[] wordsArray = fullText.Split (separators, StringSplitOptions.RemoveEmptyEntries);\n\n			var dictWords = new Dictionary&lt;string, int&gt; ();\n			foreach (var word in wordsArray) \n			{\n				if (!dictWords.ContainsKey (word)) \n				{\n					dictWords.Add (word, 1);\n				} \n				else \n				{\n					dictWords [word] += 1;\n				}\n			}\n\n			StreamWriter writer = new  StreamWriter (outputDir + @&quot;\\words.txt&quot;);\n\n			foreach (var pair in dictWords.OrderBy( x =&gt; x.Value )) \n			{\n				writer.WriteLine (&quot;{0,-14}: {1}&quot;, pair.Key, pair.Value);\n			}\n			writer.Close ();\n\n			var dictChars = new Dictionary&lt;Char, int&gt; ();\n			foreach (Char ch in fullText) \n			{\n				if (Char.IsLetter (ch)) \n				{\n				\n	if (dictChars.ContainsKey (ch)) \n					{\n						dictChars [ch] += 1;\n					} \n					else \n					{\n						dictChars.Add (ch, 1);\n					}\n				}\n			}\n\n			StringBuilder outString = new StringBuilder ();\n			foreach (var pair in dictChars.OrderBy( x =&gt; x.Value ) ) \n			{\n				double freq = (double) pair.Value / fullText.Length;\n				outString.AppendFormat(&quot;{0,-3}: {1:0.000%}&quot;, pair.Key, freq);\n				outString.AppendLine();\n			}\n			File.WriteAllText(outputDir + @&quot;\\chars.txt&quot; ,outString.ToString());\n\n			System.Diagnostics.Process.Start(outputDir + @&quot;\\chars.txt&quot;);\n			System.Diagnostics.Process.Start(outputDir + @&quot;\\words.txt&quot;);\n\n			Console.ReadKey();\n		}\n	}\n}\n</pre>', 1, 3);
INSERT INTO `articles` (`id_`, `title`, `title_menu`, `title_page`, `description`, `category_id`, `text`, `enabled`, `ord`) VALUES
(5, 'Формы', 'Формы', 'Формы', '', 2, 'Создадим <b>Windows Form Application</b>. Для этого выбираем <b>Файл / Создать / Проект</b>,\nи в качестве шаблона указываем <b>Приложение Windows Forms</b>.\nВ реультате увидим примерно следующую картинку:\n<img src="images/csharp-04-01.png" />\nЕсли у вас вдруг отсутствует левая (<b>панель элементов (toolbox)</b>) или правая панелька (<b>свойства (properties)</b>),\nих можно включить через меню <b>Вид (view)</b>\n<p>\nДобавим на форму пару элементов, пока нам хватит <b>Button</b> и <b>RichTextBox</b>. Чтобы добавить компонент его надо\nперетянуть с панели инструментов на форму. Должно получиться что-то в этом роде:\n<img src="images/csharp-04-02.png">\nВыделим кнопку (кликнув на нее один раз), и поменяем ее имя (свойство <b>Name</b>) на <b>btnShowText</b>, \nи надпись на кнопке (свойство <b>Text</b>) на <b>Показать текст</b> \n<img src="images/csharp-04-03.png">\n<div class="note">\nКаждый объект на форме, включаю саму форму, обладает набором свойств, изменяя которые можно изменять\nповедение и вид объекта. Самое простое, но в тоже время самое важное свойства - это свойство <b>Name</b>. \nС помощью него мы обращаемся к объекту. То есть если кнопка имеет имя <b>RedButton</b>, то для\nтого чтобы программно нажать на эту кнопку надо будет написать\n<pre class="brush: csharp">\nRedButton.Click();\n</pre>\nА если нам вдруг захочется узнать какая надпись на кнопке, и присвоить это значение какой-нибудь переменной мы напишем\n<pre class="brush: csharp">\nstring labeltext = RedButton.Text;\n</pre>\n</div>\n<p>\nВыделим объект типа <b>RichTextBox</b> и поменяем его имя на <b>txtMain</b>.<br>\n<b>RichTextBox</b> позволяет отображать форматированный текст и редактировать его. \nЕсли сейчас запустить приложение (<b>F5</b>), то можно написать чего нибудь в текстовом поле,\nможно понажимать на кнопку, правда все это пока не принесет ни какой пользы. \n<p>\nЕсли приложение запущенно, то закроем его и вернемся к редактированию формы. Щелкнем два раза на\nнашу кнопку <b>btnShowText</b>. По идее мы должны оказаться в режиме редактирования кода. Увидим мы примерно следующее:\n\n<pre class="brush: csharp">\n/*\n	В отличие от консольных приложений здесь уже намного \n	больше компонентов подключено по умолчанию.\n	Часть из них предназначена для работы с объектами на форме\n*/\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Data;\nusing System.Drawing;\nusing System.Linq;\nusing System.Text;\nusing System.Windows.Forms;\n\nnamespace WindowsFormsApplication1\n{ \n    /*\n    	Создавая форму, мы формируем новый объект формы на\n    	базе самой простой, на что и указывает \n    	...  class Form1 : Form ...\n    	\n    	Часто класс формы содержит очень много функций\n    	слово partial, позволяет разбивать код для класса\n    	на несколько подфайлов \n    */  \n    public partial class Form1 : Form\n    {\n        // это конструктор формы, он вызывается всего один раз\n        // когда форма создается в памяти впервые        \n        public Form1()\n        {\n            /*\n            	на самом деле данный файл содержит не весь код формы\n   \n         	часть кода содержится в файле Form1.Designer.cs\n            	метод InitializeComponent описан в том файле, \n            	и код в нем генерируется автоматически\n            	в соответствии с тем какие объекты вы добавляете на форму,\n            	и как меняете их свойства\n            */\n            InitializeComponent();\n        }\n        \n        \n        /*\n        	эта функция возникла автоматически когда мы два раза щелкнули\n        	на кнопку btnShowText, в нем мы пропишем код \n        	который будет запускаться каждый раз \n        	когда во время исполнения программы \n        	на кнопку будут нажимать\n        */  \n        private void btnShowText_Click(object sender, EventArgs e)\n        {\n\n        }\n    }\n}\n</pre>\nНаша кнопка будет показывать текстовое сообщение, в котором будет содержаться текст\nиз <b>txtMain</b>. Для этого <b>.Net</b> предлагает нам класс <b>MessageBox</b>.\n<pre class="brush: csharp">\n...\nprivate void btnShowText_Click(object sender, EventArgs e)\n{\n	// сохраним содержимое текстового поля\n	// в переменную	\n	String textFromTxtMain = txtMain.Text;\n	\n	// покажем значение переменной в окне MessageBox\n	MessageBox.Show(textFromTxtMain);\n}\n...\n</pre>\nЕстественно, чтобы в окне что-то было, это что-то надо ввести в текстовое поле.\nНо каждый раз вводить лень, так что вернемся в режим редактирования формы, и изменим значение\nсвойства <b>Text</b> объекта <b>txtMain</b> например на следующий текст:\n<div class="text">\n Шалтай-Болтай взял книжку и уставился в нее.<br>\n - Кажется, здесь нет ошиб... - начал он.<br>\n - Вы ее держите вверх ногами, - прервала его Алиса.<br>\n - Ну, конечно, - весело заметил Шалтай-Болтай и взял перевернутую Алисой книжку. - То-то я смотрю, как странно все это выглядит! Поэтому я и сказал: "_Кажется_, здесь нет ошибки!", - хоть я и не успел разобраться как следует... Значит, так: триста шестьдесят четыре дня в году ты можешь получать подарки на день нерожденья.<br>\n - Совершенно верно, - сказала Алиса.<br>\n - И только _один_ раз на день рожденья! Вот тебе и слава!<br>\n - Я не понимаю, при чем здесь "слава"? - спросила Алиса.\n</div>\nЧтобы ввести этот текст, его можно скопировать и нажать на стрелочку справа от имени свойства,\nчто позволит нам работать с многострочным текстом:\n<img src="images/csharp-04-04.png">\nТеперь если запустить приложение, текстовое поле сразу будет содержать текст.\n<p>\nДобавим еще два элемента на форму. \n<ul>\n<li>Добавим кнопку, назовем ее (свойство <b>Name</b>) <b>btnShowLine</b>, и поменяем текст надписи (свойство <b>Text</b>)\nна <b>ПоказатьСтроку</b>.</li>\n<li>Добавим счетчик, назовем его <b>edtLineIndex</b>.\n</ul>\nПолучим что-то в этом роде:\n<img src="images/csharp-04-05.png">\nЩелкнем дважды на кнопку <b>btnShowLine</b> и пропишем обработчик события нажатия на кнопку.\nПо нажатию на эту кнопку должно будет выскакивать <b>MessageBox</b> в котором будет содержаться\nтекст строки из поля <b>txtMain</b> под номером указанным в <b>edtLineIndex</b>.\n<pre class="brush: csharp">\nprivate void btnShowLine_Click(object sender, EventArgs e)\n{\n	// считываем выбранный в edtLineIndex значение	\n	int lineIndex = (int)edtLineIndex.Value;\n	\n	// с помощью свойства Lines объекта txtMain, считываем значение выбранной строки\n	// и сохраняем его в новую переменную\n	string lineText = txtMain.Lines[lineIndex];\n	\n	//выводим значение переменной на экран\n	MessageBox.Show(lineText);\n}\n</pre>\n<div class="note">\nБолее правильно было бы добавить проверку на корректность указанного номера строки,\nвдруг пользователь выберет слишком большое значение. Такая ситуация может привести к\nпадению программы, поэтому правильнее будет написать так:\n<pre class="brush: csharp">\nprivate void btnShowLine_Click(object sender, EventArgs e)\n{\n	// считываем выбранный в edtLineIndex значение	\n	int lineIndex = (int)edtLineIndex.\nValue;\n	\n	// проверяем на допустимость значения индекса строки\n	if ( lineIndex >= 0 && lineIndex < txtMain.Lines.Length)\n	{\n		// с помощью свойства Lines объекта txtMain, считываем значение выбранной строки\n		// и сохраняем его в новую переменную\n		string lineText = txtMain.Lines[lineIndex];\n		\n		//выводим значение переменной на экран\n		MessageBox.Show(lineText);\n	}\n}\n</pre>\n</div>\n<p>\nДобавим еще две кнопки, \n<ul>\n<li>Первую назовем <b>btnHighlightSep</b>, и поменяем ее надпись на <b>знаки</b>. С помощью этой\nкнопки мы сможем подсветить все знаки препинания в поле ввода</li>\n<li>вторую - <b>btnResetColor</b>, и поменяем ее надпись на <b>сбросить</b>.\nС помощью этой кнопки мы сможем снять подсветку текста.</li>\n</ul>\n<img src="images/csharp-04-06.png">\nКак я уже выше упомянул, текстовое поле позволяет форматировать текст, \nт.е. менять цвет, шрифт у подстрок в тексте. Для этого используется функция <b>Select</b>.\nФункция позволяет выделить подстроку в тексте. После того как кусок текста выделен, мы используя свойства вида <b>Selection*</b>\nможем изменять цвета и прочие характеристики выделенного текста.\n<p>\nНапишем обработчик события клика для кнопки <b>btnHighlightSep</b>, для этого как обычно щелкнем на нее дважды.\n<pre class="brush: csharp">\nprivate void btnHighlightSep_Click(object sender, EventArgs e)\n{\n	// прощелкиваем счетчик i от 0 до кол-ва символов в тексте	\n	for (int i=0; i&lt;txtMain.TextLength; ++i)\n	{\n		 // если символ на i-ой позиции, является знаком препинания	    \n	    if (Char.IsPunctuation(txtMain.Text[i]))\n	    {\n		    /* \n		  	  выделяем этот символ, функция \n		  	  Select(начальная_позиция_выделения, количество_символов для выделения)       \n		    */ \n	        txtMain.Select(i, 1);\n	        // устанавливаем цвет фона для выделенного текста на желтый \n	        txtMain.SelectionBackColor = Color.Yellow;\n	        // устанавливаем цвет выделенного текста на красный \n	        txtMain.SelectionColor = Color.Red;\n	    }\n	}\n}\n</pre>\nТеперь можно нажать на кнопку и полюбоваться на результат.\n<br>Правда реакция на нажатие кнопки видна только при первом нажатии. Чтобы исправить \nданную ситуация, пропишем кнопке с надписью <b>сбросить</b> обработчик события клика - кликнем на нее дважды.\n<pre class="brush: csharp">\nprivate void btnResetColor_Click(object sender, EventArgs e)\n{\n	// выделяем весь текст	\n	txtMain.SelectAll();\n	\n	// сбрасываем цвет фона выделенного текста на тот что по умолчанию\n	txtMain.SelectionBackColor = txtMain.BackColor;\n	\n	// сбрасываем цвет выделенного текста на тот что по умолчанию\n	txtMain.SelectionColor = txtMain.ForeColor;\n}\n</pre>\nДобавим еще одну кнопку, которая, ради смеха, позволит нам разукрасить текст в произвольные цвета.\n<ul>\n<li>Назовем ее <b>btnRandomColor</b>, и сменим ее надпись на <b>Разукрасить буквы</b></li>\n</ul>\n<img src="images/csharp-04-07.png">\nНапишем обработчик события клика для новой кнопки\n<pre class="brush: csharp">\nprivate void btnRandomColor_Click(object sender, EventArgs e)\n{\n	/*\n		создадим новый генератор случайных чисел\n		в соответствии с названием \n		он генерирует случайные числа\n		с помощью функции Next\n	*/	\n	Random rndGen = new Random();\n	\n	// снова пройдем счетчиком i от 0 до кол-ва символов в тексте\n	for (int i = 0; i < txtMain.TextLength; ++i)\n	{\n	    // выделяем i-ый символ	    \n	    txtMain.Select(i, 1);\n	    \n	    /*\n	    	сгенерируем новый цвет,\n	    	цвет состоит из 3-х компонент, \n	    	красной (1-ый параметр), принимаемое значение от 0 до 255\n			зеленый (2-ый параметр), принимаемое значение от 0 до 255\n			синий (3-ый параметр), принимаемое значение от 0 до 255\n			\n			rndGen.Next(256) - сгенерирует случайное число от 0 до 255\n			установив 0 для синей компоненты цвета, мы получим красно-зеленую\n			осеннюю раскраску\n		 */\n	    Color newRandomColor = \nColor.FromArgb(rndGen.Next(256), rndGen.Next(256), 0);\n\n	    // установим цвет выделенного символа на значене ново-сгенерируемого цвета\n	    txtMain.SelectionColor = newRandomColor;\n	}\n}\n</pre>\nНи и напоследок. Тут у меня фрагмент текста из книги Алиса в Зазеркалье, я просто\nчувствую себя обязанным чего-нибудь отзеркалить. Я буквы конечно вверх ногами не переверну, но продемонстрирую\nвозможность переноса текста из элемента в другой. Итак, добавим два новых элемента \n<ul>\n<li>Кнопку, назовем ее <b>btnMirror</b>, и подпишем <b>отзеркалить текст</b></li>\n<li>Поле для ввода текста (<b>RichTextBox</b>), и назовем его <b>txtMirrored</b></li>\n</ul>\n<img src="images/csharp-04-08.png">\nПытаясь имитировать зеркало, мы развернем порядок букв в тексте. \nВообще говоря развернуть текст можно следующим трюком:\n<pre class="brush: csharp">\n// формируем массив символов из строки\nchar[] charsArray = txtMain.Text.ToCharArray();\n// инвертируем массив символов\nArray.Reverse(charsArray);\n// формируем новую строку на основе инвертированного массива символов\ntxtMirrored.Text = new String(charsArray);\n</pre>\nНо нам кроме инвертирования самого текста хотелось бы еще сохранить и цвет, соответствующих символов, \nдля этого реализуем посимвольную раскраску текста. Пропишем обработчик события клика для кнопки <b>btnMirror</b>\n<pre class="brush: csharp">\nprivate void btnMirror_Click(object sender, EventArgs e)\n{\n	// скопируем инвертированный текст из 	txtMain в txtMirrored\n	char[] charsArray = txtMain.Text.ToCharArray();\n	Array.Reverse(charsArray);\n	txtMirrored.Text = new String(charsArray);\n	\n	// пройдем счетчиком i от 0 до кол-ва символов в тексте txtMain\n	for (int i = 0; i < txtMain.TextLength; ++i)\n	{\n		 // выделяем текст в txtMirrored    \n	    txtMirrored.Select(i, 1);\n	    /*\n	    	выделяем соответствующий символ в txtMain;\n	    	напоминаю, что текст у нас развернут\n	    	и первый символ txtMirrored соответствует \n	    	последнему символу txtMain\n	    */\n	    txtMain.Select(txtMain.TextLength - i -1, 1);\n	    \n	    // копируем значения соответствующих цветов\n	    txtMirrored.SelectionColor = txtMain.SelectionColor;\n	    txtMirrored.SelectionBackColor = txtMain.SelectionBackColor;\n	}\n}\n</pre>\nСтоит отметить что посимвольное копирование цвета ОООООЧЕНЬ медленное, и если \nвы вдруг закинули в поле для текста какой-нибудь (пусть даже небольшой рассказик),\nто самым разумным будет нажать <b>Shift+F5</b>\n<div class="note">\nКстати, если вы хотите наглядно видеть как происходит процесс перекраски текста, добавьте следующую\nстрочку в тело цикла:\n<pre class="brush: csharp">\n	 ...\n    txtMirrored.SelectionColor = txtMain.SelectionColor;\n    txtMirrored.SelectionBackColor = txtMain.SelectionBackColor;\n	  \n	 /*\n	 	с помощью этой строчки на каждой итерации цикла,\n	 	txtMirrored будет перерисовывать себя,\n	 	(в общем случае обрабатывать сообщения от операционной системы)\n	 	это сильно замедлит программу \n	 	но зато добавит в нее вау-эффект\n	 */\n    Application.DoEvents();\n}\n</pre>\n</div>\n<hr>\n<h2>Полный листинг:</h2>\nВ отличие от консольных приложений здесь недостаточно будет\nпросто скопировать текст в редактор текста <b>Visual Studio</b>,\nтут таки придется еще и нарисовать форму, и правильно назвать все компоненты.\n<pre class="brush: csharp">\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Data;\nusing System.Drawing;\nusing System.Linq;\nusing System.Text;\nusing System.Windows.Forms;\n\nnamespace WindowsFormsApplication1\n{\n    public partial class Form1 : Form\n    {\n        public Form1()\n        {\n            InitializeComponent();\n        }\n\n        private void btnShowText_Click(object sender, EventArgs e)\n        {\n            String textFromTxtMain = txtMain.Text;\n            MessageBox.Show(\ntextFromTxtMain);\n        }\n\n        private void btnShowLine_Click(object sender, EventArgs e)\n        {\n            int lineIndex = (int)edtLineIndex.Value;\n            String lineText = txtMain.Lines[lineIndex];\n            MessageBox.Show(lineText);\n        }\n\n        private void btnHighlightSep_Click(object sender, EventArgs e)\n        {\n            for (int i=0; i&lt;txtMain.TextLength; ++i)\n            {\n                if (Char.IsPunctuation(txtMain.Text[i]))\n                {\n                    txtMain.Select(i, 1);\n                    txtMain.SelectionBackColor = Color.Yellow;\n                    txtMain.SelectionColor = Color.Red;\n                }\n            }\n        }\n\n        private void btnResetColor_Click(object sender, EventArgs e)\n        {\n            txtMain.SelectAll();\n            txtMain.SelectionBackColor = txtMain.BackColor;\n            txtMain.SelectionColor = txtMain.ForeColor;\n        }\n\n        private void btnRandomColor_Click(object sender, EventArgs e)\n        {\n            Random rndGen = new Random();\n            for (int i = 0; i &lt; txtMain.TextLength; ++i)\n            {\n                txtMain.Select(i, 1);\n                Color newRandomColor\n                    = Color.FromArgb(rndGen.Next(256), rndGen.Next(256), 0);\n                txtMain.SelectionColor = newRandomColor;\n            }\n        }\n\n        private void btnMirror_Click(object sender, EventArgs e)\n        {\n            char[] charsArray = txtMain.Text.ToCharArray();\n            Array.Reverse(charsArray);\n            txtMirrored.Text = new String(charsArray);\n            for (int i = 0; i &lt; txtMain.TextLength; ++i)\n            {\n                txtMirrored.Select(i, 1);\n                txtMain.Select(txtMain.TextLength - i -1, 1);\n                txtMirrored.SelectionColor = txtMain.SelectionColor;\n                txtMirrored.SelectionBackColor = txtMain.SelectionBackColor;\n\n                Application.DoEvents();\n            }\n            \n        }\n    }\n}\n</pre>', 1, 4),
(6, 'Вопросы к колоквиуму', 'Вопросы к колоквиуму', 'Вопросы к колоквиуму', '', 4, '<ol>\n<li>Отличный вопрос</li>\n<li>Приличный вопрос</li>\n<li>Неприличный вопрос</li>\n<li>Сложный</li>\n<li>Так себе</li>\n</ol>', 0, 1),
(7, '', 'Tealeaf', 'Tealeaf', '', NULL, '<p align=center>\n<a href="http://tealeaf.su/index.php/lessons/inside" style="cursor:default;"><img alt="watch you" src="images/main_1.gif"/></a>', 1, 0),
(9, 'Вопросы к первому коллоквиуму', 'Вопросы к первому коллоквиуму', 'Вопросы к первому коллоквиуму', '', 4, '<ol class="tasks">\r\n<li>Множества (пустое множество,  подмножество, операции над множествами, парадокс Рассела, теорема о мощности булеана множества).</li>\r\n<li>Отношения (свойства бинарных, эквивалентность отношений и функций).</li>\r\n<li>Отношение эквивалентности (свойства, разбиение на классы эквивалентности).</li>\r\n<li>Пропозициональные связки. Таблицы истинности. Формулы.</li>\r\n<li>Тавтологии. Противоречия.</li>\r\n<li>Полные системы связок (примеры полных систем состоящих из 2-х связок, из 1-ой связки).</li>\r\n<li>Аксиоматическая теория L (определение, аксиомы).</li>\r\n<li>Вывод в формулах исчисления высказываний (ФИВ).</li>\r\n<li>Теорема дедукции в ФИВ.</li>\r\n</ol>', 1, 1),
(10, 'Список лабораторных заданий', ' &nbsp;&#9679; Лабораторные', 'Список лабораторных заданий', '', 2, '<div class="lab">\r\n<h2 class="title"><a>#1. Анализ текста</a></h2>\r\n<div class="info">\r\nТекст для каждой задачи необходим прочитать из файла. Файл с текстом вы вольны выбрать сами.\r\nТекст должен быть на русском языке и содержать не менее 1000 символов и исключать возможность пустых ответов. \r\nПод результат необходимо создать новый файл, и записать в него ответ.\r\n  \r\n<ol class="tasks">\r\n\r\n<li class="easy">Найти слова в которых четное кол-во букв. \r\n	В качества ответа предоставить список слов. \r\n	Рассчитать долю таких слов относительно всех слов</li>\r\n<li class="easy">Найти слова которые не содержат букву введенную с клавиатуры. \r\n	Рассчитать долю таких слов относительно всех слов.</li>\r\n<li class="easy">Найти слова в которых первая буква совпадает с последней.\r\n	Рассчитать долю таких слов относительно всех слов.</li>\r\n<li class="easy">Найти слова длина которых меньше числа введенного с клавиатуры. \r\n	Рассчитать долю таких слов относительно всех слов. </li>\r\n<li class="easy">Найти предложения содержащие четное кол-во слов.\r\n	Рассчитать долю таких предложений относительно всех предложений.</li>\r\n<li class="easy">Найти в тексте слова перевертыши.\r\n	Рассчитать их долю относительно всех слов. </li>\r\n<li class="easy">Найти предложение содержащее наибольшее кол-во слов.</li>\r\n<li class="easy">Найти строку содержащую наибольшее кол-во предложений.</li>\r\n<li class="easy">Найти слова около которых встречаются знаки препинания.\r\n	Рассчитать долю таких слов относительно всех слов.</li>\r\n\r\n<li class="medium">Выяснить слова какой длины встречаются нибольшее кол-во раз в тексте.\r\n	Рассчитать долю таких слов относительно всех слов.</li>	\r\n<li class="medium">Удалить из текста все гласные.</li>\r\n<li class="medium">Удалить из текста все согласные.</li>\r\n<li class="medium">Найти слова которые не содержат одинаковых букв.\r\n	Рассчитать долю таких слов относительно всех слов.</li>\r\n<li class="medium">Найти слова в которых встречаются сдвоенные согласные.\r\n	Рассчитать долю таких слов относительно всех слов.</li>	\r\n<li class="medium">Найти слова в которых одна и та же буква встречается более чем два раза.\r\n	Рассчитать долю таких слов относительно всех слов.</li>\r\n<li class="medium">Найти слова которые содержат нечетное кол-во гласных.\r\n	Рассчитать долю таких слов относительно всех слов.</li>\r\n<li class="medium">Найти слова в которых гласных букв неменьше согласных.\r\n	Рассчитать долю таких слов относительно всех слов.</li>\r\n<li class="medium">Найти предложения, в которых согласных не менее чем в два раза больше\r\n	чем гласных.\r\n	Рассчитать их долю относительно всех слов.</li>\r\n<li class="medium">Найти слова в которых встречаются сдвоенные гласные.\r\n	Рассчитать долю таких слов относительно всех слов.</li>	\r\n\r\n<li class="hard">Подсчитать сколько слогов содержит каждая строка.\r\nЕсли кол-во слогов в строках чередуется (например 8-7-8-7), сообщить об этом в файле отдельной строкой. \r\nВ качестве текста рекомендуется использовать стих (правило 1000 символов отменяется).\r\n<li class="nightmare">Найти прилагательные в тексте.\r\n	Рассчитать их долю относительно всех слов. </li>\r\n<li class="nightmare">Найти имена в тексте.\r\n	Рассчитать их долю относительно всех слов. </li>\r\n</ol>\r\n</div>\r\n</div>\r\n\r\n<div class="lab">\r\n<h2 class="title"><a>#2. Регулярные выражения</a></h2>\r\n<div class="info">\r\nДля данного задания все операции поиска и разбиения необходимо\r\nпроизводить с помощью регулярных выражений.\r\nТекст для обработки необходим прочитать из файла.\r\nТекст должен быть на русском языке и содержать не менее 1000 символов и исключать возможность пустых ответов. \r\nПод результат необходимо создать новый файл, и записать в него ответ.\r\n<ol class="tasks">\r\n<li class="easy">Найти слова в которых встречаются более трех подряд идущих согласных (нпр: <b>стр</b>аница).\r\n	Рассчитать долю таких слов относительно всех слов.</li>\r\n\r\n<li class="easy">Найти в тексте даты вида дд.мм.гггг (например 13.10.2013). Исходить из предположения что\r\nвсе даты в тексте валидные (т.е. нет таких 32.13.2201). Рассчитать долю таких последовательностей\r\nотносительно всех цифровых последовательностей.</li>\r\n<li class="easy"> Найти в тексте слова оканчивающиеся на несколько подряд идущих гласных (напр: вкусн<b>ое</b>).\r\n	Рассчитать долю таких слов относительно всех слов.</li>\r\n<li class="easy">\r\n	Найти в тексте слова длины заданной пользователем, и рассчитать их долю относительно всех слов.\r\n</li>\r\n<li class="easy">Найти в тексте слова с дефисом. Рассчитать их долю относительно всех слов.</li>\r\n<li class="easy">Найти в тексте слова содержащие не более одного дефиса. Рассчитать долю таких слов относительно всех слов.</li>\r\n<li class="easy">Найти в тексте цитаты</li>\r\n<li class="easy">Найти в тексте все IP-адреса. Исходить из предположения что все IP-адреса в тексте валидные. \r\nРассчитать долю таких числовых последовательностей относительное всех числовых последовательностей.</li>\r\n<li class="easy">Найти в тексте вопросительные и восклицательные предложения. Рассчитать долю таких предложений относительно всех предложений.</li>\r\n<li class="medium">Найти в тексте слова стоящие на начале и в конце предложений</li>\r\n<li class="medium">Найти в тексте слова содержащие четное кол-во букв. Рассчитать долю таких слов относительно всех слов.</li>\r\n<li class="medium">Найти в тексте слова содержащие нечетное кол-во цифр. Рассчитать долю таких слов относительно всех слов.</li>\r\n<li class="medium">Найти в тексте мобильные номера телефонов, с учетом возможности наличия черточек \r\n(нпр: <b>1 234 567 89 12</b>, <b>12345678912</b>, <b>+1 234 567 89 12</b>, <b>1-234-567-89-12</b>). Рассчитать долю таких последовательностей относительно всех цифровых последовательностей.</li>\r\n<li class="medium">Найти в тексте цифры от <b>1</b> до <b>99</b> (01, 02 и т.п. не считаются за цифры).\r\n	Рассчитать долю таких цифровых последовательностей относительно всех цифровых последовательностей.</li>\r\n<li class="medium">Найти в тексте предложения содержащие знаки препинания. Рассчитать долю таких предложений относительно всех предложений</li>\r\n<li class="hard">Найти в тексте пары слов в которых последняя буква первого совпадает с первой буквой второго слова.\r\n	Рассчитать долю таких слов относительно всех слов.</li>\r\n<li class="hard">Найти в тексте слова содержащие две подряд идущие одинаковые буквы. \r\n	Рассчитать долю таких слов относительно всех слов.</li>\r\n<li class="hard">Найти в тексте слова повторяющиеся два раза подряд. \r\n	Рассчитать долю таких слов относительно всех слов.</li>\r\n<li class="hard">Найти предложения в которых встречаются повторяющиеся слова.\r\n	Рассчитать долю таких предложений относительно всех предложений.</li>\r\n<li class="nightmare">Найти в тексте даты вида дд.мм.гггг (например 13.10.2013). Некорректные даты не должны войти \r\nв результат поиска (т.е. 32.13.2201 не подходит). Исходить из предположения что в каждом месяце 30 дней.</li>\r\n</ol>\r\n</div>\r\n</div>\r\n', 1, 0);
INSERT INTO `articles` (`id_`, `title`, `title_menu`, `title_page`, `description`, `category_id`, `text`, `enabled`, `ord`) VALUES
(11, 'Регулярные выражения. Часть 1', 'Регулярные выражения. Часть 1', 'Регулярные выражения. Часть 1', '', 2, 'Наверное вам хоть раз да приходилось файл в папке, удовлетворяющий\r\nмаске поиска типа <b>*.txt</b>. Такая форма записи позволяла найти всем файлы\r\nс расширением <b>txt</b>, возможно вы даже применяли что-то подобное при поиске по тексту.\r\nТак вот, регулярное выражение представляет из себя подобие такой маски, но с куда более широкими\r\nвозможностями.\r\n<p>\r\nЯ буду выделять регулярное выражение <span style="font-size:1.5em; color:#08E">голубым</span> цветом.<br>\r\nПоследовательности символов удовлетворяющие регулярному выражению выдею <span style="background-color: yellow">так</span> либо <span style="background-color: #BF0">так</span>.<p>\r\nРассмотрим простейшее регулярное выражение состоящие из трех символов <b>к</b>, <b>о</b> и <b>т</b>.\r\nТо бишь просто слово <b>кот</b>.<br> \r\n<div class="regex">\r\n<dt>кот</dt>\r\n<dd><b>кот</b>-окто<b>кот</b> киткоооткат толчет в <b>кот</b>ле мак</dd>\r\n</div>\r\n\r\nВ слове <b>киткоооткат</b>, то же имеется слово кот, только оно вместе одной буквы <b>о</b> содержит\r\nцелых <b>три</b>. Мы можем легко добавить к результату поиска и это слово если перепишем регулярное выражение\r\nследующим образом\r\n\r\n<div class="regex">\r\n<dt>ко+т</dt>\r\n<dd><b>кот</b>-окто<b>кот</b> кит<b>кооот</b>кат толчет в <b>кот</b>ле мак</dd>\r\n</div>\r\n\r\nДанное выражение можно прочитать как найти все подстроки начинающихся с <b>к</b>,\r\nза которой следует одна или более буква <b>о</b>, и которая заканчивается буквой <b>т</b>.\r\n<p>\r\nЗнак <b>+</b> после символа означает что символ может встречаться один и более раз.\r\nБывают ситуации когда присутствие или отсутствие символа не столь важно, для этого\r\nнам предлагают использовать символ <b>*</b>. Вот как поведет себя поиск если мы заменим <b>+</b> на <b>*</b>\r\n\r\n<div class="regex">\r\n<dt>ко*т</dt>\r\n<dd><b>кот</b>-о<b>кт</b>о<b>кот</b> кит<b>кооот</b>кат толчет в <b>кот</b>ле мак</dd>\r\n</div>\r\nТут у нас добавилась подстрока <b>кт</b>, которая начинается на <b>к</b>, заканчивается на <b>т</b>\r\nно не содержит букву <b>о</b>.\r\n<p>\r\nЕсли важно найти "котов" содержащие не более одной буквы <b>о</b>, то нужно использовать знак <b>?</b>  \r\n<div class="regex">\r\n<dt>ко?т</dt>\r\n<dd><b>кот</b>-о<b>кт</b>о<b>кот</b> киткоооткат толчет в <b>кот</b>ле мак</dd>\r\n</div>\r\nЕсли же нам хочется указать какое-то конкретное кол-во повторений того или иного символа,\r\nмы можем указать значение к фигурных скобках.\r\n<div class="regex">\r\n<dt>ко{3}т</dt>\r\n<dd>кот коот <b>кооот</b> коооот коооооот</dd>\r\n</div>\r\nНе меньше 3-х раз:\r\n<div class="regex">\r\n<dt>ко{3,}т</dt>\r\n<dd>кот коот <b>кооот</b> <b>коооот</b> <b>коооооот</b></dd>\r\n</div>\r\nНе больше 3-х раз:\r\n<div class="regex">\r\n<dt>ко{,3}т</dt>\r\n<dd><b>кот</b> <b>коот</b> <b>кооот</b> коооот коооооот </dd>\r\n</div>\r\nОт 3-х до 5-ти:\r\n<div class="regex">\r\n<dt>ко{3,5}т</dt>\r\n<dd>кот коот <b>кооот</b> <b>коооот</b> коооооот </dd>\r\n</div>\r\n\r\nА что если нам хочется найти не только "котов" но и "китов" и "катов", а может даже и "кытов".\r\nДля таких случаев в квадратных скобах можно указать какие именно буквы могут находится\r\nмежду <b>к</b> и <b>т</b> \r\n<div class="regex">\r\n<dt>к[оаыи]т</dt>\r\n<dd><b>кот</b>-окто<b>кот</b> <b>кит</b>кооот<b>кат</b> толчет в <b>кот</b>ле мак</dd>\r\n</div>\r\nАльтернативный вариант вместо фигурных скобок использовать прямую черту\r\n<div class="regex">\r\n<dt>к(о|а|ы|и)т</dt>\r\n<dd><b>кот</b>-окто<b>кот</b> <b>кит</b>кооот<b>кат</b> толчет в <b>кот</b>ле мак</dd>\r\n</div>\r\nДостоинство <b>|</b> заключается в том что позволяет указывать в качестве вариантов целый слова\r\nнапример:\r\n<div class="regex">\r\n<dt>к(о|ро|апо|и)т</dt>\r\n<dd>Такое регулярное выражение будет искать в тексте слова: <b>кот</b>, <b>крот</b>, <b>капот</b> и <b>кит</b></dd>\r\n</div>\r\n\r\nЧего-то я отвлекся. Снова пропал наш "кооот". Чтоы вернуть его надо разрешить повторения в регулярном выражении\r\n<div class="regex">\r\n<dt>к[оаыи]+т</dt>\r\n<dd><b>кот</b>-окто<b>кот</b> <b>кит</b><b><i>кооот</i></b><b>кат</b> толчет в <b>кот</b>ле мак</dd>\r\n</div>\r\n\r\nА если нас устроят всякие "к-ты", какая бы буква не была между <b>к</b> и <b>т</b>. Конечно можно в ручную\r\nпрописать все буквы, но можно сделать проще - указав допустимый диапазон букв\r\n<div class="regex">\r\n<dt>к[а-я]+т</dt>\r\n<dd><b>кот</b>-окто<b>кот</b> <b>кит</b><b><i>кооот</i></b><b>кат</b> толчет в <b>кот</b>ле мак</dd>\r\n</div>\r\n\r\nЛибо еще проще, если использовать класс <b>\\w</b> (с маленькой буквы) - который соответствует всякой букве или цифре.\r\nНе совсем правильно решение в данной ситуации (начнут вылезать всякие <b>к0ты</b>, <b>к1ро23ты</b>, <b>к_ты</b>, <b>к666ты</b> и прочая нечисть),\r\nно для учебных целей сойдет.\r\n<div class="regex">\r\n<dt>к\\w+т</dt>\r\n<dd><b>кот</b>-окто<b>кот</b> <b>кит</b><b><i>кооот</i></b><b>кат</b> толчет в <b>кот</b>ле мак</dd>\r\n</div>\r\n\r\nОчень часто, нам не будут интересовать различные вариации "котов", и нам захочется найти\r\nобыкновенного няшного кота. Как помним использование в качестве регулярного\r\nвыражения "кот" находило нам не только котов но и элементы котлов\r\nи октокотов. И если второе еще можно принять за кота, \r\nто котел уж совсем не кот. Проще говоря мы хотим найти просто слово "кот".\r\nДля таких целей регулярные выражения предлагают нам символ границы слова <b>\\b</b>. \r\nЧто найти точно слово "кот" можно использовать следующее выражение.\r\n<div class="regex">\r\n<dt>\\bкот\\b</dt>\r\n<dd><b>кот</b>-октокот киткоооткат толчет в котле мак</dd>\r\n</div>\r\n\r\nАга! Теперь мы можем найти слова содержащие котов на правой границы слова\r\n<div class="regex">\r\n<dt>\\w*кот\\b</dt>\r\n<dd><b>кот</b>-<b>октокот</b> киткоооткат толчет в котле мак</dd>\r\n</div>\r\nИли на левой\r\n<div class="regex">\r\n<dt>\\bкот\\w*</dt>\r\n<dd><b>кот</b>-октокот киткоооткат толчет в <b>котле</b> мак</dd>\r\n</div>\r\nЕсли не хотите включать слово "кот" в результат поиска, замените <b>*</b> на <b>+</b>.\r\n<p>\r\nОчевидно что на котах далеко не уедешь, и часто приходится искать более абстрактные вещи, например \r\nможет возникнуть необходимость просто найти все слова в тексте. На предыдущих занятиях\r\nприходилось использовать б-гомерзкий <b>Split()</b>. Теперь же у нас есть регулярные\r\nвыражения. Для того чтобы найти все слова подойдет такое выражение:\r\n<div class="regex">\r\n<dt>[А-Яа-я]+</dt>\r\n</div>\r\nПо умолчанию регулярные выражения являются регистро-зависимыми, поэтому приходится\r\nявно указывать строчные и прописные буквы. Если нужны еще и английские буквы то так\r\n<div class="regex">\r\n<dt>[A-Za-zА-Яа-я]+</dt>\r\n</div>\r\nКонечно можно использовать и класс <b>\\w</b>, но тогда к поиску добавятся еще и последовательности\r\nсодержащие цифры и подчеркивание <b>_</b>. То есть например так\r\n<div class="regex">\r\n<dt>\\w+</dt>\r\n<dd>Будет находить все последовательности символов содержащие исключительно\r\n<b>буквы</b>, <b>цифры</b> и <b>знак подчеркивания</b></dd>\r\n</div>\r\nЕсли вам нужны только цифры то можно использовать класс <b>\\d</b>:\r\n<div class="regex">\r\n<dt>\\d+</dt>\r\n<dd>Мне <b>15</b> лет, а мой IP <b>255</b>.<b>255</b>.<b>255</b>.<b>0</b></dd>\r\n</div>\r\nКстати, если указать в качестве регулярного выражения <b>\\w</b> без <b>*</b> или <b>+</b>\r\nполучим список всех букв, цифр и знаков подчеркиваний\r\n<div class="regex">\r\n<dt>\\w</dt>\r\n<dd><b>к</b><i>о</i><b>т</b>-<i>о</i><b>к</b><i>т</i><b>о</b><i>к</i><b>о</b><i>т</i> <b>к</b><i>и</i><b>т</b><i>к</i><b>о</b><i>о</i><b>о</b><i>т</i><b>к</b><i>а</i><b>т</b> <i>т</i><b>о</b><i>л</i><b>ч</b><i>е</i><b>т</b> <i>в</i> <b>к</b><i>о</i><b>т</b><i>л</i><b>е</b> <i>м</i><b>а</b><i>к</i></dd>\r\n</div>\r\n<p>\r\nМожет потребоваться найти все разделительные символы (пробелы, табуляции, переходы на новую строку и т.д).\r\nДля этого можно использовать класс <b>\\s</b>\r\n<div class="regex">\r\n<dt>\\s+</dt>\r\n<dd>кот-октокот<b> </b>киткоооткат<b> </b>толчет<b> </b>в<b> </b>котле<b> </b>мак</dd>\r\n</div>\r\nПрошу обратить внимания что знаки препинания не считаются за разделители.\r\nЕсли вам очень уж захочется пересчитать все разделители, включая знаки препинания\r\nбоюсь что придется перечислить их все в скобках. Примерно так:\r\n<div class="regex">\r\n<dt>[\\s,.;:?!]+</dt>\r\n<dd>кот<b>-</b>октокот<b> </b>киткоооткат<b> </b>толчет<b> </b>в<b> </b>котле<b> </b>мак</dd>\r\n</div>\r\nСначала я указываю класс всех пробельных разделителей, а потом дополняю его знаками препинания.\r\nЛибо если использовать класс обратный для класса <b>\\w</b>. Обратный класс пишется с заглавной буквы <b>\\W</b>:\r\n<div class="regex">\r\n<dt>\\W+</dt>\r\n<dd>кот<b>-</b>октокот<b> </b>киткоооткат<b> </b>толчет<b> </b>в<b> </b>котле<b> </b>мак</dd>\r\n</div>\r\n<p>\r\nА что если возникает ситуация когда надо найти любую последовательность символов, будь то\r\nпробелы буквы или что-то еще. Тут нам на помощь приходит символ <b>.</b> (\r\nточка, соответствует любому символу). Например следующее выражение \r\nсоответствует всему тексту:\r\n<div class="regex">\r\n<dt>.*</dt>\r\n<dd><b>кот-октокот киткоооткат толчет в котле мак</b></dd>\r\n</div>\r\nА если нам хочется найти все последовательности находящиеся между двумя <b>т</b>:\r\n<div class="regex">\r\n<dt>т.*т</dt>\r\n<dd>ко<b>т-октокот киткоооткат толчет в кот</b>ле мак</dd>\r\n</div>\r\nO__o? Чего-то много выделил. Ну уж точно не точно то, что я хотел.\r\nЭто называется жадностью, символы <b>+</b>, <b>*</b> при добавлении их после того или иного \r\nэлемента пытаются сформировать строку наибольшей длины соответствующей шаблону, часто\r\nэто приводит к неправильным результатом, чтобы избавить плюсик и звездочку от жадности,\r\nнадо добавлять после них знак вопроса. Вот так:\r\n<div class="regex">\r\n<dt>т.*?т</dt>\r\n<dd>ко<b>т-окт</b>око<b>т кит</b>кооо<b>ткат</b> <b>толчет</b> в котле мак</dd>\r\n</div>\r\nНу и наверное последнее что стоит отметить, что если вам вдруг захочется найти в тексте\r\nсимвол <b>*</b>, <b>+</b> или точку (<b>.</b>). Такие символы придется проэкранировать, путем добавления обратного \r\nслеша перед символом. Следующий пример находит в тексте все точки:\r\n<div class="regex">\r\n<dt>\\.+</dt>\r\n<dd>Вечереет<b>...</b> вот<b>.</b> и все<b>.</b></dd>\r\n</div>\r\n<hr>\r\n<h2>Регулярные выражения в C#	</h2>\r\nВ следующем консольном приложении регулярные выражения используются чтобы найти \r\nв тексте все слова начинающиеся на букву <b>a</b>.\r\n<pre class="brush: csharp">\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Text;\r\n\r\n// необходимо для считывания текста из файла\r\nusing System.IO; \r\n\r\n// необходимо для использования регулярных выражений\r\nusing System.Text.RegularExpressions; \r\n\r\nnamespace ConsoleApplication1\r\n{\r\n    class Program\r\n    {\r\n      static void Main (string[] args)\r\n		{\r\n		   /*\r\n		   	считываем текст из файла, и сохраняем его в переменную text,\r\n		   	Encoding.GetEncoding (1251) - использую чтобы явно указать кодировку,\r\n		   	в большинстве случаев, можно использовать просто Encoding.Default\r\n		   */			\r\n			string text = File.ReadAllText(\r\n				@"C:\\Алиса в Зазеркалье.txt",\r\n				Encoding.GetEncoding (1251)\r\n				);\r\n\r\n			/*\r\n			  Создаем регулярное выражения \r\n			  \\bА\\w+\r\n			  очевидно, оно распознает все слова начинающиеся на A\r\n			  \r\n			  устанавливаю флаг RegexOptions.IgnoreCase, \r\n			  чтобы не учитывать регистр букв			  \r\n			*/\r\n			Regex regEx = new Regex (@"\\bА\\w+", RegexOptions.IgnoreCase);\r\n			\r\n			/*\r\n			  Использую функцию Matches выше созданного регулярного выражения\r\n			  которая ищет в тексте последовательности символов \r\n			  удовлетворяющие регэкспу, \r\n			  и возвращает их в виде коллекции объектов типа Match \r\n			*/\r\n			MatchCollection matches = regEx.Matches (text);\r\n\r\n			/*\r\n			  Вывожу на экран все найденные слова (естественно, с повторениями).\r\n			  \r\n			  Стоит отметить что тип Match не просто строка, но также содержит \r\n			  информацию о расположении слова в тексте, его длине и некоторые\r\n			  другие плюшки.\r\n			*/\r\n			foreach (Match m in matches) \r\n			{\r\n				/*\r\n					напомню, что {0} заменяется на первый параметр \r\n					идущий после строки формата\r\n				*/\r\n				Console.WriteLine("Нашел на позиции {0}", m.Index);\r\n				Console.WriteLine("слово ''{0}''", m.Value);\r\n			}\r\n        }\r\n    }\r\n}\r\n</pre>', 1, 5),
(12, 'Регулярные выражения. Часть 2', 'Регулярные выражения. Часть 2', 'Регулярные выражения. Часть 2', '', 2, '', 0, 6),
(13, 'Литература', '&nbsp;&#9632; Литература', 'Книги по Мат.Логике', '', 4, '<ul>\n<li><a href="files/Мальцев Алгебраические системы.djvu">Мальцев А.И. Алгебраические системы</a> &mdash; про отношения</li>\n<li><a href="files/Мендельсон Э. Введение в математическую логику.djvu">Мендельсон Э. Введение в математическую логику</a> &mdash; формальная логика, предикаты, вывод и т.д</li>\n<li><a href="files/Лорьер - Системы искуственного интеллекта.djvu">Лорьер Системы искуственного интеллекта</a> &mdash; сложность, NP-полнота и еще много чего</li>\n</ul>', 1, 0);

-- --------------------------------------------------------

--
-- Структура таблицы `categories`
--

DROP TABLE IF EXISTS `categories`;
CREATE TABLE IF NOT EXISTS `categories` (
  `id_` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(128) NOT NULL,
  `title_menu` varchar(128) NOT NULL,
  `title_page` varchar(128) NOT NULL,
  `description` varchar(128) NOT NULL DEFAULT '',
  `controller` tinytext NOT NULL,
  `parent_id` int(11) DEFAULT NULL,
  `ord` int(11) NOT NULL DEFAULT '0',
  PRIMARY KEY (`id_`),
  UNIQUE KEY `id_` (`id_`),
  KEY `id__2` (`id_`),
  KEY `id__3` (`id_`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=11 ;

--
-- Дамп данных таблицы `categories`
--

INSERT INTO `categories` (`id_`, `title`, `title_menu`, `title_page`, `description`, `controller`, `parent_id`, `ord`) VALUES
(1, '', 'Занятия', '', '', 'lessons', -1, 0),
(2, 'Практикум по C#', '&#9632;&#9632;&#9632;', '', 'C# ', 'lessons/csharp', NULL, 2),
(4, 'Математическая логика', '&#x25B2;&#x25B2;', '', 'Математическая логика', 'lessons/mlogic', NULL, 1),
(5, '', 'Контрольные Работы', '', '', '', -1, 0),
(6, '', 'Скрипты', '', '', '', -1, 0),
(8, '', 'Вопросы к колоквиуму', '', '', 'coloclvium', -1, 0),
(9, '', '&#x25B2;', '', 'Главная страница', '', NULL, 0);

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
