-- MySQL dump 10.13  Distrib 5.5.32, for debian-linux-gnu (x86_64)
--
-- Host: localhost    Database: mmailmm8_data
-- ------------------------------------------------------
-- Server version	5.5.32-0ubuntu0.13.04.1

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `articles`
--

DROP TABLE IF EXISTS `articles`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `articles` (
  `id_` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(64) NOT NULL,
  `description` varchar(128) NOT NULL DEFAULT '',
  `category_id` int(11) DEFAULT NULL,
  `text` text NOT NULL,
  `enabled` tinyint(4) NOT NULL DEFAULT '1',
  PRIMARY KEY (`id_`)
) ENGINE=MyISAM AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `articles`
--

LOCK TABLES `articles` WRITE;
/*!40000 ALTER TABLE `articles` DISABLE KEYS */;
INSERT INTO `articles` VALUES (2,'Занятие первое. Работа с консолью','',2,' Для того чтобы писать приложения на <b>C#</b> совсем не обязательно скачивать тяжеловесную <b>Visual Studio 2010</b>, вполне хватит и <b>Express</b> версии,\r\nкоторая является бесплатной (в том числе и для коммерческой разработки) весит в 6 раз меньше и отличается от полноценной студии \r\nлишь отсутствием некоторых встроенных инструментов, которыми вы скорее всего никогда (по крайне мере в студенческой жизни) не воспользуетесь.\r\nСкачать можно отсюда \r\n<a href=\"http://download.microsoft.com/download/1/E/5/1E5F1C0A-0D5B-426A-A603-1798B951DDAE/VS2010Express1.iso\">Visual Studio 2010 Express All-in-One ISO</a>.\r\nВообще говоря можно скачать и <b>Visual Studio 2012 Express</b>, но я не уверен запустятся ли ваши программы на машинах что стоят в аудитории.\r\n<p>\r\nСкачав образ диска его можно записать на диск, либо примонтировать с помощью например <b>DaemonTools</b>. И установить <b>Visual C# 2010 Express</b>.\r\nСтоит отметить что установленную программу надо зарегистрировать. Скорее всего программа сама предложит это вам через некоторое время.\r\nПри регистрации придется указать свой <b>email</b>. Я указал одну из своих вполне рабочих почт, и за 3 года никакого спама не было. \r\nПри регистрации вам выдадут ключик.\r\n<hr>\r\n<p>\r\nЛюбая программа на <b>C#</b> имеет следующую базовую конструкцию\r\n<pre class=\"brush: csharp\">\r\nusing System;\r\nusing КакойТоВторойПакет;\r\nusing КакойТоТретийПакет;\r\n...\r\nusing КакойТо100500ыйПакет;\r\n\r\n\r\nnamespace Some_Namespace_Name\r\n{\r\n    // Любая программа является классом\r\n    class Some_Program\r\n    {\r\n        // тут начинается исполнение программы\r\n        static void Main(string[] args)\r\n        {\r\n            ...\r\n        }\r\n    }\r\n}\r\n</pre>\r\n<div class=\"note\">\r\nСоздавая новую программу, <b>VisualStudio</b> автоматически создает так называемое пространство имен (в нашем случае <b>Some_Namespace_Name</b>), \r\nкоторое можно использовать при разработке другого приложения с помощью тех же операторов <b>using</b>, что у нас идут в самом начале программы.\r\n</div>\r\n<p>\r\nТут я покажу как в <b>C#</b> приложении запросить у пользователя список чисел, \r\nи в качестве результата вывести на экран четные числа из этого списка.\r\n<pre class=\"brush: csharp\">\r\nusing System;   // подключение пространства имен для использования основных типов данных\r\n                // int, String, String[], int[] и т.д. а также объекта Console\r\n\r\nnamespace ConsoleApplication1\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            /* все что находится между открывающей и закрывающей  \r\n               фиугрными скобками называется телом функции */\r\n            ...\r\n        }\r\n    }\r\n}\r\n</pre>\r\nВесь последующий код надо записывать в тело функции <b>static void Main(string[] args)</b>\r\n<p>\r\nСначала нам надо выделить переменные которые мы будем использовать для хранения\r\nстроки введенной пользователем, и под массив подстрок на которые мы разобьем введенную строку.\r\n<pre class=\"brush: csharp\">\r\n// сюда сохраним строку введенную пользователем\r\nString strNumbers; \r\n// это массив для подстрок входящих в строку\r\nString[] strNumbersList;\r\n</pre>\r\n\r\nЧерный экран консоли с серыми буквами уж больно депрессивен, \r\nтак что почему бы и не добавить в него капельку радости:\r\n<pre class=\"brush: csharp\">\r\n// установим заголовок консоли\r\nConsole.Title = \"Я заголовок этой мрачной консоли T_T\";\r\n// меняем цвет текста на голубой\r\nConsole.ForegroundColor = ConsoleColor.Cyan;\r\n// меняем цвет фона текста на темно-синий\r\nConsole.BackgroundColor = ConsoleColor.DarkBlue;\r\n</pre>\r\nЗапрос данных у пользователя:\r\n<pre class=\"brush: csharp\">\r\n// выводим на экран предложение ввести числа\r\nConsole.WriteLine(\"Введите числа через пробел:\");\r\n\r\n/* \r\n   приостанавливаем выполнения до тех пор пока пользователь не введет \r\n   некоторый текст и не нажмет ENTER,\r\n   введенную строку сохраним в переменную strNumbers\r\n*/\r\nstrNumbers = Console.ReadLine();\r\n</pre>\r\nНу вроде строку текста от пользователя получили, теперь не плохо бы чего-нибудь с ней сделать.\r\nТак как предполагается что пользователь ввел нам список чисел через пробел, мы разобьем пробелами нашу\r\nстроку на подстроки. Разбивается строка функцией <b>Split</b>. \r\n\r\n<pre class=\"brush: csharp\">\r\n// разобьем введенную пользователем сторку пробелами на подстроки\r\nstrNumbersList = strNumbers.Split(\' \');\r\n</pre>\r\n\r\n<div class=\"note\">\r\nВсе переменный типа <b>String</b> обладают функцией <b>Split</b>,\r\nв качестве результат она возвращает массив строк, полученный разбиением строки разделителем указанным в качестве параметра.\r\n<pre class=\"brush: csharp\">\r\nsome_variable.Split(\' \');\r\n</pre>\r\nЕсли хочется использовать более одного разделителя (например пробел и запятую) придется написать уже вот-такое заклинание\r\n<pre class=\"brush: csharp\">\r\nsome_variable.Split( new Char[]{\' \' , \',\'} );\r\n\r\n// или так, указывать тип массива не обязательно, в данном случае компилятор сам догадается по содержимому\r\nsome_variable.Split( new []{\' \' , \',\'} );\r\n\r\n// или так чтобы убрать пустые строки которые возникают, если у нас например два пробела подряд\r\nsome_variable.Split( new []{\' \' , \',\'}, StringSplitOptions.RemoveEmptyEntries );\r\n</pre>\r\n</div>\r\n<p>\r\nИногда вам захочется сбросить цвета в консоли на те что идут по умолчанию, для этого у объекта <b>Console</b>\r\nесть метод <b>ResetColor</b>. Я сброшу цвета консоли на те унылые, что были по умолчанию и выведу сообщение о том,\r\nчто я сейчас я собираюсь вывести список четных чисел:\r\n<pre class=\"brush: csharp\">\r\n// сбрасываем цвет фона и текста на скучные >_>\r\nConsole.ResetColor();\r\n// выводим на экран сообщение; это хорошая практика всегда держать пользователя в курсе событий\r\nConsole.WriteLine(\"Среди введенных чисел, следующие числа являются четными:\");\r\n</pre>\r\nНу а теперь собственно то ради всего и затевалось, это вывод четных чисел на экран, каждое число в своей строчке.\r\n<br>Перво наперво я верну свои веселые цвета:\r\n<pre class=\"brush: csharp\">\r\n// меняем цвет текста на голубой\r\nConsole.ForegroundColor = ConsoleColor.Cyan;\r\n// меняем цвет фона на темно-синий\r\nConsole.BackgroundColor = ConsoleColor.DarkBlue; \r\n</pre>\r\nНу и вторым шагом собственно сам вывод\r\n<pre class=\"brush: csharp\">\r\n// проход по всем элементам массива strNumbersList, \r\n// свойство Length, очевидно, содержит количество элементов в массиве\r\nfor (int i = 0; i < strNumbersList.Length; ++i)\r\n{\r\n    // преобразуем подстроку в целое число\r\n    int num1 = int.Parse( strNumbersList[i] );  /* для доступа к i-му элементу массива\r\n                                                   используется операция индексации\r\n                                                   проще говоря чтобы узнать значение \r\n                                                   i-го элемента надо написать \r\n                                                   что-то вроде some_array[i], \r\n                                                  \r\n                                                   для 1-го элемента some_array[0]\r\n                                                   для 2-го элемента some_array[1]\r\n                                                   ...\r\n                                                   для последнего some_array[ some_array.Length - 1 ]\r\n                                                   да да нумерация с начинается с нуля!\r\n                                                */\r\n                                                \r\n    // проверяем делиться ли число на 2 без остатка, то есть по сути проверка на четность\r\n    if (num1 % 2 == 0)\r\n    {\r\n        // если так выведем на экран это число\r\n        Console.WriteLine(num1);\r\n    }\r\n}\r\n</pre>\r\n<div class=\"note\">\r\nВ C# четыре вида циклов:\r\n<pre class=\"brush: csharp\">\r\n// 1. Стандартный сишный цикл. Перебор i от 0 до max_value - 1\r\nfor ( i=0; i < max_value; i++ ) \r\n{\r\n    ...\r\n}\r\n\r\n// 2. Цикл для работы с массивами и коллекциями. Проходит по всем элементам коллекции.\r\n// Не позволяет изменять значения коллекции, только смотреть их значение.\r\nforeach (SomeType value in some_array) \r\n{\r\n    ...\r\n}\r\n\r\n// ну и условные циклы\r\n\r\n// 3. С предусловием, запуститься только если условие истинно\r\nwhile( %some_condition_is_true% ) \r\n{\r\n    ...\r\n}\r\n\r\n// 4. С постусловием, обязательно сделает один тик, и только\r\n// потом пойдет проверять истинность условия\r\ndo\r\n{\r\n    ...\r\n}\r\nwhile( %some_condition_is_true% ) \r\n</pre>\r\nА вот цикла вида <b>do ... until</b> - нет. Ну и пусть.\r\n<br> Мы будем использовать в основном циклы вида 1 и 2. \r\n</div>  \r\n<p>\r\nНу и последним шагом надо дать возможность пользователю рассмотреть выведенные числа.\r\nДля этого мы приостановим программу до тех пор пока пользователь не нажмет какую-нибудь клавишу.\r\n<pre class=\"brush: csharp\">\r\n// Иначе консоль автоматически закроется\r\n// и весь вывод улетит в небытие...\r\nConsole.ReadKey();\r\n</pre>\r\nВот и весь код \\(^_^)/\r\n<hr>\r\n<h2>Результат работы:</h2>\r\n<div class=\"console\"> \r\n<span style=\"background:DarkBlue;color:Cyan\">\r\nВведите числа через пробел:<br>\r\n12 123 78 3 2<br>\r\n</span>\r\nСреди введенных чисел, следующие числа являются четными:<br>\r\n<span style=\"background:DarkBlue;color:Cyan\">\r\n12<br>\r\n78<br>\r\n2\r\n</span>\r\n</div>\r\n<hr>\r\n<h2>Полный листинг:</h2>\r\n\r\n<pre class=\"brush: csharp;\">\r\nusing System;\r\nusing System.Linq;\r\n\r\nnamespace ConsoleApplication1\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            // сюда сохраним строку введенную пользователем\r\n            String strNumbers; \r\n            // это массив для подстрок входящих в строку\r\n            String[] strNumbersList; \r\n\r\n            Console.Title = \"Я заголовок этой мрачной консоли T_T\";\r\n\r\n            // меняем цвет текста на голубой\r\n            Console.ForegroundColor = ConsoleColor.Cyan;\r\n            // меняем цвет фона на темно-синий\r\n            Console.BackgroundColor = ConsoleColor.DarkBlue;\r\n\r\n            // выводим на экран предложение ввести числа\r\n            Console.WriteLine(\"Введите числа через пробел:\");\r\n            // приостанавиливаем выполнения до тех пор пока пользователь не введет \r\n            // некоторый текст и не нажмет ENTER,\r\n            // введенную строку сохраним в переменную strNumbers\r\n            strNumbers = Console.ReadLine();\r\n\r\n            // разобьем введенную пользователем сторку пробелами на подстроки\r\n            strNumbersList = strNumbers.Split(\' \');\r\n\r\n            // сбрасываем цвет фона и текста на те что идут по умолчанию\r\n            Console.ResetColor();\r\n            // выводим на экран сообщение\r\n            Console.WriteLine(\"Среди введенных чисел, следующие числа являются четными:\");\r\n\r\n            // меняем цвет текста на голубой\r\n            Console.ForegroundColor = ConsoleColor.Cyan;\r\n            // меняем цвет фона на темно-синий\r\n            Console.BackgroundColor = ConsoleColor.DarkBlue; \r\n\r\n            /// перебираем все элементы массива, нумерация элементов массива начинается от 0\r\n            for (int i = 0; i < strNumbersList.Length; ++i)\r\n            {\r\n                // преобразуем подстроку в целое число\r\n                int num1 = int.Parse(strNumbersList[i]);\r\n                // проверяем является число делиться ли оно на 2 без остатка\r\n                if (num1 % 2 == 0)\r\n                {\r\n                    // если так выведем на экран это число\r\n                    Console.WriteLine(num1);\r\n                }\r\n            }\r\n            // Иначе консоль автоматически закроется\r\n            // и весь вывод улетит в небытие...\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}\r\n</pre>\r\n<hr>\r\n<h2>Альтернативные варианты:</h2>\r\nВообще говоря получить тот же результат можно еще как минимум 5 способами, я их на всякий пожарный оставлю здесь \r\nвдруг пригодится:\r\n<p>\r\n<div class=\"note\">\r\n<h3>Способ #2.</h3>\r\n С использованием цикла <b>foreach</b>. Наверное самый лучший способ в подобной ситуации. Я б использовал именно его.\r\n<pre class=\"brush: csharp\">\r\nforeach (String subString in strNumbersList)\r\n{\r\n    // преобразуем подстроку в целое число\r\n    int num2 = int.Parse(subString);\r\n    // проверяем делиться ли число на 2 без остатка\r\n    if (num2 % 2 == 0)\r\n    {\r\n        // если так выведем на экран это число\r\n        Console.WriteLine(num2);\r\n    }\r\n}\r\n</pre>\r\n<h3>Способ #3.</h3>\r\nБолее хитрый способ с использованием встроенного языка <b>Linq</b>. \r\nГлавное не забыть вверху подключить пространство имен System.Linq:\r\n<pre class=\"brush: csharp\">\r\nusing System;\r\nusing System.Linq; // для использования функции Select\r\n\r\n...\r\n\r\n// формируем из массива подстрок массив целых чисел,\r\n// для этого используется функция Select\r\n// ей в качестве параметра передается функция которая применяется\r\n// к каждому элементу массива strNumbersList.\r\n// ToArray() - необходимо чтобы преобразовать резульат функции Select в массив\r\nint[] intArray = strNumbersList.Select(int.Parse).ToArray();\r\nforeach (int num3 in intArray)\r\n{\r\n    // проверяем делиться ли число на 2 без остатка\r\n    if (num3 % 2 == 0)\r\n    {\r\n        // если так выведем на экран это число\r\n        Console.WriteLine(num3);\r\n    }\r\n}\r\n\r\n</pre>\r\n<h3>Способ #4.</h3> Еще более хитрый способ с использованием лямбда выражений (это та часть что \"<b>x => x % 2 == 0</b>\"). \r\nОказывается за один шаг можно преобразовать массив строк в массив целых чисел и сразу же отсеять нечетные числа:\r\n<pre class=\"brush: csharp\">\r\nint[] evenNumbers = strNumbersList.Select(int.Parse).Where(x => x % 2 == 0).ToArray();\r\nforeach (int num4 in evenNumbers)\r\n{\r\n        // выведем на экран число\r\n        Console.WriteLine(num4);\r\n}\r\n</pre>\r\n<h3>Способ #5.</h3> \r\nБез использования цикла. С использованием функции <b>Join</b>. Функция <b>Join</b> является обратной для функции <b>Split</b>\r\nи позволяет склеить массив строк в одну строку. Между каждыми элементами массива можно указать разделитель. \r\nОказывается строку можно вывести как несколько строк для этого надо каждую подстроку отделить от другой \r\nсимволом перехода на новую строку <b>\"\\n\"</b> (в <b>VBS</b> это была константа <b>VbCrLf</b>). Например:<br>\r\nСтрока <span class=\"consoleIn\">\"Пожалуй хватит\\nна сегодня сишарпа\"</span> в консоли будет выведена как:\r\n<div class=\"console\">\r\nПожалуй хватит<br>\r\nна сегодня сишарпа\r\n</div>\r\nСпособ выглядит вот так:\r\n<pre class=\"brush: csharp\">\r\n// здесь мы одной строкой преобразовываем все подстроки к числам,\r\n// и среди этих чисел выбираем четные числа\r\nint[] evenNumbers2 = strNumbersList.Select(int.Parse).Where(x => x % 2 == 0).ToArray();\r\n\r\n// из массива целых чисел формируем массив строк\r\nString[] evenNumbersStr = evenNumbers2.Select(x => x.ToString()).ToArray();\r\n\r\n// склеиваем все элементы масива строк в одну большую строку outputString\r\n// String.Join(%разделитель строк%, %массив_строк%) возвращает объедененую строку\r\n// \"\\n\" - знак обозначает переход на новую строку\r\nString outputString = String.Join(\"\\n\", evenNumbersStr);\r\n\r\n// выводи эту строку на экран\r\nConsole.WriteLine(outputString);\r\n</pre>\r\n<h3>Способ #6.</h3> \r\nСтоит отметить, что способ 5 умещается в одну длинную мультикоманду.\r\nНе рекомендуется к использованию, так как сильно затрудняет восприятие кода,\r\n\r\n<pre class=\"brush: csharp\">\r\nConsole.WriteLine(String.Join(\"\\n\",strNumbersList.Select(int.Parse).Where(x => x % 2 == 0).Select(x => x.ToString()).ToArray()));\r\n</pre>\r\n</div>',1),(3,'Занятие второе. Коллекции','',2,'Коллекции являются своего рода динамическим массивами. Я собираюсь рассмотреть работу с коллекциями \r\nна примере списков (List) и словарей (Dictionary).\r\nСоздадим обыкновенное консольное приложение\r\n<pre class=\"brush: csharp\">\r\nusing System; // подключим пространство имен для работы с онсновными типами и консолью\r\nusing System.Collections.Generic; // для работы с коллекциями\r\nusing System.Linq; // для использование встроенного языка Linq\r\n\r\nnamespace ConsoleApplication1\r\n{\r\n	class Program\r\n	{\r\n		static void Main(string[] args)\r\n		{\r\n            \r\n		}\r\n	}\r\n}\r\n</pre>\r\nОпять же весь код ниже надо будет вписать в тело функции <b>static void Main(string[] args).</b>\r\n<p>\r\nВ данном приложении я для ускорения процесса, \"захардкодю\" строку ввода, чтобы не вводить ее по 100 раз.\r\nИ хотя работать я собираюсь сегодня со списком чисел, я намерено добавлю паразитных элементов в строку.\r\n<pre class=\"brush: csharp\">\r\n/* \r\n	чтобы положить чего то в строку совсем необязательно \r\n	запорашивать это \"чего-то\" от пользователя, можно явно указать строку\r\n*/\r\nString strNumbers = \"123 bz 12, 53, asd 7 91 15\";\r\n</pre>\r\nЧтобы разбить строку на подстроки, а тут в качестве разделителей используется не только пробелы но и запятые,\r\nпридется использовать усложненную версию функции <b>Split</b>\r\n<pre class=\"brush: csharp\">\r\n// массив разделителей\r\nChar[] separators = new Char[] { \' \', \',\' };\r\n\r\n/* \r\n	Создаем переменную для хранения списка строк, \r\n	полученных путем разбиения сторки strNumbers \r\n	разделителями из массива separators.\r\n\r\n	Второй параметр устанавливаем на StringSplitOptions.RemoveEmptyEntries\r\n	чтобы избежать появления пустых строк в массиве strNumbersArray,\r\n	которые возникают если два разделителя стоят рядом (например два подряд идущих пробела) \r\n*/\r\nString[] strNumbersArray = strNumbers.Split(separators, StringSplitOptions.RemoveEmptyEntries);\r\n</pre>\r\n<hr>\r\n<h2>Списки. Тип List&#60;int&#62;</h2>\r\nТак как нашей целью является изучить возможности работы со списками, необходимо этот список создать.\r\nДля большинства объектов (типов) с которыми вы столкнетесь необходимо будет использование оператор new.\r\n<pre class=\"brush: csharp\">\r\n/* \r\n	Данное предложение читается справа налево, т.е. \r\n	создать в памяти объект типа List&ltint&gt (список целых чисел),\r\n	и установить numbers как ссылку на этот объект\r\n*/\r\nList&ltint&gtnumbers = new List&ltint&gt();\r\n</pre>\r\nТеперь этот список надо наполнить числами полученные преобразованием элементов массива <b>strNumbersArray</b> в числа.\r\nОчевидно что не все элементы массива <b>strNumbersArray</b> являются числами, если вывести сейчас массив <b>strNumbersArray</b> на экран \r\nто мы увидим примерно следующую картину:\r\n<div class=\"console\">\r\n123<br>\r\nbz<br>\r\n12<br>\r\n53<br>\r\nasd<br>\r\n7<br>\r\n91<br>\r\n15<br>\r\n</div>\r\nОчевидно, что <span class=\"consoleIn\">bz</span> и <span class=\"consoleIn\">asd</span> не являются числами.\r\nДля заполнения списка числами мы будем использовать цикл <b>foreach</b> внутри которого будет вызываться функция\r\n<b>TryParse </b>которая позволяет проверить строку на ее возможность преобразования в число, если такая возможность\r\nесть то в она возвращает true и во второй параметр передает результат преобразования.\r\n\r\n<pre class=\"brush: csharp\">\r\n// проходим по всем подстрокам\r\nforeach (Strig strNumber in strNumbersArray)\r\n{\r\n	int num;\r\n	/*\r\n		тут мы проверяем можно ли преобразовать строку в число\r\n		если преобразование возможно то результат преобразования\r\n		будет положен в переменную num, которую мы создали шагом выше\r\n	*/\r\n	if ( int.TryParse(strNumber, out num) == true )\r\n	{\r\n		numbers.Add(num);\r\n	}\r\n}\r\n</pre>\r\n\r\n<div class=\"note\">\r\nФункция объекта <b>int</b> по имени <b>TryParse</b> представляет собой функцию возвращающая сразу два значение \r\n<pre class=\"brush: csharp\">\r\nint.TryParse(strNumber, out num)\r\n</pre>\r\nПервое значение мы используем когда сравниваем значения функции с константой <b>true</b>\r\n<pre class=\"brush: csharp\">\r\n// не обращаем внимание на многоточие\r\nif ( int.TryParse( ... ) == true )\r\n...\r\n// можно было записать это и так выделив дополнительную переменную \r\n// для сохранения результата функции\r\nbool tryParseResult = int.TryParse( ... );\r\nif ( tryParseResult == true )\r\n...\r\n</pre>\r\nЭта же функция в случае успешной конвертации возвращает еще одно значение, \r\nоно передается во второй параметр. Чтобы получить к нему доступ необходимо \r\nсоздать дополнительную переменную и передать ее в качестве второго параметра \r\nвместе с ключевым словом <b>out</b>:\r\n<pre class=\"brush: csharp\">\r\n...\r\n// создаем переменную для хранения результата преобразования\r\nint num;\r\n// пытаемся преобразовать строку some_string в число\r\nif ( int.TryParse(some_string, out num) ) \r\n{\r\n	// если преобразование было успешным то выводим на экран это число	\r\n	Console.WriteLine(num);\r\n} \r\nelse \r\n{\r\n	// в случае неудачи сообщим что данная строка не является числом	\r\n	Console.WriteLine(some_string + \" не является числом >_>\");\r\n}\r\n</pre>\r\nТо есть должно быть очевидно, что если <b>some_string == \"123\"</b>, \r\nна консоле увидим:\r\n<div class=\"console\">\r\n123\r\n</div>\r\nЕсли же <b>some_string == \"фонарик\"</b>, на консоле увидим:\r\n<div class=\"console\">\r\nфонарик не является числом >_>\r\n</div>\r\n</div>\r\n<p>\r\nПосле выполнения всех этих операций список <b>numbers</b> будет содержать \r\nчисла, (если быть точным, то с учетом того какую строку мы задали \r\nв списке будут числа <b>123, 12, 53, 7, 91, 15</b>, именно в таком порядке)\r\n<p>\r\nТеперь выведем их на экран\r\n<pre class=\"brush: csharp\">\r\n// сообщим пользователю о том что собираемся показать все числа в списке\r\nConsole.WriteLine(\"Исходный список:\");\r\n\r\n// выведем список на экран\r\nforeach(int number in numbers) Console.Write(number + \" \");\r\n\r\n/*\r\n	так как фукнция Console.Write в отличие от Console.WriteLine \r\n	не переводит курсор на новую строку, то я вызову функцию Console.WriteLine \r\n	чтобы такое переход осуществить собственноручно\r\n*/\r\nConsole.WriteLine();\r\n</pre>\r\nУпорядочивание элементов в C# -- милое дело, все делается в одну-две команды\r\n<h4>Сортировка по возрастанию</h4>\r\n<pre class=\"brush: csharp\">\r\n// функция Sort сортирует элементы списка в порядке возрастания\r\nnumbers.Sort();\r\n\r\n// вывод на экран\r\nConsole.WriteLine(\"Упорядоченный по возрастанию:\");\r\nforeach(int number in numbers) Console.Write(number + \" \");\r\nConsole.WriteLine();\r\n</pre>\r\n\r\n<h4>Сортировка по убыванию</h4>\r\n<pre class=\"brush: csharp\">\r\n// сначала отсортируем по возрастанию \r\nnumbers.Sort();\r\n// а потом развернем список \r\n// вообще не самый эффективный способ, \r\n// но вполне пригодный для небольших списков\r\nnumbers.Reverse();\r\n\r\n// вывод на экран\r\nConsole.WriteLine(\"Упорядоченный по возрастанию:\");\r\nforeach(int number in numbers) Console.Write(number + \" \");\r\nConsole.WriteLine();\r\n</pre>\r\n<div class=\"note\">\r\nБолее эффективным способом упорядочения списка по убыванию, заключается в явном указании функции сортировки:\r\n<pre class=\"brush: csharp\">\r\nnumbers.Sort( (num1, num2) => num2.CompareTo(num1) );\r\n</pre>\r\nЗдесь используется лямбда-выражение, которым реализуется функция от двух параметров \r\nвозвращающая<br>\r\n<b>-1</b> если <b>num1 > num2</b>,<br>\r\n<b>1</b> если <b>num1 < num2</b><br> \r\n<b>0</b> если они совпадают.\r\n</div>\r\n<h4>Количество элементов в списке</h4>\r\n<pre class=\"brush: csharp\">\r\nConsole.Write\"Количество элементов в списке: \");\r\n// используем свойстве списка count\r\nConsole.WriteLine(numbers.count);\r\n</pre>\r\n\r\n<h4>Минимальный элемент</h4>\r\n<pre class=\"brush: csharp\">\r\n/*\r\n	в отличие от количества элементов, под минимальный элемент\r\n	лучше создать переменную, так как при каждом вызове функции Min\r\n	этот элемент ищется заново\r\n*/\r\nint minimum = numbers.Min();\r\n\r\nConsole.Write(\"Минимальный элемент: \");\r\nConsole.WriteLine(minimum);\r\n</pre>\r\n\r\n<h4>Максимальный элемент</h4>\r\n<pre class=\"brush: csharp\">\r\n/*\r\n	и под максимальный элемент лучше создать переменную, \r\n	так как при каждом вызове функции Max\r\n	этот элемент также ищется заново.\r\n*/\r\nint maximum = numbers.Max();\r\n\r\nConsole.Write(\"Максимальный элемент: \");\r\nConsole.WriteLine(maximum);\r\n</pre>\r\n<hr>\r\n<h2>Словари. Тип Dictionary&#60;String, String&#62;</h2>\r\nСловари позволяют нам хранить пары вида (ключ, значение). Наилучшим примером объекта типа словарь,\r\nявляется, как бы это странно это не звучало, обычный словарь. Например русско-английский. Я продемонстрирую\r\nкак сделать словарь который будет переводить предложения не хуже печально известного Промта. \r\n<p>\r\nКак и любой объект сложнее <b>int</b> (ну или <b>String</b>, <b>float</b>, <b>long</b> и т.п.), словарь надо создавать с помощью оператора <b>new</b>:\r\n<pre class=\"brush: csharp\">\r\nDictionary&lt;String, String&gt; dictionary = new Dictionary&lt;string, string&gt;();\r\n/*\r\n	не обязательно указывать тип явно можно написать и так\r\n	var dictionary = new Dictionary&lt;string, string&gt;();\r\n*/\r\n</pre>\r\n\r\nТеперь добавим несколько слов в наш словарь\r\n<pre class=\"brush: csharp\">\r\n// первый параметр функции Add это ключ, второй - значение\r\ndictionary.Add(\"яблоко\", \"apple\");\r\ndictionary.Add(\"мороженое\", \"icecream\");\r\ndictionary.Add(\"чай\", \"tea\");\r\n</pre>\r\nВыводим содержимое словаря на экран\r\n<pre class=\"brush: csharp\">\r\nforeach (var pair in dictionary)\r\n{\r\n	/*\r\n	  Тут мы используем форматирование выводимого текста\r\n	  {0} - будет заменено на второй параметр функции WriteLine (т.е на значение pair.Key)\r\n	  {1} - будет заменено на третий параметр функции WriteLine (т.е на значение pair.Value)\r\n	  \r\n	  Аналогично можно добавить {2} - если у нас вдруг появиться какой-то третий параметр \r\n	*/	\r\n	Console.WriteLine(\"{0} по-английски {1}\", pair.Key, pair.Value);\r\n}\r\n</pre>\r\nДобавим следующее приложение:\r\n<pre class=\"brush: csharp\">\r\nString sentence = \"Я пожалуй возьму яблоко, мороженое и чай\";\r\n</pre>\r\nИ воспользуемся нашим словарем для перевода (так как в нашем словаре только три слова,\r\nследовательно и перевести мы сможем  только три слова, ну для начала и так не плохо :D \r\n<pre class=\"brush: csharp\">\r\n// сначала покажем исходное предложение\r\nConsole.WriteLine(sentence);\r\n\r\n/*\r\n	собственно тут и осуществляется перевод,\r\n	для упрощения, я вместо того чтобы искать \r\n	слова из текста в словаре, будут искать \r\n	слова из словаря в тексте. \r\n	\r\n	Нелогично, зато код во много раз проще,\r\n	иначе бы мне пришлось разбивать текст \r\n	на слова, искать каждое слово в словаре,\r\n	а потом еще эти слова уже склеивать обратно\r\n	в предложение, что, вообще говоря, является\r\n	нетривиальной задачей.\r\n*/\r\n\r\nforeach (var wordPair in dictionary)\r\n{\r\n	/*\r\n	  Функция Replace ищет в строке для которой она вызывается\r\n	  значение первого параметра и заменяет его значением второго параметра.\r\n	  \r\n	  В качестве результата  возвращает новую строку которая является\r\n	  преобразованным предложением.\r\n	  \r\n	  Тут мы присваиваем значение функции самой строке, чтобы на следующей\r\n	  итерации цикла уже использовалось новое предложение \r\n	  в котором часть слов уже переведена\r\n	*/	 \r\n	 sentence = sentence.Replace(wordPair.Key, wordPair.Value);\r\n}\r\n\r\n// вывод на экран переведенного предложения\r\nConsole.WriteLine(sentence);\r\n</pre>\r\nНу и последним шагов приостанавливаем работу программы в ожидании нажатия любой клавиши\r\nпользователем, иначе консолька автоматически закроется.\r\n<pre class=\"brush: csharp\">\r\n// ожидаем нажатия любой клавиши пользователем\r\nConsole.ReadKey();\r\n</pre>\r\n\r\n<hr>\r\n<h2>Результат работы:</h2>\r\n<div class =\"console\">\r\nИсходный список:<br>\r\n123 12 53 7 91 15<br>\r\nУпорядоченный по возрастанию:<br>\r\n7 12 15 53 91 123 <br>\r\nУпорядоченный по убыванию:<br>\r\n123 91 53 15 12 7 <br>\r\nКоличество элементов: 6<br>\r\nМинимальный элемент: 7<br>\r\nМаксимальный элемент: 123<br>\r\nмороженое по-английски icecream<br>\r\nчай по-английски tea<br>\r\nяблоко по-английски apple<br>\r\nЯ пожалуй возьму яблоко, мороженое и чай<br>\r\nЯ пожалуй возьму apple, icecream и tea<br>\r\n_\r\n</div>\r\n<hr>\r\n<h2>Полный листинг:</h2>\r\n<pre class=\"brush: csharp\">\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\n\r\n\r\nclass Program\r\n{\r\n    static void Main(string[] args)\r\n    {\r\n        // чтобы положить чего то в строку совсем необязательно \r\n        // заправшивать чего-то от пользователя, можно явно указать строку\r\n        String strNumbers = &quot;123 bz 12, 53, asd 7 91 15&quot;;\r\n\r\n        // разбиваем строку запятыми и пробелами, и убираем за одно пустые строки\r\n        Char[] separators = new Char[] { &apos; &apos;, &apos;,&apos; };\r\n        String[] strNumbersArray = strNumbers.Split(separators, StringSplitOptions.RemoveEmptyEntries);\r\n\r\n        List&lt;int&gt; numbers = new List&lt;int&gt;(); // создаем динамический список\r\n\r\n        // проходим по всем подстрокам\r\n        foreach (String strNumber in strNumbersArray)\r\n        {\r\n            int num;\r\n            // тут мы проверяем можно ли преобразовать строку в число\r\n            if (int.TryParse(strNumber, out num))\r\n            {\r\n                numbers.Add(num);\r\n            }\r\n        }\r\n\r\n        Console.WriteLine(&quot;Исходный список:&quot;);\r\n        foreach(int number in numbers) Console.Write(number + \" \");\r\n        Console.WriteLine();\r\n\r\n        // функция Sort сортирует элменты массива в порядке возрастания\r\n        numbers.Sort();\r\n        \r\n        Console.WriteLine(&quot;Упорядоченный по возрастанию:&quot;);\r\n        foreach(int number in numbers) Console.Write(number + \" \");\r\n        // чтобы не слипалось со следующем выводом\r\n        Console.WriteLine();\r\n\r\n        // упорядочим список по убыванию\r\n        numbers.Sort();\r\n        numbers.Reverse();\r\n        \r\n        Console.WriteLine(&quot;Упорядоченный по убыванию:&quot;);\r\n        foreach(int number in numbers) Console.Write(number + \" \");\r\n        Console.WriteLine();\r\n\r\n		  Console.Write(&quot;Количество элементов: &quot;);\r\n        Console.WriteLine(numbers.Count);\r\n\r\n        int minimum = numbers.Min();\r\n        Console.Write(&quot;Минимальный элемент: &quot;);\r\n        Console.WriteLine(minimum);\r\n\r\n        int maximum = numbers.Max();\r\n        Console.Write(&quot;Максимальный элемент: &quot;);\r\n        Console.WriteLine(maximum);\r\n\r\n        Dictionary&lt;String, String&gt; dictionary = new Dictionary&lt;string, string&gt;();\r\n        dictionary.Add(&quot;яблоко&quot;, &quot;apple&quot;);\r\n        dictionary.Add(&quot;мороженое&quot;, &quot;icecream&quot;);\r\n        dictionary.Add(&quot;чай&quot;, &quot;tea&quot;);\r\n\r\n        dictionary = dictionary.OrderBy(pair =&gt; pair.Key).ToDictionary(pair =&gt; pair.Key, pair =&gt; pair.Value);\r\n\r\n        foreach (var pair in dictionary)\r\n        {\r\n            Console.WriteLine(&quot;{0} по-английски {1}&quot;, pair.Key, pair.Value);\r\n        }\r\n\r\n\r\n        String sentence = &quot;Я пожалуй возьму яблоко, мороженое и чай&quot;;\r\n\r\n        Console.WriteLine(sentence);\r\n        foreach (var wordPair in dictionary)\r\n        {\r\n            sentence = sentence.Replace(wordPair.Key, wordPair.Value);\r\n        }\r\n        Console.WriteLine(sentence);\r\n		\r\n\r\n        Console.ReadKey();\r\n    }\r\n}\r\n</pre>',1),(4,'Занятие третье. Работа с файлами','',2,'В качестве файла для экспериментов я возьму текст книги <a href=\"files/%D0%90%D0%BB%D0%B8%D1%81%D0%B0%20%D0%B2%20%D0%97%D0%B0%D0%B7%D0%B5%D1%80%D0%BA%D0%B0%D0%BB%D1%8C%D0%B5.txt\">\"Алиса в Зазеркалье\"</a>, вы можете\r\nиспользовать этот файл либо какой-нибудь свой, главное чтобы это был простой текст (<b>*.txt</b>).\r\n<p>\r\nСоздадим простое консольное приложение:\r\n<pre class=\"brush: csharp\">\r\nusing System; 		 // базовые типы\r\nusing System.Text; // для работы с кодировками\r\nusing System.IO;	 // для работы с фалами\r\nusing System.Collections.Generic; // для работы с коллекциями\r\nusing System.Linq; // для использования конструкций языка Linq\r\n\r\nnamespace ConsoleApplication1\r\n{\r\n	class MainClass\r\n	{\r\n		public static void Main (string[] args)\r\n		{\r\n		}\r\n	}\r\n}\r\n</pre>\r\nВозможны вы уже обратили внимание что у функции <b>public static void Main (string[] args)</b>. \r\nПрисутствует параметр <b>string[] args</b>. Это так называемые аргументы командной строки, их используют\r\nдля того чтобы контролировать поведение консольных приложений. Их количество и вид определяет разработчик программы.\r\nНапример команду <b>copy</b> консольной оболочки Windows (чтобы запустить консоль нажмите <b>Win+R</b>, введите <b>cmd</b> и нажмите <b>ENTER</b>) , можно вызвать следующим образом:\r\n<div class=\"console\">\r\ncopy somefile.txt d:\\Texts\r\n</div>\r\nПрограмме <b>copy</b> передается два аргумента (аргументы отделяются друг от друга пробелами, если параметр может содержать пробелы его надо заключить в кавычки, например: <b>copy \"Some file with spaces in name.txt\" d:\\Texts</b> ):<br>\r\n<b>somefile.txt</b> -- файл для копирования <br>\r\n<b>d:\\Texts</b> -- папка назначения, туда куда скопируется файл <br>\r\nЕсли бы мы были разработчиками программы <b>copy</b>, то мы могли бы обратиться к этим аргументам через параметр <b>string[] args</b>.<br>\r\n<b>args</b> -- это массив строк<br>\r\n<b>args[0]</b> -- хранит первый аргумент переданный в командную строку \r\n(т.е. для данного примера он содержал <b>\"somefile.txt\"</b>) <br>\r\n<b>args[1]</b> -- хранит второй аргумент переданный в командную строку \r\n(т.е. для данного примера он содержал <b>\"d:\\Texts\"</b>)<br>\r\nи т.д.\r\n<p>\r\nВ нашем приложении мы тоже будем использовать два параметра: для указания файла с текстом \r\nи для папки куда мы будем сохранять результаты обработки текста. Но мы же не собираемся запускать \r\nпрограмму из консоли, мы просто тыкаем <b>F5</b> и все делается на автомате. Чтобы передать параметры\r\nприложению необходимо сделать небольшие манипуляции.\r\n<br>Открыть свойства проекта:\r\n<img src=\"images/project_properties.png\" />\r\nВыбрать вкладку Debug (отладка):\r\n<img src=\"images/project_properties_debug.png\" />\r\nИ прописать туда параметры через пробел, как видите так как путь к книге \"Алиса в Зазеркалье\" содержит\r\nпробелы я заключаю его в двойные кавычки.\r\n<p>\r\nМожно закрыть вкладку свойств и перейти к написанию кода, как обычно весь код помещаем \r\nв тело функции <b>public static void Main (string[] args)</b>\r\n<p>\r\nСоздадим две переменные для хранения первого и второго аргумента (вообще говоря это необязательно,\r\nмы могли бы просто использовать <b>args[0]</b> и <b>args[1]</b>, но они имена не несут никакой смысловой\r\nнагрузке, и через неделю другую вам будет достаточно тяжело вспомнить для чего и какой аргумент использовался.\r\n<pre class=\"brush: csharp\">\r\nString inputFile = args [0]; // файл с текстом\r\nString outputDir = args [1]; // папка куда будем сохранять файл\r\n</pre>\r\nТеперь сделаем небольшую проверку, вдруг пользователь подсунет нам файл которого\r\nне существует или и вовсе какую ерунду. Для этого воспользуемся методом <b>Exists</b> класса <b>File</b>, \r\nкоторый возвращает <b>true</b> если файл существует и <b>false</b> в обратном случае. \r\n<pre class=\"brush: csharp\">\r\n// если файл не существует\r\nif ( !File.Exists (inputFile) ) {\r\n\r\n	// сообщить об этом пользователю\r\n	Console.WriteLine(\"файла \\\"\" + inputFile + \"\\\" не существует!\");\r\n	\r\n	// дать возможность прочитать сообщение	\r\n	Console.ReadKey();\r\n	\r\n	// завершить программу\r\n	return;\r\n}\r\n</pre>\r\n<div class=\"note\">\r\nВозможно вы обратили внимание что мы используем <b>\\</b> для того что выводить кавычки. \r\n<pre class=\"brush: csharp\">\r\n... \r\nConsole.WriteLine(\"файла \\\"\" + inputFile + \"\\\" не существует!\");\r\n...\r\n</pre>\r\nСвязанно это с тем, что кавычки являются зарезервированным символом поэтому чтобы вывести сроку содержащую\r\nкавычки необходимо кавычки в ней \"экранировать\" с помощью обратного слеша. Таким образом, чтобы создать строку содержащую\r\nнеобходимо делать так:\r\n<pre class=\"brush: csharp\">\r\nString some_string = \"\\\"\"; // с одним символом двойных кавычек\r\n...\r\nString another_string = \"\\\"\\\"\";// с двумя символами двойных кавычек\r\n...\r\nString other_string = \"\\\\\"; // с обратным слешом\r\n...\r\nString freak_string = \"\\\\\\\"\\\\\"; // с символом двойных кавычек, между двумя обратными слэшами \r\n</pre>\r\nПоследняя строка уж совсем страшная.<br>\r\n<b>C#</b> предлагает нам альтернативный способ задания строк\r\nсодержащих много экранированных символов. С использованием символа <b>@</b> (at - по-английски). \r\nС помощью <b>@</b> последняя строка может быть записана как\r\n<pre class=\"brush: csharp\">\r\nString freak_string = @\"\\\"\"\\\"; \r\n/*\r\n  кавычки все равно приходится экранировать, повторяя их два раза\r\n    \r\n  два раза повторенная двойная кавычка \r\n  будет выведена как один символ двойной кавычки\r\n*/\r\n</pre>\r\nВ основном символ используют для задания путей в <b>Windows</b> (в <b>UNIX</b> подобных системах, в путях используется прямой слэш\r\nи таких проблем там не возникает):\r\n<pre class=\"brush: csharp\">\r\n// без @:\r\nString path1 = \"C:\\\\somedir\\\\anotherdir\\\\somefile.jpeg\";\r\n\r\n// с использованием @:\r\nString path2 = @\"C:\\somedir\\anotherdir\\somefile.jpeg\";\r\n\r\n// вывести строки на экран\r\nConsole.WriteLine(path1);\r\nConsole.WriteLine(path2);\r\n</pre>\r\nВыведутся на консоль обе строки абсолютно одинаково.\r\n<div class=\"console\">\r\nC:\\somedir\\anotherdir\\somefile.jpeg<br>\r\nC:\\somedir\\anotherdir\\somefile.jpeg\r\n</div>\r\n</div>\r\n<p>\r\nТеперь считаем содержимое файла в и сохраним в строку\r\n<pre class=\"brush: csharp\">\r\n/*\r\n	Кодировки это большая головная боль\r\n	если у вас вместо букв вылезут вопросики\r\n	попробуйте в качестве второго параметра \r\n	один из следующих вариантов:\r\n	\r\n	Encoding.GetEncoding (1251)\r\n	Encoding.Default;\r\n	Encoding.UTF8\r\n*/\r\nString fullText = File.ReadAllText (inputFile, Encoding.GetEncoding (1251));\r\n/*\r\n	выведем текст на экран,\r\n	кстати если текст достаточно большой\r\n	то в консоль он весь не влезет (даже с учетом прокрутки)\r\n*/\r\nConsole.Write(fullText);\r\n</pre>\r\nЯ хочу провести частотный анализ появления слов в тексте, для этого мне надо\r\nпрежде всего текст разбить на слова. Я воспользуюсь уже знакомой с прошлых уроков функцией\r\n<b>Split</b>, а в качестве разделителей выберу следующие символы:\r\n<pre class=\"brush: csharp\">\r\n/*\r\n	этот далеко не полный список разделителей, но и такой пойдет\r\n	обратите внимание на два последних символа,\r\n	\'\\n\' - символ перехода на новую строку\r\n	\'\\r\' - символ возврата каретки\r\n	эти символы не являются печатными, \r\n	но тем не менее в тексте присутствуют.\r\n*/\r\nChar[] separators = {\' \', \',\', \'.\', \'-\', \'!\', \'?\', \'\\\"\', \'\\n\', \'\\r\' };\r\n</pre>\r\nСформируем список слов:\r\n<pre class=\"brush: csharp\">\r\nString[] wordsArray = fullText.Split (separators, StringSplitOptions.RemoveEmptyEntries);\r\n</pre>\r\nТеперь я хочу создать новый список состоящий из пар: слово + кол-во появлений слова в тексте.\r\nДля этого как нельзя лучше подходят класс <b>Dictionary</b>. \r\nВ прошлом уроке я использовал словарь типа <b>Dictionary&lt;String, String&gt;</b>. \r\n<p>Сегодня я буду использовать словарь вида <b>Dictionary&lt;String, int&gt;</b>. Создам его:\r\n<pre class=\"brush: csharp\">\r\n/*\r\n	мне лень явно указывать тип переменной\r\n	к тому же он вполне очевиден из правой части \r\n*/\r\nvar dictWords = new Dictionary&lt;String, int&gt; ();\r\n</pre> \r\nА теперь мне надо заполнить этот словарь элементами. Для этого я организую цикл по всем словам из списка слов текста:\r\n<pre class=\"brush: csharp\">\r\n// для каждого слова из списка слов\r\nforeach (var word in wordsArray) \r\n{\r\n	// если словарь не содержит слово	\r\n	if (!dictWords.ContainsKey (word)) \r\n	{\r\n		/*\r\n			добавляем слово в качестве ключа в словарь,\r\n			его значение устанавливаем единичкой,\r\n			что означает -- слово один раз в тексте встречалось,\r\n			таки так оно и есть\r\n		*/		\r\n		dictWords.Add (word, 1);\r\n	} \r\n	else  // а если встречалось\r\n	{\r\n		/*\r\n			в таком случае добавлять слово с словарь не надо\r\n			но надо увеличить значение для слова на 1 \r\n		*/\r\n		dictWords [word] += 1;\r\n	}\r\n}\r\n</pre>\r\n<div class=\"note\">\r\nВ таком виде программа различает слова начинающиеся с большой и маленькой буквы, т.е. <b>алиса</b> и <b>Алиса</b> будут восприняты как два разных слова, вообще говоря такое поведение не логично, чтобы поправить ситуацию можно например переписать так:\r\n<pre class=\"brush: csharp\">\r\nforeach (var word in wordsArray) \r\n{\r\n	/*\r\n		введем дополнительную переменную, которая все слова будет переводить\r\n		в нижний регистр и уже для этого слова мы будем решать\r\n		добавлять его в словарь или изменять его значение\r\n	*/  	\r\n	String lowerWord = word.ToLower(); 	\r\n	\r\n	// если словарь не содержит слово	\r\n	if (!dictWords.ContainsKey (lowerWord)) \r\n	{\r\n		/*\r\n			добавляем слово в качестве ключа в словарь,\r\n			его значение устанавливаем единичкой,\r\n			что означает -- слово один раз в тексте встречалось,\r\n			таки так оно и есть\r\n		*/		\r\n		dictWords.Add (lowerWord, 1);\r\n	} \r\n	else  // а если встречалось\r\n	{\r\n		/*\r\n			в таком случае добавлять слово с словарь не надо\r\n			но надо увеличить значение для слова на 1 \r\n		*/\r\n		dictWords [lowerWord] += 1;\r\n	}\r\n}\r\n</pre>\r\n</div>\r\nНу а теперь самое интересное, мы могли бы вывести на экран какое слово сколько раз\r\nвстречалось, но вместо этого, мы будем производить вывод в файл. Для этого создадим объект\r\n<b>StreamWriter</b> который позволяет производить операции записи над файлом указанном\r\nв качестве параметра при его инициализации. \r\n<pre class=\"brush: csharp\">\r\nStreamWriter writer = new  StreamWriter(outputDir + @\"\\words.txt\");\r\n</pre>\r\nА теперь запишем информацию о нашем анализе в текстовый файл:\r\n<pre class=\"brush: csharp\">\r\n/*\r\n	Я воспользуюсь возможностью упорядочения на лету\r\n	с помощью функции OrderBy, \r\n	и укажу что хочу упорядочить по значению\r\n*/\r\nforeach (var pair in dictWords.OrderBy( x => x.Value ) ) \r\n{\r\n	/*\r\n		Напоминаю что \"{0,-14}: {1}\" -- это шаблон форматирования строки\r\n		сам шаблон означает вывести первый аргумент, если строковое значение\r\n		первого аргумента длиной меньше 14 символов добавить к нему справа пробелов \r\n		чтобы она равнялась 14 (если б стояло просто 14, то обозначало бы добавить слева), \r\n		\r\n		нарисовать двоеточие, \r\n		вывести второй аргумент\r\n		\r\n		все данные записываются в файл\r\n	*/	\r\n	writer.WriteLine(\"{0,-14}: {1}\", pair.Key, pair.Value);\r\n}\r\n\r\n// так как мы больше ничего не собираемся делать с этим файлом, его необходимо закрыть\r\nwriter.Close();\r\n</pre>\r\nМожно открыть файл и полюбоваться результатом. Вот несколько строчек из моего файла:\r\n<div class=\"console\">\r\nКоролева&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;168<br>\r\nа&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;170<br>\r\nто&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;170<br>\r\nтак&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;178<br>\r\nИ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;185<br>\r\nА&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;189<br>\r\nон&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;219<br>\r\nэто&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;219<br>\r\nя&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;243<br>\r\nкак&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;291<br>\r\nс&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;304<br>\r\nона&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;327<br>\r\nАлиса&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;488<br>\r\nчто&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;492<br>\r\nна&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;516<br>\r\nне&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;654<br>\r\nв&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;692<br>\r\nи&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;936\r\n</div>\r\nЕсли уже забыли, то в первой колонке у нас слова, а в правой то сколько раз они встретились в тексте. \r\n<p>Теперь попробуем сделать частотный анализ букв, в отличие от слов, для этого разбивать текст не надо, достаточно использовать исходный текст, мы можем обращаться к символом текста через операцию индексации. Но сначала создадим новый словарь. В качестве ключа будем использовать букву, а в качестве значения, то сколько раз она встречалась в тексте.\r\n<pre class=\"brush: csharp\">\r\nvar dictChars = new Dictionary&lt;Char, int&gt;();\r\n</pre>\r\nТеперь организуем цикл по всем символам текста:\r\n<pre class=\"brush: csharp\">\r\n// проходим по всем символам в тексте \r\nforeach (Char ch in fullText) {\r\n	/*\r\n		нас интересует лишь частотный анализ букв\r\n		поэтому мы использую статический метод IsLetter\r\n		класса Char, проверяем является ли символ буквой\r\n	*/ \r\n	if ( Char.IsLetter(ch) ) \r\n	{\r\n		// если такой буквы нет в словаре		\r\n		if ( !dictChars.ContainsKey (ch) ) \r\n		{\r\n			// добавляем ее в словарь, устанавливаем ее значение на 1\r\n			dictChars.Add (ch, 1);			\r\n		} \r\n		else  // а если есть\r\n		{\r\n			// увеличиваем значение буквы на один			\r\n			dictChars [ch] += 1;\r\n		}\r\n	}\r\n}\r\n</pre>\r\nПосле выполнения этого цикла наш словарь будет содержать информацию о том сколько раз\r\nкаждая буква встречалась в тексте.\r\n<p>Теперь рассмотрим альтернативный способ записи текста в файл.\r\nФункция <b>WriteAllText</b> класса <b>File</b>, позволяет записать строку в файл, за\r\nодин шаг, главное чтобы строка к этому моменту была сформирована. Формировать строку очень \r\nудобно с помощью объекта <b>StringBuilder</b>.\r\n<pre class=\"brush: csharp\">\r\n// создадим объект для формирования строк\r\nStringBuilder outString = new StringBuilder ();\r\n/*\r\n  для каждой пары: буква - кол-во появлений в тексте\r\n  как и в предыдущем примере я упорядочиваю на лету по значению\r\n*/\r\nforeach (var pair in dictChars.OrderBy( x => x.Value ) ) \r\n{\r\n	// рассчитываем долю появления буквы к количеству символов в тексте \r\n	// это число очевидно меньше единицы 	\r\n	double freq = (double) pair.Value / fullText.Length;\r\n\r\n	/* \r\n		добавляю строку\r\n		{0,-3} - выделить три символа с выравниванием влево под символ буквы \r\n		{1:0.000%} - вывести долю в процентах, с точностью до третьего знака после запятой\r\n	*/ \r\n	outString.AppendFormat(\"{0,-3}: {1:0.000%}\", pair.Key, freq);\r\n	\r\n	// добавить символ перехода на новую строку\r\n	outString.AppendLine();\r\n}\r\n</pre>\r\n<div class=\"note\">\r\nСтоит отметить что тут (<b>double freq = (double) pair.Value / fullText.Length</b>) \r\nмы сравниваем частоту появления буквы относительно количества символов в тексте\r\n(не только букв, но и знаков препинания, пробелов, цифр и т.д.), более правильно было бы\r\nвместо <b>fullText.Length</b>, ввести дополнительную переменную хранящую кол-во букв в тексте\r\n<pre class=\"brush: csharp\">\r\n/*\r\n	Тут мы используем Linq-функцию Count которая возвращает кол-во элементов в массиве,\r\n	для которых функция, указанная в качестве параметра, возвращает true\r\n*/\r\nint lettersCount = fullText.Count(Char.IsLetter);\r\n/*\r\n	равносильная запись \r\n	int lettersCount = fullText.Count( ch => Char.IsLetter(ch));\r\n*/\r\n</pre>\r\nНу и заменить пересчет доли\r\n<pre class=\"brush: csharp\">\r\n...\r\ndouble freq = (double) pair.Value / lettersCount;\r\n...\r\n</pre>\r\n</div>\r\n<p>\r\nНу а теперь мы эту строку сформированную объектом <b>outString</b> типа <b>StringBuilder</b> сохраним в файл:\r\n<pre class=\"brush: csharp\">\r\n/*\r\n	Так как StringBuilder не является строкой, \r\n	а является чем то вроде контейнера для хранения строки\r\n	строку надо извлечь с помощью метода ToString(), \r\n	\r\n	кстати методом ToString() обладают абсолютно все объекты в C#	\r\n*/\r\nFile.WriteAllText(outputDir + @\"\\chars.txt\" ,outString.ToString());\r\n</pre>\r\nВот несколько строк из моего файла:\r\n<div class=\"console\">\r\nь&nbsp;&nbsp;:&nbsp;1.503%<br>\r\nп&nbsp;&nbsp;:&nbsp;1.814%<br>\r\nу&nbsp;&nbsp;:&nbsp;1.967%<br>\r\nд&nbsp;&nbsp;:&nbsp;1.982%<br>\r\nм&nbsp;&nbsp;:&nbsp;2.101%<br>\r\nк&nbsp;&nbsp;:&nbsp;2.497%<br>\r\nв&nbsp;&nbsp;:&nbsp;2.823%<br>\r\nр&nbsp;&nbsp;:&nbsp;3.268%<br>\r\nс&nbsp;&nbsp;:&nbsp;3.901%<br>\r\nл&nbsp;&nbsp;:&nbsp;4.145%<br>\r\nн&nbsp;&nbsp;:&nbsp;4.286%<br>\r\nт&nbsp;&nbsp;:&nbsp;4.379%<br>\r\nи&nbsp;&nbsp;:&nbsp;4.496%<br>\r\nе&nbsp;&nbsp;:&nbsp;5.931%<br>\r\nа&nbsp;&nbsp;:&nbsp;6.579%<br>\r\nо&nbsp;&nbsp;:&nbsp;8.126%<br>\r\n</div>\r\n для интереса слазайте <a href=\"http://ru.wikipedia.org/wiki/%D0%A7%D0%B0%D1%81%D1%82%D0%BE%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C\" target=\"_blank\">сюда</a> и сравните порядок букв с тем что в вашем файле\r\n(напомню что буквы я упорядочил по частоте появления в тексте)\r\nНу напоследок откроем созданные файлы программно, мы конечно могли бы\r\nдойти до папки и в ручную открыть их, но ведь нам лень .__.\r\n<pre class=\"brush: csharp\">\r\n// открываем первый файл\r\nSystem.Diagnostics.Process.Start(outputDir + @\"/chars.txt\");\r\n// открываем второй файл\r\nSystem.Diagnostics.Process.Start(outputDir + @\"/words.txt\");\r\n</pre>\r\nЕсли в качестве стандартного приложения для работы с *.txt файлами у вас стоит блокнот,\r\nто у вас должно открыться два блокнота.\r\n<div class=\"note\">\r\nкстати <b>System.Diagnostics.Process</b> на самом деле просто класс <b>Process</b> для управления процессами операционной системы, если б мы подключили вверху программы пространство имен <b>System.Diagnostics</b>, можно было написать и так:\r\n<pre class=\"brush: csharp\">\r\n...\r\nusing System.Diagnostics;\r\n...\r\n\r\n// открываем первый файл\r\nProcess.Start(outputDir + @\"/chars.txt\");\r\n// открываем второй файл\r\nProcess.Start(outputDir + @\"/words.txt\");\r\n</pre>\r\n</div>\r\n<p>\r\nНу и напоследок дадим рассмотреть пользователю чего у нас на консоль выведено:\r\n<pre class=\"brush: csharp\">\r\n// приостановка, в ожидании нажатия пользователем любой клавиши\r\nConsole.ReadKey();\r\n</pre>\r\n<hr>\r\n<h2>Полный листинг:</h2>\r\n<pre class=\"brush: csharp\">\r\nusing System;\r\nusing System.Text;\r\nusing System.IO;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\n\r\nnamespace ConsoleApplication1\r\n{\r\n	class MainClass\r\n	{\r\n		public static void Main (string[] args)\r\n		{\r\n			String inputFile = args [0];\r\n			String outputDir = args [1];\r\n\r\n			if (!File.Exists (inputFile)) \r\n			{\r\n				Console.WriteLine (&quot;файла \\&quot;&quot; + inputFile + &quot;\\&quot; не существует!&quot;);\r\n				Console.ReadKey ();\r\n				return;\r\n			}\r\n\r\n			String fullText = File.ReadAllText (inputFile, Encoding.GetEncoding (1251));\r\n			Console.WriteLine (fullText);\r\n\r\n			Char[] separators = {&apos; &apos;, &apos;,&apos;, &apos;.&apos;, &apos;-&apos;, &apos;\\n&apos;, &apos;!&apos;, &apos;?&apos;, &apos;\\&quot;&apos;, &apos;\\r&apos; };\r\n			String[] wordsArray = fullText.Split (separators, StringSplitOptions.RemoveEmptyEntries);\r\n\r\n			var dictWords = new Dictionary&lt;string, int&gt; ();\r\n			foreach (var word in wordsArray) \r\n			{\r\n				if (!dictWords.ContainsKey (word)) \r\n				{\r\n					dictWords.Add (word, 1);\r\n				} \r\n				else \r\n				{\r\n					dictWords [word] += 1;\r\n				}\r\n			}\r\n\r\n			StreamWriter writer = new  StreamWriter (outputDir + @&quot;\\words.txt&quot;);\r\n\r\n			foreach (var pair in dictWords.OrderBy( x =&gt; x.Value )) \r\n			{\r\n				writer.WriteLine (&quot;{0,-14}: {1}&quot;, pair.Key, pair.Value);\r\n			}\r\n			writer.Close ();\r\n\r\n			var dictChars = new Dictionary&lt;Char, int&gt; ();\r\n			foreach (Char ch in fullText) \r\n			{\r\n				if (Char.IsLetter (ch)) \r\n				{\r\n					if (dictChars.ContainsKey (ch)) \r\n					{\r\n						dictChars [ch] += 1;\r\n					} \r\n					else \r\n					{\r\n						dictChars.Add (ch, 1);\r\n					}\r\n				}\r\n			}\r\n\r\n			StringBuilder outString = new StringBuilder ();\r\n			foreach (var pair in dictChars.OrderBy( x =&gt; x.Value ) ) \r\n			{\r\n				double freq = (double) pair.Value / fullText.Length;\r\n				outString.AppendFormat(&quot;{0,-3}: {1:0.000%}&quot;, pair.Key, freq);\r\n				outString.AppendLine();\r\n			}\r\n			File.WriteAllText(outputDir + @&quot;\\chars.txt&quot; ,outString.ToString());\r\n\r\n			System.Diagnostics.Process.Start(outputDir + @&quot;\\chars.txt&quot;);\r\n			System.Diagnostics.Process.Start(outputDir + @&quot;\\words.txt&quot;);\r\n\r\n			Console.ReadKey();\r\n		}\r\n	}\r\n}\r\n</pre>',1),(5,'Занятие четвертое. Формы','',2,'Создадим <b>Windows Form Application</b>. Для этого выбираем <b>Файл / Создать / Проект</b>,\r\nи в качестве шаблона указываем <b>Приложение Windows Forms</b>.\r\nВ реультате увидим примерно следующую картинку:\r\n<img src=\"images/csharp-04-01.png\" />\r\nЕсли у вас вдруг отсутствует левая (<b>панель элементов (toolbox)</b>) или правая панелька (<b>свойства (properties)</b>),\r\nих можно включить через меню <b>Вид (view)</b>\r\n<p>\r\nДобавим на форму пару элементов, пока нам хватит <b>Button</b> и <b>RichTextBox</b>. Чтобы добавить компонент его надо\r\nперетянуть с панели инструментов на форму. Должно получиться что-то в этом роде:\r\n<img src=\"images/csharp-04-02.png\">\r\nВыделим кнопку (кликнув на нее один раз), и поменяем ее имя (свойство <b>Name</b>) на <b>btnShowText</b>, \r\nи надпись на кнопке (свойство <b>Text</b>) на <b>Показать текст</b> \r\n<img src=\"images/csharp-04-03.png\">\r\n<div class=\"note\">\r\nКаждый объект на форме, включаю саму форму, обладает набором свойств, изменяя которые можно изменять\r\nповедение и вид объекта. Самое простое, но в тоже время самое важное свойства - это свойство <b>Name</b>. \r\nС помощью него мы обращаемся к объекту. То есть если кнопка имеет имя <b>RedButton</b>, то для\r\nтого чтобы программно нажать на эту кнопку надо будет написать\r\n<pre class=\"brush: csharp\">\r\nRedButton.Click();\r\n</pre>\r\nА если нам вдруг захочется узнать какая надпись на кнопке, и присвоить это значение какой-нибудь переменной мы напишем\r\n<pre class=\"brush: csharp\">\r\nstring labeltext = RedButton.Text;\r\n</pre>\r\n</div>\r\n<p>\r\nВыделим объект типа <b>RichTextBox</b> и поменяем его имя на <b>txtMain</b>.<br>\r\n<b>RichTextBox</b> позволяет отображать форматированный текст и редактировать его. \r\nЕсли сейчас запустить приложение (<b>F5</b>), то можно написать чего нибудь в текстовом поле,\r\nможно понажимать на кнопку, правда все это пока не принесет ни какой пользы. \r\n<p>\r\nЕсли приложение запущенно, то закроем его и вернемся к редактированию формы. Щелкнем два раза на\r\nнашу кнопку <b>btnShowText</b>. По идее мы должны оказаться в режиме редактирования кода. Увидим мы примерно следующее:\r\n\r\n<pre class=\"brush: csharp\">\r\n/*\r\n	В отличие от консольных приложений здесь уже намного \r\n	больше компонентов подключено по умолчанию.\r\n	Часть из них предназначена для работы с объектами на форме\r\n*/\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.ComponentModel;\r\nusing System.Data;\r\nusing System.Drawing;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Windows.Forms;\r\n\r\nnamespace WindowsFormsApplication1\r\n{ \r\n    /*\r\n    	Создавая форму, мы формируем новый объект формы на\r\n    	базе самой простой, на что и указывает \r\n    	...  class Form1 : Form ...\r\n    	\r\n    	Часто класс формы содержит очень много функций\r\n    	слово partial, позволяет разбивать код для класса\r\n    	на несколько подфайлов \r\n    */  \r\n    public partial class Form1 : Form\r\n    {\r\n        // это конструктор формы, он вызывается всего один раз\r\n        // когда форма создается в памяти впервые        \r\n        public Form1()\r\n        {\r\n            /*\r\n            	на самом деле данный файл содержит не весь код формы\r\n            	часть кода содержится в файле Form1.Designer.cs\r\n            	метод InitializeComponent описан в том файле, \r\n            	и код в нем генерируется автоматически\r\n            	в соответствии с тем какие объекты вы добавляете на форму,\r\n            	и как меняете их свойства\r\n            */\r\n            InitializeComponent();\r\n        }\r\n        \r\n        \r\n        /*\r\n        	эта функция возникла автоматически когда мы два раза щелкнули\r\n        	на кнопку btnShowText, в нем мы пропишем код \r\n        	который будет запускаться каждый раз \r\n        	когда во время исполнения программы \r\n        	на кнопку будут нажимать\r\n        */  \r\n        private void btnShowText_Click(object sender, EventArgs e)\r\n        {\r\n\r\n        }\r\n    }\r\n}\r\n</pre>\r\nНаша кнопка будет показывать текстовое сообщение, в котором будет содержаться текст\r\nиз <b>txtMain</b>. Для этого <b>.Net</b> предлагает нам класс <b>MessageBox</b>.\r\n<pre class=\"brush: csharp\">\r\n...\r\nprivate void btnShowText_Click(object sender, EventArgs e)\r\n{\r\n	// сохраним содержимое текстового поля\r\n	// в переменную	\r\n	String textFromTxtMain = txtMain.Text;\r\n	\r\n	// покажем значение переменной в окне MessageBox\r\n	MessageBox.Show(textFromTxtMain);\r\n}\r\n...\r\n</pre>\r\nЕстественно, чтобы в окне что-то было, это что-то надо ввести в текстовое поле.\r\nНо каждый раз вводить лень, так что вернемся в режим редактирования формы, и изменим значение\r\nсвойства <b>Text</b> объекта <b>txtMain</b> например на следующий текст:\r\n<div class=\"text\">\r\n Шалтай-Болтай взял книжку и уставился в нее.<br>\r\n - Кажется, здесь нет ошиб... - начал он.<br>\r\n - Вы ее держите вверх ногами, - прервала его Алиса.<br>\r\n - Ну, конечно, - весело заметил Шалтай-Болтай и взял перевернутую Алисой книжку. - То-то я смотрю, как странно все это выглядит! Поэтому я и сказал: \"_Кажется_, здесь нет ошибки!\", - хоть я и не успел разобраться как следует... Значит, так: триста шестьдесят четыре дня в году ты можешь получать подарки на день нерожденья.<br>\r\n - Совершенно верно, - сказала Алиса.<br>\r\n - И только _один_ раз на день рожденья! Вот тебе и слава!<br>\r\n - Я не понимаю, при чем здесь \"слава\"? - спросила Алиса.\r\n</div>\r\nЧтобы ввести этот текст, его можно скопировать и нажать на стрелочку справа от имени свойства,\r\nчто позволит нам работать с многострочным текстом:\r\n<img src=\"images/csharp-04-04.png\">\r\nТеперь если запустить приложение, текстовое поле сразу будет содержать текст.\r\n<p>\r\nДобавим еще два элемента на форму. \r\n<ul>\r\n<li>Добавим кнопку, назовем ее (свойство <b>Name</b>) <b>btnShowLine</b>, и поменяем текст надписи (свойство <b>Text</b>)\r\nна <b>ПоказатьСтроку</b>.</li>\r\n<li>Добавим счетчик, назовем его <b>edtLineIndex</b>.\r\n</ul>\r\nПолучим что-то в этом роде:\r\n<img src=\"images/csharp-04-05.png\">\r\nЩелкнем дважды на кнопку <b>btnShowLine</b> и пропишем обработчик события нажатия на кнопку.\r\nПо нажатию на эту кнопку должно будет выскакивать <b>MessageBox</b> в котором будет содержаться\r\nтекст строки из поля <b>txtMain</b> под номером указанным в <b>edtLineIndex</b>.\r\n<pre class=\"brush: csharp\">\r\nprivate void btnShowLine_Click(object sender, EventArgs e)\r\n{\r\n	// считываем выбранный в edtLineIndex значение	\r\n	int lineIndex = (int)edtLineIndex.Value;\r\n	\r\n	// с помощью свойства Lines объекта txtMain, считываем значение выбранной строки\r\n	// и сохраняем его в новую переменную\r\n	string lineText = txtMain.Lines[lineIndex];\r\n	\r\n	//выводим значение переменной на экран\r\n	MessageBox.Show(lineText);\r\n}\r\n</pre>\r\n<div class=\"note\">\r\nБолее правильно было бы добавить проверку на корректность указанного номера строки,\r\nвдруг пользователь выберет слишком большое значение. Такая ситуация может привести к\r\nпадению программы, поэтому правильнее будет написать так:\r\n<pre class=\"brush: csharp\">\r\nprivate void btnShowLine_Click(object sender, EventArgs e)\r\n{\r\n	// считываем выбранный в edtLineIndex значение	\r\n	int lineIndex = (int)edtLineIndex.Value;\r\n	\r\n	// проверяем на допустимость значения индекса строки\r\n	if ( lineIndex >= 0 && lineIndex < txtMain.Lines.Length)\r\n	{\r\n		// с помощью свойства Lines объекта txtMain, считываем значение выбранной строки\r\n		// и сохраняем его в новую переменную\r\n		string lineText = txtMain.Lines[lineIndex];\r\n		\r\n		//выводим значение переменной на экран\r\n		MessageBox.Show(lineText);\r\n	}\r\n}\r\n</pre>\r\n</div>\r\n<p>\r\nДобавим еще две кнопки, \r\n<ul>\r\n<li>Первую назовем <b>btnHighlightSep</b>, и поменяем ее надпись на <b>знаки</b>. С помощью этой\r\nкнопки мы сможем подсветить все знаки препинания в поле ввода</li>\r\n<li>вторую - <b>btnResetColor</b>, и поменяем ее надпись на <b>сбросить</b>.\r\nС помощью этой кнопки мы сможем снять подсветку текста.</li>\r\n</ul>\r\n<img src=\"images/csharp-04-06.png\">\r\nКак я уже выше упомянул, текстовое поле позволяет форматировать текст, \r\nт.е. менять цвет, шрифт у подстрок в тексте. Для этого используется функция <b>Select</b>.\r\nФункция позволяет выделить подстроку в тексте. После того как кусок текста выделен, мы используя свойства вида <b>Selection*</b>\r\nможем изменять цвета и прочие характеристики выделенного текста.\r\n<p>\r\nНапишем обработчик события клика для кнопки <b>btnHighlightSep</b>, для этого как обычно щелкнем на нее дважды.\r\n<pre class=\"brush: csharp\">\r\nprivate void btnHighlightSep_Click(object sender, EventArgs e)\r\n{\r\n	// прощелкиваем счетчик i от 0 до кол-ва символов в тексте	\r\n	for (int i=0; i&lt;txtMain.TextLength; ++i)\r\n	{\r\n		 // если символ на i-ой позиции, является знаком препинания	    \r\n	    if (Char.IsPunctuation(txtMain.Text[i]))\r\n	    {\r\n		    /* \r\n		  	  выделяем этот символ, функция \r\n		  	  Select(начальная_позиция_выделения, количество_символов для выделения)       \r\n		    */ \r\n	        txtMain.Select(i, 1);\r\n	        // устанавливаем цвет фона для выделенного текста на желтый \r\n	        txtMain.SelectionBackColor = Color.Yellow;\r\n	        // устанавливаем цвет выделенного текста на красный \r\n	        txtMain.SelectionColor = Color.Red;\r\n	    }\r\n	}\r\n}\r\n</pre>\r\nТеперь можно нажать на кнопку и полюбоваться на результат.\r\n<br>Правда реакция на нажатие кнопки видна только при первом нажатии. Чтобы исправить \r\nданную ситуация, пропишем кнопке с надписью <b>сбросить</b> обработчик события клика - кликнем на нее дважды.\r\n<pre class=\"brush: csharp\">\r\nprivate void btnResetColor_Click(object sender, EventArgs e)\r\n{\r\n	// выделяем весь текст	\r\n	txtMain.SelectAll();\r\n	\r\n	// сбрасываем цвет фона выделенного текста на тот что по умолчанию\r\n	txtMain.SelectionBackColor = txtMain.BackColor;\r\n	\r\n	// сбрасываем цвет выделенного текста на тот что по умолчанию\r\n	txtMain.SelectionColor = txtMain.ForeColor;\r\n}\r\n</pre>\r\nДобавим еще одну кнопку, которая, ради смеха, разукрасить текст в произвольные цвета.\r\n<ul>\r\n<li>Назовем ее <b>btnRandomColor</b>, и сменим ее надпись на <b>Разукрасить буквы</b></li>\r\n</ul>\r\n<img src=\"images/csharp-04-07.png\">\r\nНапишем обработчик события клика для новой кнопки\r\n<pre class=\"brush: csharp\">\r\nprivate void btnRandomColor_Click(object sender, EventArgs e)\r\n{\r\n	/*\r\n		создадим новый генератор случайных чисел\r\n		в соответствии с названием \r\n		он генерирует случайные числа\r\n		с помощью функции Next\r\n	*/	\r\n	Random rndGen = new Random();\r\n	\r\n	// снова пройдем счетчиком i от 0 до кол-ва символов в тексте\r\n	for (int i = 0; i < txtMain.TextLength; ++i)\r\n	{\r\n	    // выделяем i-ый символ	    \r\n	    txtMain.Select(i, 1);\r\n	    \r\n	    /*\r\n	    	сгенерируем новый цвет,\r\n	    	цвет состоит из 3-х компонент, \r\n	    	красной (1-ый параметр), принимаемое значение от 0 до 255\r\n			зеленый (2-ый параметр), принимаемое значение от 0 до 255\r\n			синий (3-ый параметр), принимаемое значение от 0 до 255\r\n			\r\n			rndGen.Next(256) - сгенерирует случайное число от 0 до 255\r\n			установив 0 для синей компоненты цвета, мы получим красно-зеленую\r\n			осеннюю раскраску\r\n		 */\r\n	    Color newRandomColor = Color.FromArgb(rndGen.Next(256), rndGen.Next(256), 0);\r\n\r\n	    // установим цвет выделенного символа на значене ново-сгенерируемого цвета\r\n	    txtMain.SelectionColor = newRandomColor;\r\n	}\r\n}\r\n</pre>\r\nНи и напоследок. Тут у меня фрагмент текста из книги Алиса в Зазеркалье, я просто\r\nчувствую себя обязанным чего-нибудь отзеркалить. Я буквы конечно вверх ногами не переверну, но продемонстрирую\r\nвозможность переноса текста из элемента в другой. Итак, добавим два новых элемента \r\n<ul>\r\n<li>Кнопку, назовем ее <b>btnMirror</b>, и подпишем <b>отзеркалить текст</b></li>\r\n<li>Поле для ввода текста (<b>RichTextBox</b>), и назовем его <b>txtMirrored</b></li>\r\n</ul>\r\n<img src=\"images/csharp-04-08.png\">\r\nПытаясь имитировать зеркало, мы развернем порядок букв в тексте. \r\nВообще говоря развернуть текст можно следующим трюком:\r\n<pre class=\"brush: csharp\">\r\n// формируем массив символов из строки\r\nchar[] charsArray = txtMain.Text.ToCharArray();\r\n// инвертируем массив символов\r\nArray.Reverse(charsArray);\r\n// формируем новую строку на основе инвертированного массива символов\r\ntxtMirrored.Text = new String(charsArray);\r\n</pre>\r\nНо нам кроме инвертирования самого текста хотелось бы еще сохранить и цвет, соответствующих символов, \r\nдля этого реализуем посимвольную раскраску текста. Пропишем обработчик события клика для кнопки <b>btnMirror</b>\r\n<pre class=\"brush: csharp\">\r\nprivate void btnMirror_Click(object sender, EventArgs e)\r\n{\r\n	// скопируем инвертированный текст из 	txtMain в txtMirrored\r\n	char[] charsArray = txtMain.Text.ToCharArray();\r\n	Array.Reverse(charsArray);\r\n	txtMirrored.Text = new String(charsArray);\r\n	\r\n	// пройдем счетчиком i от 0 до кол-ва символов в тексте txtMain\r\n	for (int i = 0; i < txtMain.TextLength; ++i)\r\n	{\r\n		 // выделяем текст в txtMirrored    \r\n	    txtMirrored.Select(i, 1);\r\n	    /*\r\n	    	выделяем соответствующий символ в txtMain;\r\n	    	напоминаю, что текст у нас развернут\r\n	    	и первый символ txtMirrored соответствует \r\n	    	последнему символу txtMain\r\n	    */\r\n	    txtMain.Select(txtMain.TextLength - i -1, 1);\r\n	    \r\n	    // копируем значения соответствующих цветов\r\n	    txtMirrored.SelectionColor = txtMain.SelectionColor;\r\n	    txtMirrored.SelectionBackColor = txtMain.SelectionBackColor;\r\n	}\r\n}\r\n</pre>\r\nСтоит отметить что посимвольное копирование цвета ОООООЧЕНЬ медленное, и если \r\nвы вдруг закинули в поле для текста какой-нибудь (пусть даже небольшой рассказик),\r\nто самым разумным будет нажать <b>Shift+F5</b>\r\n<div class=\"note\">\r\nКстати, если вы хотите наглядно видеть как происходит процесс перекраски текста, добавьте следующую\r\nстрочку в тело цикла:\r\n<pre class=\"brush: csharp\">\r\n	 ...\r\n    txtMirrored.SelectionColor = txtMain.SelectionColor;\r\n    txtMirrored.SelectionBackColor = txtMain.SelectionBackColor;\r\n	  \r\n	 /*\r\n	 	с помощью этой строчки на каждой итерации цикла,\r\n	 	txtMirrored будет перерисовывать себя,\r\n	 	(в общем случае обрабатывать сообщения от операционной системы)\r\n	 	это сильно замедлит программу \r\n	 	но зато добавит в нее вау-эффект\r\n	 */\r\n    Application.DoEvents();\r\n}\r\n</pre>\r\n</div>\r\n<hr>\r\n<h2>Полный листинг:</h2>\r\nВ отличие от консольных приложений здесь недостаточно будет\r\nпросто скопировать текст в редактор текста <b>Visual Studio</b>,\r\nтут таки придется еще и нарисовать форму, и правильно назвать все компоненты.\r\n<pre class=\"brush: csharp\">\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.ComponentModel;\r\nusing System.Data;\r\nusing System.Drawing;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Windows.Forms;\r\n\r\nnamespace WindowsFormsApplication1\r\n{\r\n    public partial class Form1 : Form\r\n    {\r\n        public Form1()\r\n        {\r\n            InitializeComponent();\r\n        }\r\n\r\n        private void btnShowText_Click(object sender, EventArgs e)\r\n        {\r\n            String textFromTxtMain = txtMain.Text;\r\n            MessageBox.Show(textFromTxtMain);\r\n        }\r\n\r\n        private void btnShowLine_Click(object sender, EventArgs e)\r\n        {\r\n            int lineIndex = (int)edtLineIndex.Value;\r\n            String lineText = txtMain.Lines[lineIndex];\r\n            MessageBox.Show(lineText);\r\n        }\r\n\r\n        private void btnHighlightSep_Click(object sender, EventArgs e)\r\n        {\r\n            for (int i=0; i&lt;txtMain.TextLength; ++i)\r\n            {\r\n                if (Char.IsPunctuation(txtMain.Text[i]))\r\n                {\r\n                    txtMain.Select(i, 1);\r\n                    txtMain.SelectionBackColor = Color.Yellow;\r\n                    txtMain.SelectionColor = Color.Red;\r\n                }\r\n            }\r\n        }\r\n\r\n        private void btnResetColor_Click(object sender, EventArgs e)\r\n        {\r\n            txtMain.SelectAll();\r\n            txtMain.SelectionBackColor = txtMain.BackColor;\r\n            txtMain.SelectionColor = txtMain.ForeColor;\r\n        }\r\n\r\n        private void btnRandomColor_Click(object sender, EventArgs e)\r\n        {\r\n            Random rndGen = new Random();\r\n            for (int i = 0; i &lt; txtMain.TextLength; ++i)\r\n            {\r\n                txtMain.Select(i, 1);\r\n                Color newRandomColor\r\n                    = Color.FromArgb(rndGen.Next(256), rndGen.Next(256), 0);\r\n                txtMain.SelectionColor = newRandomColor;\r\n            }\r\n        }\r\n\r\n        private void btnMirror_Click(object sender, EventArgs e)\r\n        {\r\n            char[] charsArray = txtMain.Text.ToCharArray();\r\n            Array.Reverse(charsArray);\r\n            txtMirrored.Text = new String(charsArray);\r\n            for (int i = 0; i &lt; txtMain.TextLength; ++i)\r\n            {\r\n                txtMirrored.Select(i, 1);\r\n                txtMain.Select(txtMain.TextLength - i -1, 1);\r\n                txtMirrored.SelectionColor = txtMain.SelectionColor;\r\n                txtMirrored.SelectionBackColor = txtMain.SelectionBackColor;\r\n\r\n                Application.DoEvents();\r\n            }\r\n            \r\n        }\r\n    }\r\n}\r\n</pre>',1);
/*!40000 ALTER TABLE `articles` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `categories`
--

DROP TABLE IF EXISTS `categories`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `categories` (
  `id_` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(64) NOT NULL,
  `description` varchar(128) NOT NULL DEFAULT '',
  `parent_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id_`)
) ENGINE=MyISAM AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `categories`
--

LOCK TABLES `categories` WRITE;
/*!40000 ALTER TABLE `categories` DISABLE KEYS */;
INSERT INTO `categories` VALUES (1,'Занятия','',NULL),(2,'Практикум по C#','',1);
/*!40000 ALTER TABLE `categories` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2013-09-29 17:37:31
