-- phpMyAdmin SQL Dump
-- version 3.5.2.2
-- http://www.phpmyadmin.net
--
-- Host: 192.168.100.102:3306
-- Generation Time: Nov 03, 2013 at 10:51 PM
-- Server version: 5.1.69
-- PHP Version: 5.4.8

SET SQL_MODE="NO_AUTO_VALUE_ON_ZERO";
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;

--
-- Database: `mmailmm8_data`
--

-- --------------------------------------------------------

--
-- Table structure for table `articles`
--

DROP TABLE IF EXISTS `articles`;
CREATE TABLE IF NOT EXISTS `articles` (
  `id_` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(128) NOT NULL,
  `title_menu` varchar(128) NOT NULL,
  `title_page` varchar(128) NOT NULL,
  `description` varchar(128) NOT NULL DEFAULT '',
  `category_id` int(11) DEFAULT NULL,
  `text` text NOT NULL,
  `enabled` tinyint(4) NOT NULL DEFAULT '1',
  `ord` int(11) NOT NULL DEFAULT '0',
  `top` tinyint(4) NOT NULL DEFAULT '0',
  `visits` int(11) NOT NULL DEFAULT '0',
  `date_create` int(11) NOT NULL DEFAULT '0',
  `date_update` int(11) NOT NULL DEFAULT '0',
  PRIMARY KEY (`id_`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=19 ;

--
-- Dumping data for table `articles`
--

INSERT INTO `articles` (`id_`, `title`, `title_menu`, `title_page`, `description`, `category_id`, `text`, `enabled`, `ord`, `top`, `visits`, `date_create`, `date_update`) VALUES
(2, 'Работа с консолью', 'Работа с консолью', 'Работа с консолью', '', 2, 'Для того чтобы писать приложения на **C#** совсем не обязательно скачивать тяжеловесную **Visual Studio 2010**, вполне хватит и **Express** версии, которая является бесплатной (в том числе и для коммерческой разработки) весит в 6 раз меньше и отличается от полноценной студии лишь отсутствием некоторых встроенных инструментов, которыми вы скорее всего никогда (по крайне мере в студенческой жизни) не воспользуетесь. \n\nСкачать можно отсюда "Visual Studio 2010 Express All-in-One ISO":http://download.microsoft.com/download/1/E/5/1E5F1C0A-0D5B-426A-A603-1798B951DDAE/VS2010Express1.iso\n\nВообще говоря можно скачать и **Visual Studio 2012 Express**, но я не уверен запустятся ли ваши программы на машинах что стоят в аудитории.\n\nСкачав образ диска его можно записать на диск, либо примонтировать с помощью например **DaemonTools**. И установить **Visual C# 2010 Express**.\n\nСтоит отметить что установленную программу надо зарегистрировать. Скорее всего программа сама предложит это вам через некоторое время. При регистрации придется указать свой **email**. Я указал одну из своих вполне рабочих почт, и за 3 года никакого спама не было. \nПри регистрации вам выдадут ключик.\n<hr>\n\nЛюбая программа на **C#** имеет следующую базовую конструкцию\n\npre(brush: csharp).. \nusing System;\nusing КакойТоВторойПакет;\nusing КакойТоТретийПакет;\n...\nusing КакойТо100500ыйПакет;\n\n\nnamespace Some_Namespace_Name\n{\n    // Любая программа является классом\n    class Some_Program\n    {\n        // тут начинается исполнение программы\n        static void Main(string[] args)\n        {\n            ...\n        }\n    }\n}\n\np. \n\n<div class="note"> Создавая новую программу, **VisualStudio** автоматически создает так называемое пространство имен (в нашем случае **Some_Namespace_Name**), которое можно использовать при разработке другого приложения с помощью тех же операторов **using**, что у нас идут в самом начале программы. </div>\n\nТут я покажу как в **C#** приложении запросить у пользователя список чисел, и в качестве результата вывести на экран четные числа из этого списка.\n\npre(brush: csharp).. \nusing System;   // подключение пространства имен для использования основных типов данных\n                // int, String, String[], int[] и т.д. а также объекта Console\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            /** все что находится между открывающей и закрывающей  \n               фиугрными скобками называется телом функции **/\n            ...\n        }\n    }\n}\n\np. \n\nВесь последующий код надо записывать в тело функции **static void Main(string[] args)**\n\nСначала нам надо выделить переменные которые мы будем использовать для хранения строки введенной пользователем, и под массив подстрок на которые мы разобьем введенную строку.\n\npre(brush: csharp).. \n// сюда сохраним строку введенную пользователем\nString strNumbers; \n// это массив для подстрок входящих в строку\nString[] strNumbersList;\n\np. \n\nЧерный экран консоли с серыми буквами уж больно депрессивен, так что почему бы и не добавить в него капельку радости:\n\npre(brush: csharp).. \n// установим заголовок консоли\nConsole.Title = "Я заголовок этой мрачной консоли T_T";\n// меняем цвет текста на голубой\nConsole.ForegroundColor = ConsoleColor.Cyan;\n// меняем цвет фона текста на темно-синий\nConsole.BackgroundColor = ConsoleColor.DarkBlue;\n\np. \n\nЗапрос данных у пользователя:\n\npre(brush: csharp).. \n// выводим на экран предложение ввести числа\nConsole.WriteLine("Введите числа через пробел:");\n\n/** \n   приостанавливаем выполнения до тех пор пока пользователь не введет \n   некоторый текст и не нажмет ENTER,\n   введенную строку сохраним в переменную strNumbers\n**/\nstrNumbers = Console.ReadLine();\n\np. \n\nНу вроде строку текста от пользователя получили, теперь не плохо бы чего-нибудь с ней сделать. Так как предполагается что пользователь ввел нам список чисел через пробел, мы разобьем пробелами нашу\nстроку на подстроки. Разбивается строка функцией **Split**. \n\npre(brush: csharp).. \n// разобьем введенную пользователем сторку пробелами на подстроки\nstrNumbersList = strNumbers.Split('' '');\n\np. \n\n<div class="note"> Все переменный типа **String** обладают функцией **Split**, в качестве результат она возвращает массив строк, полученный разбиением строки разделителем указанным в качестве параметра.\n\npre(brush: csharp).. \nsome_variable.Split('' '');\n\np. \n\nЕсли хочется использовать более одного разделителя (например пробел и запятую) придется написать уже вот-такое заклинание\n\npre(brush: csharp).. \nsome_variable.Split( new Char[]{'' '' , '',''} );\n\n// или так, указывать тип массива не обязательно, в данном случае компилятор сам догадается по содержимому\nsome_variable.Split( new []{'' '' , '',''} );\n\n// или так чтобы убрать пустые строки которые возникают, если у нас например два пробела подряд\nsome_variable.Split( new []{'' '' , '',''}, StringSplitOptions.RemoveEmptyEntries );\n\np. \n</div>\n\nИногда вам захочется сбросить цвета в консоли на те что идут по умолчанию, для этого у объекта **Console** есть метод **ResetColor**. Я сброшу цвета консоли на те унылые, что были по умолчанию и выведу сообщение о том, что я сейчас я собираюсь вывести список четных чисел:\n\npre(brush: csharp).. \n// сбрасываем цвет фона и текста на скучные >_>\nConsole.ResetColor();\n// выводим на экран сообщение; это хорошая практика всегда держать пользователя в курсе событий\nConsole.WriteLine("Среди введенных чисел, следующие числа являются четными:");\n\np. \n\nНу а теперь собственно то ради всего и затевалось, это вывод четных чисел на экран, каждое число в своей строчке. \nПерво наперво я верну свои веселые цвета:\n\npre(brush: csharp).. \n// меняем цвет текста на голубой\nConsole.ForegroundColor = ConsoleColor.Cyan;\n// меняем цвет фона на темно-синий\nConsole.BackgroundColor = ConsoleColor.DarkBlue; \n\np. \n\nНу и вторым шагом собственно сам вывод\n\npre(brush: csharp).. \n// проход по всем элементам массива strNumbersList, \n// свойство Length, очевидно, содержит количество элементов в массиве\nfor (int i = 0; i < strNumbersList.Length; ++i)\n{\n    // преобразуем подстроку в целое число\n    int num1 = int.Parse( strNumbersList[i] );  /** для доступа к i-му элементу массива\n                                                   используется операция индексации\n                                                   проще говоря чтобы узнать значение \n                                                   i-го элемента надо написать \n                                                   что-то вроде some_array[i], \n                                                  \n                                                   для 1-го элемента some_array[0]\n                                                   для 2-го элемента some_array[1]\n                                                   ...\n                                                   для последнего some_array[ some_array.Length - 1 ]\n                                                   да да нумерация с начинается с нуля!\n                                                **/\n                                                \n    // проверяем делиться ли число на 2 без остатка, то есть по сути проверка на четность\n    if (num1 % 2 == 0)\n    {\n        // если так выведем на экран это число\n        Console.WriteLine(num1);\n    }\n}\n\np. \n\n<div class="note"> В C# четыре вида циклов:\n\npre(brush: csharp).. \n// 1. Стандартный сишный цикл. Перебор i от 0 до max_value - 1\nfor ( i=0; i < max_value; i++ ) \n{\n    ...\n}\n\n// 2. Цикл для работы с массивами и коллекциями. Проходит по всем элементам коллекции.\n// Не позволяет изменять значения коллекции, только смотреть их значение.\nforeach (SomeTy\np. value in some_array) \n{\n    ...\n}\n\n// ну и условные циклы\n\n// 3. С предусловием, запуститься только если условие истинно\nwhile( %some_condition_is_true% ) \n{\n    ...\n}\n\n// 4. С постусловием, обязательно сделает один тик, и только\n// потом пойдет проверять истинность условия\ndo\n{\n    ...\n}\nwhile( %some_condition_is_true% ) \n\np. \n\nА вот цикла вида **do ... until** - нет. Ну и пусть. Мы будем использовать в основном циклы вида 1 и 2.</div>  \n\nНу и последним шагом надо дать возможность пользователю рассмотреть выведенные числа. Для этого мы приостановим программу до тех пор пока пользователь не нажмет какую-нибудь клавишу.\n\npre(brush: csharp).. \n// Иначе консоль автоматически закроется\n// и весь вывод улетит в небытие...\nConsole.ReadKey();\n\np. \n\nВот и весь код ==\\(^_^)/==\n<hr>\n\nh2. Результат работы:\n\n<div class="console">\n%{background:DarkBlue;color:Cyan}Введите числа через пробел:<br>12 123 78 3 2<br>%\nСреди введенных чисел, следующие числа являются четными:<br>\n%{background:DarkBlue;color:Cyan}12<br>78<br>2%\n</div>\n\n<hr>\n\nh2. Полный листинг:\n\npre(brush: csharp).. \nusing System;\nusing System.Linq;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            // сюда сохраним строку введенную пользователем\n            String strNumbers; \n            // это массив для подстрок входящих в строку\n            String[] strNumbersList; \n\n            Console.Title = "Я заголовок этой мрачной консоли T_T";\n\n            // меняем цвет текста на голубой\n            Console.ForegroundColor = ConsoleColor.Cyan;\n            // меняем цвет фона на темно-синий\n            Console.BackgroundColor = ConsoleColor.DarkBlue;\n\n            // выводим на экран предложение ввести числа\n            Console.WriteLine("Введите числа через пробел:");\n            // приостанавиливаем выполнения до тех пор пока пользователь не введет \n            // некоторый текст и не нажмет ENTER,\n            // введенную строку сохраним в переменную strNumbers\n            strNumbers = Console.ReadLine();\n\n            // разобьем введенную пользователем сторку пробелами на подстроки\n            strNumbersList = strNumbers.Split('' '');\n\n            // сбрасываем цвет фона и текста на те что идут по умолчанию\n            Console.ResetColor();\n            // выводим на экран сообщение\n            Console.WriteLine("Среди введенных чисел, следующие числа являются четными:");\n\n            // меняем цвет текста на голубой\n            Console.ForegroundColor = ConsoleColor.Cyan;\n            // меняем цвет фона на темно-синий\n            Console.BackgroundColor = ConsoleColor.DarkBlue; \n\n            /// перебираем все элементы массива, нумерация элементов массива начинается от 0\n            for (int i = 0; i < strNumbersList.Length; ++i)\n            {\n                // преобразуем подстроку в целое число\n                int num1 = int.Parse(strNumbersList[i]);\n                // проверяем является число делиться ли оно на 2 без остатка\n                if (num1 % 2 == 0)\n                {\n                    // если так выведем на экран это число\n                    Console.WriteLine(num1);\n                }\n            }\n            // Иначе консоль автоматически закроется\n            // и весь вывод улетит в небытие...\n            Console.ReadKey();\n        }\n    }\n}\n\np. \n\n<hr>\n\nh2. Альтернативные варианты:\n\nВообще говоря получить тот же результат можно еще как минимум 5 способами, я их на всякий пожарный оставлю здесь вдруг пригодится:\n\n<div class="note">\n\nh3. Способ #2.\n\nС использованием цикла **foreach**. Наверное самый лучший способ в подобной ситуации. Я б использовал именно его.\n\npre(brush: csharp).. \nforeach (String subString in strNumbersList)\n{\n    // преобразуем подстроку в целое число\n    int num2 = int.Parse(subString);\n    // проверяем делиться ли число на 2 без остатка\n    if (num2 % 2 == 0)\n    {\n        // если так выведем на экран это число\n        Console.WriteLine(num2);\n    }\n}\n\np. \n\nh3. Способ #3.\n\nБолее хитрый способ с использованием встроенного языка **Linq**. Главное не забыть вверху подключить пространство имен System.Linq:\n\npre(brush: csharp).. \nusing System;\nusing System.Linq; // для использования функции Select\n\n...\n\n// формируем из массива подстрок массив целых чисел,\n// для этого используется функция Select\n// ей в качестве параметра передается функция которая применяется\n// к каждому элементу массива strNumbersList.\n// ToArray() - необходимо чтобы преобразовать резульат функции Select в массив\nint[] intArray = strNumbersList.Select(int.Parse).ToArray();\nforeach (int num3 in intArray)\n{\n    // проверяем делиться ли число на 2 без остатка\n    if (num3 % 2 == 0)\n    {\n        // если так выведем на экран это число\n        Console.WriteLine(num3);\n    }\n}\n\np. \n\nh3. Способ #4.\n\nЕще более хитрый способ с использованием лямбда выражений (это та часть что "<b>x => x % 2 == 0</b>"). Оказывается за один шаг можно преобразовать массив строк в массив целых чисел и сразу же отсеять нечетные числа:\n\npre(brush: csharp).. \nint[] evenNumbers = strNumbersList.Select(int.Parse).Where(x => x % 2 == 0).ToArray();\nforeach (int num4 in evenNumbers)\n{\n        // выведем на экран число\n        Console.WriteLine(num4);\n}\n\np. \n\nh3. Способ #5.\n\nБез использования цикла. С использованием функции **Join**. Функция **Join** является обратной для \nфункции **Split** и позволяет склеить массив строк в одну строку. Между каждыми элементами массива можно указать разделитель. Оказывается строку можно вывести как несколько строк для этого надо каждую подстроку отделить от другой символом перехода на новую строку <b>"\\n"</b> (в **VBS** это была константа **VbCrLf**). Например: cтрока %(consoleIn)"Пожалуй хватит\\nна сегодня сишарпа"% в консоли будет выведена как:\n\nnotextile.. \n<div class="console">\nПожалуй хватит<br>\nна сегодня сишарпа\n</div>\n\np. \nСпособ выглядит вот так:\n\npre(brush: csharp).. \n// здесь мы одной строкой преобразовываем все подстроки к числам,\n// и среди этих чисел выбираем четные числа\nint[] evenNumbers2 = strNumbersList.Select(int.Parse).Where(x => x % 2 == 0).ToArray();\n\n// из массива целых чисел формируем массив строк\nString[] evenNumbersStr = evenNumbers2.Select(x => x.ToString()).ToArray();\n\n// склеиваем все элементы масива строк в одну большую строку outputString\n// String.Join(%разделитель строк%, %массив_строк%) возвращает объедененую строку\n// "\\n" - знак обозначает переход на новую строку\nString outputString = String.Join("\\n", evenNumbersStr);\n\n// выводи эту строку на экран\nConsole.WriteLine(outputString);\n\np. \n\nh3. Способ #6.\n\nСтоит отметить, что способ 5 умещается в одну длинную мультикоманду. Не рекомендуется к использованию, так как сильно затрудняет восприятие кода,\n\npre(brush: csharp).. \nConsole.WriteLine(String.Join("\\n",strNumbersList.Select(int.Parse).Where(x => x % 2 == 0).Select(x => x.ToString()).ToArray()));\n\np. </div>', 1, 1, 0, 26, 0, 1382553619),
(3, 'Коллекции', 'Коллекции', 'Коллекции', '', 2, 'notextile.. \nКоллекции являются своего рода динамическим массивами. Я собираюсь рассмотреть работу с коллекциями \nна примере списков (List) и словарей (Dictionary).\nСоздадим обыкновенное консольное приложение\n<pre class="brush: csharp">\nusing System; // подключим пространство имен для работы с онсновными типами и консолью\nusing System.Collections.Generic; // для работы с коллекциями\nusing System.Linq; // для использование встроенного языка Linq\n\nnamespace ConsoleApplication1\n{\n	class Program\n	{\n		static void Main(string[] args)\n		{\n            \n		}\n	}\n}\n</pre>\nОпять же весь код ниже надо будет вписать в тело функции <b>static void Main(string[] args).</b>\n<p>\nВ данном приложении я для ускорения процесса, "захардкодю" строку ввода, чтобы не вводить ее по 100 раз.\nИ хотя работать я собираюсь сегодня со списком чисел, я намерено добавлю паразитных элементов в строку.\n<pre class="brush: csharp">\n/* \n	чтобы положить чего то в строку совсем необязательно \n	запорашивать это "чего-то" от пользователя, можно явно указать строку\n*/\nString strNumbers = "123 bz 12, 53, asd 7 91 15";\n</pre>\nЧтобы разбить строку на подстроки, а тут в качестве разделителей используется не только пробелы но и запятые,\nпридется использовать усложненную версию функции <b>Split</b>\n<pre class="brush: csharp">\n// массив разделителей\nChar[] separators = new Char[] { '' '', '','' };\n\n/* \n	Создаем переменную для хранения списка строк, \n	полученных путем разбиения сторки strNumbers \n	разделителями из массива separators.\n\n	Второй параметр устанавливаем на StringSplitOptions.RemoveEmptyEntries\n	чтобы избежать появления пустых строк в массиве strNumbersArray,\n	которые возникают если два разделителя стоят рядом (например два подряд идущих пробела) \n*/\nString[] strNumbersArray = strNumbers.Split(separators, StringSplitOptions.RemoveEmptyEntries);\n</pre>\n<hr>\n<h2>Списки. Тип List<int></h2>\nТак как нашей целью является изучить возможности работы со списками, необходимо этот список создать.\nДля большинства объектов (типов) с которыми вы столкнетесь необходимо будет использование оператор new.\n<pre class="brush: csharp">\n/* \n	Данное предложение читается справа налево, т.е. \n	создать в памяти объект типа List<int> (список целых чисел),\n	и установить numbers как ссылку на этот объект\n*/\nList<int>numbers = new List<int>();\n</pre>\nТеперь этот список надо наполнить числами полученные преобразованием элементов массива <b>strNumbersArray</b> в числа.\nОчевидно что не все элементы массива <b>strNumbersArray</b> являются числами, если вывести сейчас массив <b>strNumbersArray</b> на экран \nто мы увидим примерно следующую картину:\n<div class="console">\n123<br>\nbz<br>\n12<br>\n53<br>\nasd<br>\n7<br>\n91<br>\n15<br>\n</div>\nОчевидно, что <span class="consoleIn">bz</span> и <span class="consoleIn">asd</span> не являются числами.\nДля заполнения списка числами мы будем использовать цикл <b>foreach</b> внутри которого будет вызываться функция\n<b>TryParse </b>которая позволяет проверить строку на ее возможность преобразования в число, если такая возможность\nесть то в она возвращает true и во второй параметр передает результат преобразования.\n\n<pre class="brush: csharp">\n// проходим по всем подстрокам\nforeach (Strig strNumber in strNumbersArray)\n{\n	int num;\n	/*\n		тут мы проверяем можно ли преобразовать строку в число\n		если преобразование возможно то результат преобразования\n		будет положен в переменную num, которую мы создали шагом выше\n	*/\n	if ( int.TryParse(strNumber, out num) == true )\n	{\n		numbers.Add(num);\n	}\n}\n</pre>\n\n<div class="note">\nФункция объекта <b>int</b> по имени <b>TryParse</b> представляет собой функцию возвращающая сразу два значение \n<pre class="brush: csharp">\nint.TryParse(strNumber, out num)\n</pre>\nПервое значение мы используем когда сравниваем значения функции с константой <b>true</b>\n<pre class="brush: csharp">\n// не обращаем внимание на многоточие\nif ( int.TryParse( ... ) == true )\n...\n// можно было записать это и так выделив дополнительную переменную \n// для сохранения результата функции\nbool tryParseResult = int.TryParse( ... );\nif ( tryParseResult == true )\n...\n</pre>\nЭта же функция в случае успешной конвертации возвращает еще одно значение, \nоно передается во второй параметр. Чтобы получить к нему доступ необходимо \nсоздать дополнительную переменную и передать ее в качестве второго параметра \nвместе с ключевым словом <b>out</b>:\n<pre class="brush: csharp">\n...\n// создаем переменную для хранения результата преобразования\nint num;\n// пытаемся преобразовать строку some_string в число\nif ( int.TryParse(some_string, out num) ) \n{\n	// если преобразование было успешным то выводим на экран это число	\n	Console.WriteLine(num);\n} \nelse \n{\n	// в случае неудачи сообщим что данная строка не является числом	\n	Console.WriteLine(some_string + " не является числом >_>");\n}\n</pre>\nТо есть должно быть очевидно, что если <b>some_string == "123"</b>, \nна консоле увидим:\n<div class="console">\n123\n</div>\nЕсли же <b>some_string == "фонарик"</b>, на консоле увидим:\n<div class="console">\nфонарик не является числом >_>\n</div>\n</div>\n<p>\nПосле выполнения всех этих операций список <b>numbers</b> будет содержать \nчисла, (если быть точным, то с учетом того какую строку мы задали \nв списке будут числа <b>123, 12, 53, 7, 91, 15</b>, именно в таком порядке)\n<p>\nТеперь выведем их на экран\n<pre class="brush: csharp">\n// сообщим пользователю о том что собираемся показать все числа в списке\nConsole.WriteLine("Исходный список:");\n\n// выведем список на экран\nforeach(int number in numbers) Console.Write(number + " ");\n\n/*\n	так как фукнция Console.Write в отличие от Console.WriteLine \n	не переводит курсор на новую строку, то я вызову функцию Console.WriteLine \n	чтобы такое переход осуществить собственноручно\n*/\nConsole.WriteLine();\n</pre>\nУпорядочивание элементов в C# -- милое дело, все делается в одну-две команды\n<h4>Сортировка по возрастанию</h4>\n<pre class="brush: csharp">\n// функция Sort сортирует элементы списка в порядке возрастания\nnumbers.Sort();\n\n// вывод на экран\nConsole.WriteLine("Упорядоченный по возрастанию:");\nforeach(int number in numbers) Console.Write(number + " ");\nConsole.WriteLine();\n</pre>\n\n<h4>Сортировка по убыванию</h4>\n<pre class="brush: csharp">\n// сначала отсортируем по возрастанию \nnumbers.Sort();\n// а потом развернем список \n// вообще не самый эффективный способ, \n// но вполне пригодный для небольших списков\nnumbers.Reverse();\n\n// вывод на экран\nConsole.WriteLine("Упорядоченный по возрастанию:");\nforeach(int number in numbers) Console.Write(number + " ");\nConsole.WriteLine();\n</pre>\n<div class="note">\nБолее эффективным способом упорядочения списка по убыванию, заключается в явном указании функции сортировки:\n<pre class="brush: csharp">\nnumbers.Sort( (num1, num2) => num2.CompareTo(num1) );\n</pre>\nЗдесь используется лямбда-выражение, которым реализуется функция от двух параметров \nвозвращающая<br>\n<b>-1</b> если <b>num1 > num2</b>,<br>\n<b>1</b> если <b>num1 < num2</b><br> \n<b>0</b> если они совпадают.\n</div>\n<h4>Количество элементов в списке</h4>\n<pre class="brush: csharp">\nConsole.Write"Количество элементов в списке: ");\n// используем свойстве списка count\nConsole.WriteLine(numbers.count);\n</pre>\n\n<h4>Минимальный элемент</h4>\n<pre class="brush: csharp">\n/*\n	в отличие от количества элементов, под минимальный элемент\n	лучше создать переменную, так как при каждом вызове функции Min\n	этот элемент ищется заново\n*/\nint minimum = numbers.Min();\n\nConsole.Write("Минимальный элемент: ");\nConsole.WriteLine(minimum);\n</pre>\n\n<h4>Максимальный элемент</h4>\n<pre class="brush: csharp">\n/*\n	и под максимальный элемент лучше создать переменную, \n	так как при каждом вызове функции Max\n	этот элемент также ищется заново.\n*/\nint maximum = numbers.Max();\n\nConsole.Write("Максимальный элемент: ");\nConsole.WriteLine(maximum);\n</pre>\n<hr>\n<h2>Словари. Тип Dictionary<String, String></h2>\nСловари позволяют нам хранить пары вида (ключ, значение). Наилучшим примером объекта типа словарь,\nявляется, как бы это странно это не звучало, обычный словарь. Например русско-английский. Я продемонстрирую\nкак сделать словарь который будет переводить предложения не хуже печально известного Промта. \n<p>\nКак и любой объект сложнее <b>int</b> (ну или <b>String</b>, <b>float</b>, <b>long</b> и т.п.), словарь надо создавать с помощью оператора <b>new</b>:\n<pre class="brush: csharp">\nDictionary<String, String> dictionary = new Dictionary<string, string>();\n/*\n	не обязательно указывать тип явно можно написать и так\n	var dictionary = new Dictionary<string, string>();\n*/\n</pre>\n\nТеперь добавим несколько слов в наш словарь\n<pre class="brush: csharp">\n// первый параметр функции Add это ключ, второй - значение\ndictionary.Add("яблоко", "apple");\ndictionary.Add("мороженое", "icecream");\ndictionary.Add("чай", "tea");\n</pre>\nВыводим содержимое словаря на экран\n<pre class="brush: csharp">\nforeach (var pair in dictionary)\n{\n	/*\n	  Тут мы используем форматирование выводимого текста\n	  {0} - будет заменено на второй параметр функции WriteLine (т.е на значение pair.Key)\n	  {1} - будет заменено на третий параметр функции WriteLine (т.е на значение pair.Value)\n	  \n	  Аналогично можно добавить {2} - если у нас вдруг появиться какой-то третий параметр \n	*/	\n	Console.WriteLine("{0} по-английски {1}", pair.Key, pair.Value);\n}\n</pre>\nДобавим следующее приложение:\n<pre class="brush: csharp">\nString sentence = "Я пожалуй возьму яблоко, мороженое и чай";\n</pre>\nИ воспользуемся нашим словарем для перевода (так как в нашем словаре только три слова,\nследовательно и перевести мы сможем  только три слова, ну для начала и так не плохо :D \n<pre class="brush: csharp">\n// сначала покажем исходное предложение\nConsole.WriteLine(sentence);\n\n/*\n	собственно тут и осуществляется перевод,\n	для упрощения, я вместо того чтобы искать \n	слова из текста в словаре, будут искать \n	слова из словаря в тексте. \n	\n	Нелогично, зато код во много раз проще,\n	иначе бы мне пришлось разбивать текст \n	на слова, искать каждое слово в словаре,\n	а потом еще эти слова уже склеивать обратно\n	в предложение, что, вообще говоря, является\n	нетривиальной задачей.\n*/\n\nforeach (var wordPair in dictionary)\n{\n	/*\n	  Функция Replace ищет в строке для которой она вызывается\n	  значение первого параметра и заменяет его значением второго параметра.\n	  \n	  В качестве результата  возвращает новую строку которая является\n	  преобразованным предложением.\n	  \n	  Тут мы присваиваем значение функции самой строке, чтобы на следующей\n	  итерации цикла уже использовалось новое предложение \n	  в котором часть слов уже переведена\n	*/	 \n	 sentence = sentence.Replace(wordPair.Key, wordPair.Value);\n}\n\n// вывод на экран переведенного предложения\nConsole.WriteLine(sentence);\n</pre>\nНу и последним шагов приостанавливаем работу программы в ожидании нажатия любой клавиши\nпользователем, иначе консолька автоматически закроется.\n<pre class="brush: csharp">\n// ожидаем нажатия любой клавиши пользователем\nConsole.ReadKey();\n</pre>\n\n<hr>\n<h2>Результат работы:</h2>\n<div class ="console">\nИсходный список:<br>\n123 12 53 7 91 15<br>\nУпорядоченный по возрастанию:<br>\n7 12 15 53 91 123 <br>\nУпорядоченный по убыванию:<br>\n123 91 53 15 12 7 <br>\nКоличество элементов: 6<br>\nМинимальный элемент: 7<br>\nМаксимальный элемент: 123<br>\nмороженое по-английски icecream<br>\nчай по-английски tea<br>\nяблоко по-английски apple<br>\nЯ пожалуй возьму яблоко, мороженое и чай<br>\nЯ пожалуй возьму apple, icecream и tea<br>\n_\n</div>\n<hr>\n<h2>Полный листинг:</h2>\n<pre class="brush: csharp">\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        // чтобы положить чего то в строку совсем необязательно \n        // заправшивать чего-то от пользователя, можно явно указать строку\n        String strNumbers = "123 bz 12, 53, asd 7 91 15";\n\n        // разбиваем строку запятыми и пробелами, и убираем за одно пустые строки\n        Char[] separators = new Char[] { '' '', '','' };\n        String[] strNumbersArray = strNumbers.Split(separators, StringSplitOptions.RemoveEmptyEntries);\n\n        List<int> numbers = new List<int>(); // создаем динамический список\n\n        // проходим по всем подстрокам\n        foreach (String strNumber in strNumbersArray)\n        {\n            int num;\n            // тут мы проверяем можно ли преобразовать строку в число\n            if (int.TryParse(strNumber, out num))\n            {\n                numbers.Add(num);\n            }\n        }\n\n        Console.WriteLine("Исходный список:");\n        foreach(int number in numbers) Console.Write(number + " ");\n        Console.WriteLine();\n\n        // функция Sort сортирует элменты массива в порядке возрастания\n        numbers.Sort();\n        \n        Console.WriteLine("Упорядоченный по возрастанию:");\n        foreach(int number in numbers) Console.Write(number + " ");\n        // чтобы не слипалось со следующем выводом\n        Console.WriteLine();\n\n        // упорядочим список по убыванию\n        numbers.Sort();\n        numbers.Reverse();\n        \n        Console.WriteLine("Упорядоченный по убыванию:");\n        foreach(int number in numbers) Console.Write(number + " ");\n        Console.WriteLine();\n\n		  Console.Write("Количество элементов: ");\n        Console.WriteLine(numbers.Count);\n\n        int minimum = numbers.Min();\n        Console.Write("Минимальный элемент: ");\n        Console.WriteLine(minimum);\n\n        int maximum = numbers.Max();\n        Console.Write("Максимальный элемент: ");\n        Console.WriteLine(maximum);\n\n        Dictionary<String, String> dictionary = new Dictionary<string, string>();\n        dictionary.Add("яблоко", "apple");\n        dictionary.Add("мороженое", "icecream");\n        dictionary.Add("чай", "tea");\n\n        dictionary = dictionary.OrderBy(pair => pair.Key).ToDictionary(pair => pair.Key, pair => pair.Value);\n\n        foreach (var pair in dictionary)\n        {\n            Console.WriteLine("{0} по-английски {1}", pair.Key, pair.Value);\n        }\n\n\n        String sentence = "Я пожалуй возьму яблоко, мороженое и чай";\n\n        Console.WriteLine(sentence);\n        foreach (var wordPair in dictionary)\n        {\n            sentence = sentence.Replace(wordPair.Key, wordPair.Value);\n        }\n        Console.WriteLine(sentence);\n		\n\n        Console.ReadKey();\n    }\n}\n</pre>', 1, 2, 0, 18, 0, 1382525639);
INSERT INTO `articles` (`id_`, `title`, `title_menu`, `title_page`, `description`, `category_id`, `text`, `enabled`, `ord`, `top`, `visits`, `date_create`, `date_update`) VALUES
(4, 'Работа с файлами', 'Работа с файлами', 'Работа с файлами', '', 2, 'notextile.. \nВ качестве файла для экспериментов я возьму текст книги <a href="files/%D0%90%D0%BB%D0%B8%D1%81%D0%B0%20%D0%B2%20%D0%97%D0%B0%D0%B7%D0%B5%D1%80%D0%BA%D0%B0%D0%BB%D1%8C%D0%B5.txt">"Алиса в Зазеркалье"</a>, вы можете\nиспользовать этот файл либо какой-нибудь свой, главное чтобы это был простой текст (<b>*.txt</b>).\n<p>\nСоздадим простое консольное приложение:\n<pre class="brush: csharp">\nusing System; 		 // базовые типы\nusing System.Text; // для работы с кодировками\nusing System.IO;	 // для работы с фалами\nusing System.Collections.Generic; // для работы с коллекциями\nusing System.Linq; // \nдля использования конструкций языка Linq\n\nnamespace ConsoleApplication1\n{\n	class MainClass\n	{\n		public static void Main (string[] args)\n		{\n		}\n	}\n}\n</pre>\nВозможны вы уже обратили внимание что у функции <b>public static void Main (string[] args)</b>. \nПрисутствует параметр <b>string[] args</b>. Это так называемые аргументы командной строки, их используют\nдля того чтобы контролировать поведение консольных приложений. Их количество и вид определяет разработчик программы.\nНапример команду <b>copy</b> консольной оболочки Windows (чтобы запустить консоль нажмите <b>Win+R</b>, введите <b>cmd</b> и нажмите <b>ENTER</b>) , можно вызвать следующим образом:\n<div class="console">\ncopy somefile.txt d:\\Texts\n</div>\nПрограмме <b>copy</b> передается два аргумента (аргументы отделяются друг от друга пробелами, если параметр может содержать пробелы его надо заключить в кавычки, например: <b>copy "Some file with spaces in name.txt" d:\\Texts</b> ):<br>\n<b>somefile.txt</b> — файл для копирования <br>\n<b>d:\\Texts</b> — папка назначения, туда куда скопируется файл <br>\nЕсли бы мы были разработчиками программы <b>copy</b>, то мы могли бы обратиться к этим аргументам через параметр <b>string[] args</b>.<br>\n<ul>\n<li><b>args</b> — это массив строк</li>\n<li><b>args[0]</b> — хранит первый аргумент переданный в командную строку \n(т.е. для данного примера он содержал <b>"somefile.txt"</b>)</li>\n<li><b>args[1]</b> — хранит второй аргумент переданный в командную строку \n(т.е. для данного примера он содержал <b>"d:\\Texts"</b>)</li>\n<li>и т.д.</li>\n</ul>\n<p>\nВ нашем приложении мы тоже будем использовать два параметра: для указания файла с текстом \nи для папки куда мы будем сохранять результаты обработки текста. Но мы же не собираемся запускать \nпрограмму из консоли, мы просто тыкаем <b>F5</b> и все делается на автомате. Чтобы передать параметры\nприложению необходимо сделать небольшие манипуляции.\n<br>Открыть свойства проекта:\n<img src="images/project_properties.png" />\nВыбрать вкладку Debug (отладка):\n<img src="images/project_properties_debug.png" />\nИ прописать туда параметры через пробел, как видите так как путь к книге "Алиса в Зазеркалье" содержит\nпробелы я заключаю его в двойные кавычки.\n<p>\nМожно закрыть вкладку свойств и перейти к написанию кода, как обычно весь код помещаем \nв тело функции <b>public static void Main (string[] args)</b>\n<p>\nСоздадим две переменные для хранения первого и второго аргумента (вообще говоря это необязательно,\nмы могли бы просто использовать <b>args[0]</b> и <b>args[1]</b>, но они имена не несут никакой смысловой\nнагрузке, и через неделю другую вам будет достаточно тяжело вспомнить для чего и какой аргумент использовался.\n<pre class="brush: csharp">\nString inputFile = args [0]; // файл с текстом\nString outputDir = args [1]; // папка куда будем сохранять файл\n</pre>\nТеперь сделаем небольшую проверку, вдруг пользователь подсунет нам файл которого\nне существует или и вовсе какую ерунду. Для этого воспользуемся методом <b>Exists</b> класса <b>File</b>, \nкоторый возвращает <b>true</b> если файл существует и <b>false</b> в обратном случае. \n<pre class="brush: csharp">\n// если файл не существует\nif ( !File.Exists (inputFile) ) {\n\n	// сообщить об этом пользователю\n	Console.WriteLine("файла \\"" + inputFile + "\\" не существует!");\n	\n	// дать возможность прочитать сообщение	\n	Console.ReadKey();\n	\n	// завершить программу\n	return;\n}\n</pre>\n<div class="note">\nВозможно вы обратили внимание что мы используем <b>\\</b> для того что выводить кавычки. \n<pre class="brush: csharp">\n... \nConsole.WriteLine("файла \\"" + inputFile + "\\" не существует!");\n...\n</pre>\nСвязанно это с тем, что кавычки являются зарезервированным символом поэтому чтобы вывести сроку содержащую\nкавычки необходимо кавычки в ней "экранировать" с помощью обратного слеша. Таким образом, чтобы создать строку содержащую\nнеобходимо \nделать так:\n<pre class="brush: csharp">\nString some_string = "\\""; // с одним символом двойных кавычек\n...\nString another_string = "\\"\\"";// с двумя символами двойных кавычек\n...\nString other_string = "\\\\"; // с обратным слешом\n...\nString freak_string = "\\\\\\"\\\\"; // с символом двойных кавычек, между двумя обратными слэшами \n</pre>\nПоследняя строка уж совсем страшная.<br>\n<b>C#</b> предлагает нам альтернативный способ задания строк\nсодержащих много экранированных символов. С использованием символа <b>@</b> (at - по-английски). \nС помощью <b>@</b> последняя строка может быть записана как\n<pre class="brush: csharp">\nString freak_string = @"\\""\\"; \n/*\n  кавычки все равно приходится экранировать, повторяя их два раза\n    \n  два раза повторенная двойная кавычка \n  будет выведена как один символ двойной кавычки\n*/\n</pre>\nВ основном символ используют для задания путей в <b>Windows</b> (в <b>UNIX</b> подобных системах, в путях используется прямой слэш\nи таких проблем там не возникает):\n<pre class="brush: csharp">\n// без @:\nString path1 = "C:\\\\somedir\\\\anotherdir\\\\somefile.jpeg";\n\n// с использованием @:\nString path2 = @"C:\\somedir\\anotherdir\\somefile.jpeg";\n\n// вывести строки на экран\nConsole.WriteLine(path1);\nConsole.WriteLine(path2);\n</pre>\nВыведутся на консоль обе строки абсолютно одинаково.\n<div class="console">\nC:\\somedir\\anotherdir\\somefile.jpeg<br>\nC:\\somedir\\anotherdir\\somefile.jpeg\n</div>\n</div>\n<p>\nТеперь считаем содержимое файла в и сохраним в строку\n<pre class="brush: csharp">\n/*\n	Кодировки это большая головная боль\n	если у вас вместо букв вылезут вопросики\n	попробуйте в качестве второго параметра \n	один из следующих вариантов:\n	\n	Encoding.GetEncoding (1251)\n	Encoding.Default;\n	Encoding.UTF8\n*/\nString fullText = File.ReadAllText (inputFile, Encoding.GetEncoding (1251));\n/*\n	выведем текст на экран,\n	кстати если текст достаточно большой\n	то в консоль он весь не влезет (даже с учетом прокрутки)\n*/\nConsole.Write(fullText);\n</pre>\nЯ хочу провести частотный анализ появления слов в тексте, для этого мне надо\nпрежде всего текст разбить на слова. Я воспользуюсь уже знакомой с прошлых уроков функцией\n<b>Split</b>, а в качестве разделителей выберу следующие символы:\n<pre class="brush: csharp">\n/*\n	этот далеко не полный список разделителей, но и такой пойдет\n	обратите внимание на два последних символа,\n	''\\n'' - символ перехода на новую строку\n	''\\r'' - символ возврата каретки\n	эти символы не являются печатными, \n	но тем не менее в тексте присутствуют.\n*/\nChar[] separators = {'' '', '','', ''.'', ''-'', ''!'', ''?'', ''\\"'', ''\\n'', ''\\r'' };\n</pre>\nСформируем список слов:\n<pre class="brush: csharp">\nString[] wordsArray = fullText.Split (separators, StringSplitOptions.RemoveEmptyEntries);\n</pre>\nТеперь я хочу создать новый список состоящий из пар: слово + кол-во появлений слова в тексте.\nДля этого как нельзя лучше подходят класс <b>Dictionary</b>. \nВ прошлом уроке я использовал словарь типа <b>Dictionary<String, String></b>. \n<p>Сегодня я буду использовать словарь вида <b>Dictionary<String, int></b>. Создам его:\n<pre class="brush: csharp">\n/*\n	мне лень явно указывать тип переменной\n	к тому же он вполне очевиден из правой части \n*/\nvar dictWords = new Dictionary<String, int> ();\n</pre> \nА теперь мне надо заполнить этот словарь элементами. Для этого я организую цикл по всем словам из списка слов текста:\n<pre class="brush: csharp">\n// для каждого слова из списка слов\nforeach (var word in wordsArray) \n{\n	// если словарь не содержит слово	\n	if (!dictWords.ContainsKey (word)) \n	{\n		/*\n			добавляем слово в качестве ключа в словарь,\n			его значение устанавливаем единичкой,\n			что означает — слово один раз в тексте встречалось,\n			таки так оно \nи есть\n		*/		\n		dictWords.Add (word, 1);\n	} \n	else  // а если встречалось\n	{\n		/*\n			в таком случае добавлять слово с словарь не надо\n			но надо увеличить значение для слова на 1 \n		*/\n		dictWords [word] += 1;\n	}\n}\n</pre>\n<div class="note">\nВ таком виде программа различает слова начинающиеся с большой и маленькой буквы, т.е. <b>алиса</b> и <b>Алиса</b> будут восприняты как два разных слова, вообще говоря такое поведение не логично, чтобы поправить ситуацию можно например переписать так:\n<pre class="brush: csharp">\nforeach (var word in wordsArray) \n{\n	/*\n		введем дополнительную переменную, которая все слова будет переводить\n		в нижний регистр и уже для этого слова мы будем решать\n		добавлять его в словарь или изменять его значение\n	*/  	\n	String lowerWord = word.ToLower(); 	\n	\n	// если словарь не содержит слово	\n	if (!dictWords.ContainsKey (lowerWord)) \n	{\n		/*\n			добавляем слово в качестве ключа в словарь,\n			его значение устанавливаем единичкой,\n			что означает — слово один раз в тексте встречалось,\n			таки так оно и есть\n		*/		\n		dictWords.Add (lowerWord, 1);\n	} \n	else  // а если встречалось\n	{\n		/*\n			в таком случае добавлять слово с словарь не надо\n			но надо увеличить значение для слова на 1 \n		*/\n		dictWords [lowerWord] += 1;\n	}\n}\n</pre>\n</div>\nНу а теперь самое интересное, мы могли бы вывести на экран какое слово сколько раз\nвстречалось, но вместо этого, мы будем производить вывод в файл. Для этого создадим объект\n<b>StreamWriter</b> который позволяет производить операции записи над файлом указанном\nв качестве параметра при его инициализации. \n<pre class="brush: csharp">\nStreamWriter writer = new  StreamWriter(outputDir + @"\\words.txt");\n</pre>\nА теперь запишем информацию о нашем анализе в текстовый файл:\n<pre class="brush: csharp">\n/*\n	Я воспользуюсь возможностью упорядочения на лету\n	с помощью функции OrderBy, \n	и укажу что хочу упорядочить по значению\n*/\nforeach (var pair in dictWords.OrderBy( x => x.Value ) ) \n{\n	/*\n		Напоминаю что "{0,-14}: {1}" — это шаблон форматирования строки\n		сам шаблон означает вывести первый аргумент, если строковое значение\n		первого аргумента длиной меньше 14 символов добавить к нему справа пробелов \n		чтобы она равнялась 14 (если б стояло просто 14, то обозначало бы добавить слева), \n		\n		нарисовать двоеточие, \n		вывести второй аргумент\n		\n		все данные записываются в файл\n	*/	\n	writer.WriteLine("{0,-14}: {1}", pair.Key, pair.Value);\n}\n\n// так как мы больше ничего не собираемся делать с этим файлом, его необходимо закрыть\nwriter.Close();\n</pre>\nМожно открыть файл и полюбоваться результатом. Вот несколько строчек из моего файла:\n<div class="console">\nКоролева      : 168<br>\nа             : 170<br>\nто            : 170<br>\nтак           : 178<br>\nИ             : 185<br>\nА             : 189<br>\nон            : 219<br>\nэто           : 219<br>\nя             : 243<br>\nкак           : 291<br>\nс             : 304<br>\nона           : 327<br>\nАлиса         : 488<br>\nчто           : 492<br>\nна            : 516<br>\nне            : 654<br>\nв             : 692<br>\nи             : 936\n</div>\nЕсли уже забыли, то в первой колонке у нас слова, а в правой то сколько раз они встретились в тексте. \n<p>Теперь попробуем сделать частотный анализ букв, в отличие от слов, для этого разбивать текст не надо, достаточно использовать исходный текст, мы можем обращаться к символом текста через операцию индексации. Но сначала создадим новый словарь. В качестве ключа будем использовать букву, а в качестве значения, то сколько раз она встречалась в тексте.\n<pre class="brush: csharp">\nvar dictChars = new Dictionary<Char, int>();\n</pre>\nТеперь организуем цикл по всем символам текста:\n<pre class="brush: csharp">\n// проходим по всем символам в тексте \nforeach (Char ch in fullText) {\n	/*\n		нас интересует лишь частотный анализ букв\n		поэтому мы использую статический метод IsLetter\n		класса Char, проверяем является ли символ буквой\n	*/ \n	if ( Char.IsLetter(ch) ) \n	{\n		// если такой буквы нет в словаре		\n		if ( !dictChars.ContainsKey (ch) ) \n		{\n			// добавляем ее в словарь, устанавливаем ее значение на 1\n			dictChars.Add (ch, 1);			\n		} \n		else  // а если есть\n		{\n			// увеличиваем значение буквы на один			\n			dictChars [ch] += 1;\n		}\n	}\n}\n</pre>\nПосле выполнения этого цикла наш словарь будет содержать информацию о том сколько раз\nкаждая буква встречалась в тексте.\n<p>Теперь рассмотрим альтернативный способ записи текста в файл.\nФункция <b>WriteAllText</b> класса <b>File</b>, позволяет записать строку в файл, за\nодин шаг, главное чтобы строка к этому моменту была сформирована. Формировать строку очень \nудобно с помощью объекта <b>StringBuilder</b>.\n<pre class="brush: csharp">\n// создадим объект для формирования строк\nStringBuilder outString = new StringBuilder ();\n/*\n  для каждой пары: буква - кол-во появлений в тексте\n  как и в предыдущем примере я упорядочиваю на лету по значению\n*/\nforeach (var pair in dictChars.OrderBy( x => x.Value ) ) \n{\n	// рассчитываем долю появления буквы к количеству символов в тексте \n	// это число очевидно меньше единицы 	\n	double freq = (double) pair.Value / fullText.Length;\n\n	/* \n		добавляю строку\n		{0,-3} - выделить три символа с выравниванием влево под символ буквы \n		{1:0.000%} - вывести долю в процентах, с точностью до третьего знака после запятой\n	*/ \n	outString.AppendFormat("{0,-3}: {1:0.000%}", pair.Key, freq);\n	\n	// добавить символ перехода на новую строку\n	outString.AppendLine();\n}\n</pre>\n<div class="note">\nСтоит отметить что тут (<b>double freq = (double) pair.Value / fullText.Length</b>) \nмы сравниваем частоту появления буквы относительно количества символов в тексте\n(не только букв, но и знаков препинания, пробелов, цифр и т.д.), более правильно было бы\nвместо <b>fullText.Length</b>, ввести дополнительную переменную хранящую кол-во букв в тексте\n<pre class="brush: csharp">\n/*\n	Тут мы используем Linq-функцию Count которая возвращает кол-во элементов в массиве,\n	для которых функция, указанная в качестве параметра, возвращает true\n*/\nint lettersCount = fullText.Count(Char.IsLetter);\n/*\n	равносильная запись \n	int lettersCount = fullText.Count( ch => Char.IsLetter(ch));\n*/\n</pre>\nНу и заменить пересчет доли\n<pre class="brush: csharp">\n...\ndouble freq = (double) pair.Value / lettersCount;\n...\n</pre>\n</div>\n<p>\nНу а теперь мы эту строку сформированную объектом <b>outString</b> типа <b>StringBuilder</b> сохраним в файл:\n<pre class="brush: csharp">\n/*\n	Так как StringBuilder не является строкой,\n \n	а является чем то вроде контейнера для хранения строки\n	строку надо извлечь с помощью метода ToString(), \n	\n	кстати методом ToString() обладают абсолютно все объекты в C#	\n*/\nFile.WriteAllText(outputDir + @"\\chars.txt" ,outString.ToString());\n</pre>\nВот несколько строк из моего файла:\n<div class="console">\nь  : 1.503%<br>\nп  : 1.814%<br>\nу  : 1.967%<br>\nд  : 1.982%<br>\nм  : 2.101%<br>\nк  : 2.497%<br>\nв  : 2.823%<br>\nр  : 3.268%<br>\nс  : 3.901%<br>\nл  : 4.145%<br>\nн  : 4.286%<br>\nт  : 4.379%<br>\nи  : 4.496%<br>\nе  : 5.931%<br>\nа  : 6.579%<br>\nо  : 8.126%<br>\n</div>\n для интереса слазайте <a href="http://ru.wikipedia.org/wiki/%D0%A7%D0%B0%D1%81%D1%82%D0%BE%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C" target="_blank">сюда</a> и сравните порядок букв с тем что в вашем файле\n(напомню что буквы я упорядочил по частоте появления в тексте)\nНу напоследок откроем созданные файлы программно, мы конечно могли бы\nдойти до папки и в ручную открыть их, но ведь нам лень .__.\n<pre class="brush: csharp">\n// открываем первый файл\nSystem.Diagnostics.Process.Start(outputDir + @"/chars.txt");\n// открываем второй файл\nSystem.Diagnostics.Process.Start(outputDir + @"/words.txt");\n</pre>\nЕсли в качестве стандартного приложения для работы с *.txt файлами у вас стоит блокнот,\nто у вас должно открыться два блокнота.\n<div class="note">\nкстати <b>System.Diagnostics.Process</b> на самом деле просто класс <b>Process</b> для управления процессами операционной системы, если б мы подключили вверху программы пространство имен <b>System.Diagnostics</b>, можно было написать и так:\n<pre class="brush: csharp">\n...\nusing System.Diagnostics;\n...\n\n// открываем первый файл\nProcess.Start(outputDir + @"/chars.txt");\n// открываем второй файл\nProcess.Start(outputDir + @"/words.txt");\n</pre>\n</div>\n<p>\nНу и напоследок дадим рассмотреть пользователю чего у нас на консоль выведено:\n<pre class="brush: csharp">\n// приостановка, в ожидании нажатия пользователем любой клавиши\nConsole.ReadKey();\n</pre>\n<hr>\n<h2>Полный листинг:</h2>\n<pre class="brush: csharp">\nusing System;\nusing System.Text;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ConsoleApplication1\n{\n	class MainClass\n	{\n		public static void Main (string[] args)\n		{\n			String inputFile = args [0];\n			String outputDir = args [1];\n\n			if (!File.Exists (inputFile)) \n			{\n				Console.WriteLine ("файла \\"" + inputFile + "\\" не существует!");\n				Console.ReadKey ();\n				return;\n			}\n\n			String fullText = File.ReadAllText (inputFile, Encoding.GetEncoding (1251));\n			Console.WriteLine (fullText);\n\n			Char[] separators = {'' '', '','', ''.'', ''-'', ''\\n'', ''!'', ''?'', ''\\"'', ''\\r'' };\n			String[] wordsArray = fullText.Split (separators, StringSplitOptions.RemoveEmptyEntries);\n\n			var dictWords = new Dictionary<string, int> ();\n			foreach (var word in wordsArray) \n			{\n				if (!dictWords.ContainsKey (word)) \n				{\n					dictWords.Add (word, 1);\n				} \n				else \n				{\n					dictWords [word] += 1;\n				}\n			}\n\n			StreamWriter writer = new  StreamWriter (outputDir + @"\\words.txt");\n\n			foreach (var pair in dictWords.OrderBy( x => x.Value )) \n			{\n				writer.WriteLine ("{0,-14}: {1}", pair.Key, pair.Value);\n			}\n			writer.Close ();\n\n			var dictChars = new Dictionary<Char, int> ();\n			foreach (Char ch in fullText) \n			{\n				if (Char.IsLetter (ch)) \n				{\n				\n	if (dictChars.ContainsKey (ch)) \n					{\n						dictChars [ch] += 1;\n					} \n					else \n					{\n						dictChars.Add (ch, 1);\n					}\n				}\n			}\n\n			StringBuilder outString = new StringBuilder ();\n			foreach (var pair in dictChars.OrderBy( x => x.Value ) ) \n			{\n				double freq = (double) pair.Value / fullText.Length;\n				outString.AppendFormat("{0,-3}: {1:0.000%}", pair.Key, freq);\n				outString.AppendLine();\n			}\n			File.WriteAllText(outputDir + @"\\chars.txt" ,outString.ToString());\n\n			System.Diagnostics.Process.Start(outputDir + @"\\chars.txt");\n			System.Diagnostics.Process.Start(outputDir + @"\\words.txt");\n\n			Console.ReadKey();\n		}\n	}\n}\n</pre>', 1, 3, 0, 30, 0, 1382525653);
INSERT INTO `articles` (`id_`, `title`, `title_menu`, `title_page`, `description`, `category_id`, `text`, `enabled`, `ord`, `top`, `visits`, `date_create`, `date_update`) VALUES
(5, 'Формы', 'Формы', 'Формы', '', 2, '\nnotextile.. \nСоздадим <b>Windows Form Application</b>. Для этого выбираем <b>Файл / Создать / Проект</b>,\nи в качестве шаблона указываем <b>Приложение Windows Forms</b>.\nВ реультате увидим примерно следующую картинку:\n<img src="images/csharp-04-01.png" />\nЕсли у вас вдруг отсутствует левая (<b>панель элементов (toolbox)</b>) или правая панелька (<b>свойства (properties)</b>),\nих можно включить через меню <b>Вид (view)</b>\n<p>\nДобавим на форму пару элементов, пока нам хватит <b>Button</b> и <b>RichTextBox</b>. Чтобы добавить компонент его надо\nперетянуть с панели инструментов на форму. Должно получиться что-то в этом роде:\n<img src="images/csharp-04-02.png">\nВыделим кнопку (кликнув на нее один раз), и поменяем ее имя (свойство <b>Name</b>) на <b>btnShowText</b>, \nи надпись на кнопке (свойство <b>Text</b>) на <b>Показать текст</b> \n<img src="images/csharp-04-03.png">\n<div class="note">\nКаждый объект на форме, включаю саму форму, обладает набором свойств, изменяя которые можно изменять\nповедение и вид объекта. Самое простое, но в тоже время самое важное свойства - это свойство <b>Name</b>. \nС помощью него мы обращаемся к объекту. То есть если кнопка имеет имя <b>RedButton</b>, то для\nтого чтобы программно нажать на эту кнопку надо будет написать\n<pre class="brush: csharp">\nRedButton.Click();\n</pre>\nА если нам вдруг захочется узнать какая надпись на кнопке, и присвоить это значение какой-нибудь переменной мы напишем\n<pre class="brush: csharp">\nstring labeltext = RedButton.Text;\n</pre>\n</div>\n<p>\nВыделим объект типа <b>RichTextBox</b> и поменяем его имя на <b>txtMain</b>.<br>\n<b>RichTextBox</b> позволяет отображать форматированный текст и редактировать его. \nЕсли сейчас запустить приложение (<b>F5</b>), то можно написать чего нибудь в текстовом поле,\nможно понажимать на кнопку, правда все это пока не принесет ни какой пользы. \n<p>\nЕсли приложение запущенно, то закроем его и вернемся к редактированию формы. Щелкнем два раза на\nнашу кнопку <b>btnShowText</b>. По идее мы должны оказаться в режиме редактирования кода. Увидим мы примерно следующее:\n\n<pre class="brush: csharp">\n/*\n	В отличие от консольных приложений здесь уже намного \n	больше компонентов подключено по умолчанию.\n	Часть из них предназначена для работы с объектами на форме\n*/\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Data;\nusing System.Drawing;\nusing System.Linq;\nusing System.Text;\nusing System.Windows.Forms;\n\nnamespace WindowsFormsApplication1\n{ \n    /*\n    	Создавая форму, мы формируем новый объект формы на\n    	базе самой простой, на что и указывает \n    	...  class Form1 : Form ...\n    	\n    	Часто класс формы содержит очень много функций\n    	слово partial, позволяет разбивать код для класса\n    	на несколько подфайлов \n    */  \n    public partial class Form1 : Form\n    {\n        // это конструктор формы, он вызывается всего один раз\n        // когда форма создается в памяти впервые        \n        public Form1()\n        {\n            /*\n            	на самом деле данный файл содержит не весь код формы\n   \n         	часть кода содержится в файле Form1.Designer.cs\n            	метод InitializeComponent описан в том файле, \n            	и код в нем генерируется автоматически\n            	в соответствии с тем какие объекты вы добавляете на форму,\n            	и как меняете их свойства\n            */\n            InitializeComponent();\n        }\n        \n        \n        /*\n        	эта функция возникла автоматически когда мы два раза щелкнули\n        	на кнопку btnShowText, в нем мы пропишем код \n        	который будет запускаться каждый раз \n        	когда во время исполнения программы \n        	на кнопку будут нажимать\n        */  \n        private void btnShowText_Click(object sender, EventArgs e)\n        {\n\n        }\n    }\n}\n</pre>\nНаша кнопка будет показывать текстовое сообщение, в котором будет содержаться текст\nиз <b>txtMain</b>. Для этого <b>.Net</b> предлагает нам класс <b>MessageBox</b>.\n<pre class="brush: csharp">\n...\nprivate void btnShowText_Click(object sender, EventArgs e)\n{\n	// сохраним содержимое текстового поля\n	// в переменную	\n	String textFromTxtMain = txtMain.Text;\n	\n	// покажем значение переменной в окне MessageBox\n	MessageBox.Show(textFromTxtMain);\n}\n...\n</pre>\nЕстественно, чтобы в окне что-то было, это что-то надо ввести в текстовое поле.\nНо каждый раз вводить лень, так что вернемся в режим редактирования формы, и изменим значение\nсвойства <b>Text</b> объекта <b>txtMain</b> например на следующий текст:\n<div class="text">\n Шалтай-Болтай взял книжку и уставился в нее.<br>\n - Кажется, здесь нет ошиб... - начал он.<br>\n - Вы ее держите вверх ногами, - прервала его Алиса.<br>\n - Ну, конечно, - весело заметил Шалтай-Болтай и взял перевернутую Алисой книжку. - То-то я смотрю, как странно все это выглядит! Поэтому я и сказал: "_Кажется_, здесь нет ошибки!", - хоть я и не успел разобраться как следует... Значит, так: триста шестьдесят четыре дня в году ты можешь получать подарки на день нерожденья.<br>\n - Совершенно верно, - сказала Алиса.<br>\n - И только _один_ раз на день рожденья! Вот тебе и слава!<br>\n - Я не понимаю, при чем здесь "слава"? - спросила Алиса.\n</div>\nЧтобы ввести этот текст, его можно скопировать и нажать на стрелочку справа от имени свойства,\nчто позволит нам работать с многострочным текстом:\n<img src="images/csharp-04-04.png">\nТеперь если запустить приложение, текстовое поле сразу будет содержать текст.\n<p>\nДобавим еще два элемента на форму. \n<ul>\n<li>Добавим кнопку, назовем ее (свойство <b>Name</b>) <b>btnShowLine</b>, и поменяем текст надписи (свойство <b>Text</b>)\nна <b>ПоказатьСтроку</b>.</li>\n<li>Добавим счетчик, назовем его <b>edtLineIndex</b>.\n</ul>\nПолучим что-то в этом роде:\n<img src="images/csharp-04-05.png">\nЩелкнем дважды на кнопку <b>btnShowLine</b> и пропишем обработчик события нажатия на кнопку.\nПо нажатию на эту кнопку должно будет выскакивать <b>MessageBox</b> в котором будет содержаться\nтекст строки из поля <b>txtMain</b> под номером указанным в <b>edtLineIndex</b>.\n<pre class="brush: csharp">\nprivate void btnShowLine_Click(object sender, EventArgs e)\n{\n	// считываем выбранный в edtLineIndex значение	\n	int lineIndex = (int)edtLineIndex.Value;\n	\n	// с помощью свойства Lines объекта txtMain, считываем значение выбранной строки\n	// и сохраняем его в новую переменную\n	string lineText = txtMain.Lines[lineIndex];\n	\n	//выводим значение переменной на экран\n	MessageBox.Show(lineText);\n}\n</pre>\n<div class="note">\nБолее правильно было бы добавить проверку на корректность указанного номера строки,\nвдруг пользователь выберет слишком большое значение. Такая ситуация может привести к\nпадению программы, поэтому правильнее будет написать так:\n<pre class="brush: csharp">\nprivate void btnShowLine_Click(object sender, EventArgs e)\n{\n	// считываем выбранный в edtLineIndex значение	\n	int lineIndex = (int)edtLineIndex.\nValue;\n	\n	// проверяем на допустимость значения индекса строки\n	if ( lineIndex >= 0 && lineIndex &lt; txtMain.Lines.Length)\n	{\n		// с помощью свойства Lines объекта txtMain, считываем значение выбранной строки\n		// и сохраняем его в новую переменную\n		string lineText = txtMain.Lines[lineIndex];\n		\n		//выводим значение переменной на экран\n		MessageBox.Show(lineText);\n	}\n}\n</pre>\n</div>\n<p>\nДобавим еще две кнопки, \n<ul>\n<li>Первую назовем <b>btnHighlightSep</b>, и поменяем ее надпись на <b>знаки</b>. С помощью этой\nкнопки мы сможем подсветить все знаки препинания в поле ввода</li>\n<li>вторую - <b>btnResetColor</b>, и поменяем ее надпись на <b>сбросить</b>.\nС помощью этой кнопки мы сможем снять подсветку текста.</li>\n</ul>\n<img src="images/csharp-04-06.png">\nКак я уже выше упомянул, текстовое поле позволяет форматировать текст, \nт.е. менять цвет, шрифт у подстрок в тексте. Для этого используется функция <b>Select</b>.\nФункция позволяет выделить подстроку в тексте. После того как кусок текста выделен, мы используя свойства вида <b>Selection*</b>\nможем изменять цвета и прочие характеристики выделенного текста.\n<p>\nНапишем обработчик события клика для кнопки <b>btnHighlightSep</b>, для этого как обычно щелкнем на нее дважды.\n\n<pre class="brush:csharp">\nprivate void btnHighlightSep_Click(object sender, EventArgs e)\n{\n	// прощелкиваем счетчик i от 0 до кол-ва символов в тексте	\n	for (int i=0; i &lt; txtMain.TextLength; ++i)\n	{\n		 // если символ на i-ой позиции, является знаком препинания	    \n	    if (Char.IsPunctuation(txtMain.Text[i]))\n	    {\n		    /* \n		  	  выделяем этот символ, функция \n		  	  Select(начальная_позиция_выделения, количество_символов для выделения)       \n		    */ \n	        txtMain.Select(i, 1);\n	        // устанавливаем цвет фона для выделенного текста на желтый \n	        txtMain.SelectionBackColor = Color.Yellow;\n	        // устанавливаем цвет выделенного текста на красный \n	        txtMain.SelectionColor = Color.Red;\n	    }\n	}\n}\n</pre>\nТеперь можно нажать на кнопку и полюбоваться на результат.\n<br>Правда реакция на нажатие кнопки видна только при первом нажатии. Чтобы исправить \nданную ситуация, пропишем кнопке с надписью <b>сбросить</b> обработчик события клика - кликнем на нее дважды.\n<pre class="brush: csharp">\nprivate void btnResetColor_Click(object sender, EventArgs e)\n{\n	// выделяем весь текст	\n	txtMain.SelectAll();\n	\n	// сбрасываем цвет фона выделенного текста на тот что по умолчанию\n	txtMain.SelectionBackColor = txtMain.BackColor;\n	\n	// сбрасываем цвет выделенного текста на тот что по умолчанию\n	txtMain.SelectionColor = txtMain.ForeColor;\n}\n</pre>\n\nДобавим еще одну кнопку, которая, ради смеха, позволит нам разукрасить текст в произвольные цвета.\n<ul>\n<li>Назовем ее <b>btnRandomColor</b>, и сменим ее надпись на <b>Разукрасить буквы</b></li>\n</ul>\n<img src="images/csharp-04-07.png">\nНапишем обработчик события клика для новой кнопки\n<pre class="brush: csharp">\nprivate void btnRandomColor_Click(object sender, EventArgs e)\n{\n	/*\n		создадим новый генератор случайных чисел\n		в соответствии с названием \n		он генерирует случайные числа\n		с помощью функции Next\n	*/	\n	Random rndGen = new Random();\n	\n	// снова пройдем счетчиком i от 0 до кол-ва символов в тексте\n	for (int i = 0; i &lt; txtMain.TextLength; ++i)\n	{\n	    // выделяем i-ый символ	    \n	    txtMain.Select(i, 1);\n	    \n	    /*\n	    	сгенерируем новый цвет,\n	    	цвет состоит из 3-х компонент, \n	    	красной (1-ый параметр), принимаемое значение от 0 до 255\n			зеленый (2-ый параметр), принимаемое значение от 0 до 255\n			синий (3-ый параметр), принимаемое значение от 0 до 255\n			\n			rndGen.Next(256) - сгенерирует случайное число от 0 до 255\n			установив 0 для синей компоненты цвета, мы получим красно-зеленую\n			осеннюю раскраску\n		 */\n	    Color newRandomColor = \nColor.FromArgb(rndGen.Next(256), rndGen.Next(256), 0);\n\n	    // установим цвет выделенного символа на значене ново-сгенерируемого цвета\n	    txtMain.SelectionColor = newRandomColor;\n	}\n}\n</pre>\n\nНу и напоследок. Тут у меня фрагмент текста из книги Алиса в Зазеркалье, я просто\nчувствую себя обязанным чего-нибудь отзеркалить. Я буквы конечно вверх ногами не переверну, но продемонстрирую\nвозможность переноса текста из элемента в другой. Итак, добавим два новых элемента \n<ul>\n<li>Кнопку, назовем ее <b>btnMirror</b>, и подпишем <b>отзеркалить текст</b></li>\n<li>Поле для ввода текста (<b>RichTextBox</b>), и назовем его <b>txtMirrored</b></li>\n</ul>\n<img src="images/csharp-04-08.png">\nПытаясь имитировать зеркало, мы развернем порядок букв в тексте. \nВообще говоря развернуть текст можно следующим трюком:\n<pre class="brush: csharp">\n// формируем массив символов из строки\nchar[] charsArray = txtMain.Text.ToCharArray();\n// инвертируем массив символов\nArray.Reverse(charsArray);\n// формируем новую строку на основе инвертированного массива символов\ntxtMirrored.Text = new String(charsArray);\n</pre>\nНо нам кроме инвертирования самого текста хотелось бы еще сохранить и цвет, соответствующих символов, \nдля этого реализуем посимвольную раскраску текста. Пропишем обработчик события клика для кнопки <b>btnMirror</b>\n<pre class="brush: csharp">\nprivate void btnMirror_Click(object sender, EventArgs e)\n{\n	// скопируем инвертированный текст из 	txtMain в txtMirrored\n	char[] charsArray = txtMain.Text.ToCharArray();\n	Array.Reverse(charsArray);\n	txtMirrored.Text = new String(charsArray);\n	\n	// пройдем счетчиком i от 0 до кол-ва символов в тексте txtMain\n	for (int i = 0; i &lt; txtMain.TextLength; ++i)\n	{\n		 // выделяем текст в txtMirrored    \n	    txtMirrored.Select(i, 1);\n	    /*\n	    	выделяем соответствующий символ в txtMain;\n	    	напоминаю, что текст у нас развернут\n	    	и первый символ txtMirrored соответствует \n	    	последнему символу txtMain\n	    */\n	    txtMain.Select(txtMain.TextLength - i -1, 1);\n	    \n	    // копируем значения соответствующих цветов\n	    txtMirrored.SelectionColor = txtMain.SelectionColor;\n	    txtMirrored.SelectionBackColor = txtMain.SelectionBackColor;\n	}\n}\n</pre>\nСтоит отметить что посимвольное копирование цвета ОООООЧЕНЬ медленное, и если \nвы вдруг закинули в поле для текста какой-нибудь (пусть даже небольшой рассказик),\nто самым разумным будет нажать <b>Shift+F5</b>\n<div class="note">\nКстати, если вы хотите наглядно видеть как происходит процесс перекраски текста, добавьте следующую\nстрочку в тело цикла:\n<pre class="brush: csharp">\n	 ...\n    txtMirrored.SelectionColor = txtMain.SelectionColor;\n    txtMirrored.SelectionBackColor = txtMain.SelectionBackColor;\n	  \n	 /*\n	 	с помощью этой строчки на каждой итерации цикла,\n	 	txtMirrored будет перерисовывать себя,\n	 	(в общем случае обрабатывать сообщения от операционной системы)\n	 	это сильно замедлит программу \n	 	но зато добавит в нее вау-эффект\n	 */\n    Application.DoEvents();\n}\n</pre>\n</div>\n<hr>\n<h2>Полный листинг:</h2>\nВ отличие от консольных приложений здесь недостаточно будет\nпросто скопировать текст в редактор текста <b>Visual Studio</b>,\nтут таки придется еще и нарисовать форму, и правильно назвать все компоненты.\n\np. \n\npre(brush:csharp).. \nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Data;\nusing System.Drawing;\nusing System.Linq;\nusing System.Text;\nusing System.Windows.Forms;\n\nnamespace WindowsFormsApplication1\n{\n    public partial class Form1 : Form\n    {\n        public Form1()\n        {\n            InitializeComponent();\n        }\n\n        private void btnShowText_Click(object sender, EventArgs e)\n        {\n            String textFromTxtMain = txtMain.Text;\n            MessageBox.Show(\ntextFromTxtMain);\n        }\n\n        private void btnShowLine_Click(object sender, EventArgs e)\n        {\n            int lineIndex = (int)edtLineIndex.Value;\n            String lineText = txtMain.Lines[lineIndex];\n            MessageBox.Show(lineText);\n        }\n\n        private void btnHighlightSep_Click(object sender, EventArgs e)\n        {\n            for (int i=0; i<txtMain.TextLength; ++i)\n            {\n                if (Char.IsPunctuation(txtMain.Text[i]))\n                {\n                    txtMain.Select(i, 1);\n                    txtMain.SelectionBackColor = Color.Yellow;\n                    txtMain.SelectionColor = Color.Red;\n                }\n            }\n        }\n\n        private void btnResetColor_Click(object sender, EventArgs e)\n        {\n            txtMain.SelectAll();\n            txtMain.SelectionBackColor = txtMain.BackColor;\n            txtMain.SelectionColor = txtMain.ForeColor;\n        }\n\n        private void btnRandomColor_Click(object sender, EventArgs e)\n        {\n            Random rndGen = new Random();\n            for (int i = 0; i < txtMain.TextLength; ++i)\n            {\n                txtMain.Select(i, 1);\n                Color newRandomColor\n                    = Color.FromArgb(rndGen.Next(256), rndGen.Next(256), 0);\n                txtMain.SelectionColor = newRandomColor;\n            }\n        }\n\n        private void btnMirror_Click(object sender, EventArgs e)\n        {\n            char[] charsArray = txtMain.Text.ToCharArray();\n            Array.Reverse(charsArray);\n            txtMirrored.Text = new String(charsArray);\n            for (int i = 0; i < txtMain.TextLength; ++i)\n            {\n                txtMirrored.Select(i, 1);\n                txtMain.Select(txtMain.TextLength - i -1, 1);\n                txtMirrored.SelectionColor = txtMain.SelectionColor;\n                txtMirrored.SelectionBackColor = txtMain.SelectionBackColor;\n\n                Application.DoEvents();\n            }\n            \n        }\n    }\n}\n\np. ', 1, 4, 0, 15, 0, 1383060309),
(7, 'Чаинка', '&#x25B2;', 'Чаинка', '', 11, '<div class="plain_text">\n<p align=center>\n<a href="http://tealeaf.su/index.php/page/inside" style="cursor:default;"><img alt="watch you" src="images/main_6.gif"/></a>\n</div>', 0, 0, 1, 0, 0, 0),
(9, 'Вопросы к первому коллоквиуму', 'Вопросы к первому коллоквиуму', 'Вопросы к первому коллоквиуму', '', 4, '#(tasks) Множества (пустое множество,  подмножество, операции над множествами, парадокс Рассела, теорема о мощности булеана множества).\n# Отношения (свойства бинарных, эквивалентность отношений и функций).\n# Отношение эквивалентности (свойства, разбиение на классы эквивалентности).\n# Пропозициональные связки. Таблицы истинности. Формулы.\n# Тавтологии. Противоречия.\n# Полные системы связок (примеры полных систем состоящих из 2-х связок, из 1-ой связки).\n# Аксиоматическая теория L (определение, аксиомы).\n# Вывод в формулах исчисления высказываний (ФИВ).\n# Теорема дедукции в ФИВ.', 1, 1, 0, 15, 0, 1382525749),
(10, 'Список лабораторных заданий', ' &nbsp;&#9679; Лабораторные', 'Список лабораторных заданий', '', 2, '<div class="lab"><h2 class="title"><a>#1. Анализ текста</a></h2><div class="info">Текст для каждой задачи необходим прочитать из файла. Файл с текстом вы вольны выбрать сами. Текст должен быть на русском языке и содержать не менее 1000 символов и исключать возможность пустых ответов. Под результат необходимо создать новый файл, и записать в него ответ.\n  \n#(tasks) \n#(easy) Найти слова в которых четное кол-во букв. В качества ответа предоставить список слов. Рассчитать долю таких слов относительно всех слов\n#(easy) Найти слова которые не содержат букву введенную с клавиатуры. Рассчитать долю таких слов относительно всех слов.\n#(easy selected) Найти слова в которых первая буква совпадает с последней. Рассчитать долю таких слов относительно всех слов.\n#(easy) Найти слова длина которых меньше числа введенного с клавиатуры. Рассчитать долю таких слов относительно всех слов. \n#(easy selected) Найти предложения содержащие четное кол-во слов. Рассчитать долю таких предложений относительно всех предложений.\n#(easy) Найти в тексте слова перевертыши. Рассчитать их долю относительно всех слов.\n#(easy selected) Найти предложение содержащее наибольшее кол-во слов.\n#(easy selected) Найти строку содержащую наибольшее кол-во предложений.\n#(easy) Найти слова около которых встречаются знаки препинания.	Рассчитать долю таких слов относительно всех слов.\n#(medium) Выяснить слова какой длины встречаются нибольшее кол-во раз в тексте.	Рассчитать долю таких слов относительно всех слов.\n#(medium selected) Удалить из текста все гласные.\n#(medium selected) Удалить из текста все согласные.\n#(medium) Найти слова которые не содержат одинаковых букв. Рассчитать долю таких слов относительно всех слов.\n#(medium) Найти слова в которых встречаются сдвоенные согласные. Рассчитать долю таких слов относительно всех слов.\n#(medium) Найти слова в которых одна и та же буква встречается более чем два раза. Рассчитать долю таких слов относительно всех слов.\n#(medium) Найти слова которые содержат нечетное кол-во гласных.	Рассчитать долю таких слов относительно всех слов.\n#(medium selected) Найти слова в которых гласных букв неменьше согласных. Рассчитать долю таких слов относительно всех слов.\n#(medium) Найти предложения, в которых согласных не менее чем в два раза больше чем гласных.	Рассчитать их долю относительно всех слов.\n#(medium) Найти слова в которых встречаются сдвоенные гласные. Рассчитать долю таких слов относительно всех слов.\n#(hard) Подсчитать сколько слогов содержит каждая строка. Если кол-во слогов в строках чередуется (например 8-7-8-7), сообщить об этом в файле отдельной строкой. В качестве текста рекомендуется использовать стих (правило 1000 символов отменяется).\n#(nightmare selected) Найти прилагательные в тексте. Рассчитать их долю относительно всех слов.\n#(nightmare selected) Найти имена в тексте. Рассчитать их долю относительно всех слов.\n\n</div></div><div class="lab"><h2 class="title"><a>#2. Регулярные выражения</a></h2><div class="info"> Для данного задания все операции поиска и разбиения необходимо производить с помощью регулярных выражений. Текст для обработки необходим прочитать из файла. Текст должен быть на русском языке и содержать не менее 1000 символов и исключать возможность пустых ответов. Под результат необходимо создать новый файл, и записать в него ответ.\n\n#(tasks) \n#(easy) Найти слова в которых встречаются более трех подряд идущих согласных (нпр: <b>стр</b>аница). Рассчитать долю таких слов относительно всех слов.</li>\n#(easy) Найти в тексте даты вида дд.мм.гггг (например 13.10.2013). Исходить из предположения что\nвсе даты в тексте валидные (т.е. нет таких 32.13.2201). Рассчитать долю таких последовательностей\nотносительно всех цифровых последовательностей.\n#(easy) Найти в тексте слова оканчивающиеся на несколько подряд идущих гласных (напр: вкусн<b>ое</b>). Рассчитать долю таких слов относительно всех слов.\n#(easy) Найти в тексте слова длины заданной пользователем, и рассчитать их долю относительно всех слов.\n#(easy) Найти в тексте слова с дефисом. Рассчитать их долю относительно всех слов.</li>\n#(easy) Найти в тексте слова содержащие не более одного дефиса. Рассчитать долю таких слов относительно всех слов.</li>\n#(easy) Найти в тексте цитаты</li>\n#(easy) Найти в тексте все IP-адреса. Исходить из предположения что все IP-адреса в тексте валидные. \nРассчитать долю таких числовых последовательностей относительное всех числовых последовательностей.</li>\n#(easy) Найти в тексте вопросительные и восклицательные предложения. Рассчитать долю таких предложений относительно всех предложений.</li>\n#(medium) Найти в тексте слова стоящие на начале и в конце предложений</li>\n#(medium) Найти в тексте слова содержащие четное кол-во букв. Рассчитать долю таких слов относительно всех слов.</li>\n#(medium) Найти в тексте слова содержащие нечетное кол-во цифр. Рассчитать долю таких слов относительно всех слов.</li>\n#(medium) Найти в тексте мобильные номера телефонов, с учетом возможности наличия черточек \n(нпр: <b>1 234 567 89 12</b>, <b>12345678912</b>, <b>+1 234 567 89 12</b>, <b>1-234-567-89-12</b>). Рассчитать долю таких последовательностей относительно всех цифровых последовательностей.</li>\n#(medium) Найти в тексте цифры от <b>1</b> до <b>99</b> (01, 02 и т.п. не считаются за цифры). Рассчитать долю таких цифровых последовательностей относительно всех цифровых последовательностей.</li>\n#(medium) Найти в тексте предложения содержащие знаки препинания. Рассчитать долю таких предложений относительно всех предложений</li>\n#(medium) Найти в тексте предложения содержащие не меньше n слов. Рассчитать долю таких предложений относительно всех предложений</li>\n#(hard selected) Найти в тексте пары слов в которых последняя буква первого совпадает с первой буквой второго слова. Рассчитать долю таких слов относительно всех слов.</li>\n#(hard) Найти в тексте слова содержащие две подряд идущие одинаковые буквы. Рассчитать долю таких слов относительно всех слов.</li>\n#(hard) Найти в тексте слова повторяющиеся два раза подряд. Рассчитать долю таких слов относительно всех слов.</li>\n#(hard) Найти предложения в которых встречаются повторяющиеся слова. Рассчитать долю таких предложений относительно всех предложений.</li>\n#(nightmare) Найти в тексте даты вида дд.мм.гггг (например 13.10.2013). Некорректные даты не должны войти в результат поиска (т.е. 32.13.2201 не подходит). Исходить из предположения что в каждом месяце 30 дней.</li>\n\n</div></div><div class="lab"><h2 class="title"><a>#3. Отчеты. Часть первая</a></h2><div class="info"> Создать *три* html документа. Каждый html-документ, должен содержать:\n# не менее одного простого списка (как минимум *3* элемента)\n# не менее одного нумерованного списка (как минимум *3* элемента)\n# не менее одной таблицы (как минимум *2* строки *2* столбца)\n# не менее одного заголовка\n# не менее одной картинки из локального источника\n# ссылки на соседние документы\n# ссылку на любой внешний ресурс\n\nИнформация на странице может быть любая. Но не такая как у соседа >:O\n\nТаким образом вы должны предоставить мне как минимум *6* файлов, примерно следующей структуры:\n\n!images/image_html_sample3.png! \n\n</div></div><div class="lab"><h2 class="title"><a>#3¼. Отчеты. Часть вторая</a></h2><div class="info"> В каждом из заданий необходимо прочитать данные из файла, создать собственный объект @struct SomeObjectName@, обладающий свойствами, которые отвечают строкам в файле. Создать список типа @List<SomeObjectName>@. Заполнить его данными из файла. Обработать список в соответствии с заданием, и сохранить результат в новый файл.\n\n#(tasks) \n#(easy) Найти актеров, которые начали свою карьеру актера после 20 лет. Результат упорядочить по фамилии.\nфайл: "actors.txt":files/data/actors.txt\n#(easy) Найти модели самолетов, которые в среднем выпускались не менее 100 штук в год. Результат упорядочить по названи концерна.\nфайл: "airplanes.txt":files/data/airplanes.txt\n#(easy) Найти вулканы извергающиеся до начала нашей эры и высотой больше 1000м. Результат упорядочить по названию.\nфайл: "volcano.txt":files/data/volcano.txt\n#(easy) Найти озера максимальная глубина которых превышает среднюю более чем в два раза. Результат упорядочить по названию.\nфайл: "lakes.txt":files/data/lakes.txt\n#(easy) Найти вулканы извергающиеся хотя бы раз за последние сто лет и находящиеся на высоте более 5000м. Результат упорядочить по названию.\nфайл: "volcano.txt":files/data/volcano.txt\n#(easy) Найти фильмы выпущенные под новый год в период с 1990 по 2000 г. Результат упорядочить по названию.\nфайл: "movies.txt":files/data/movies.txt\n#(easy) Найти озера, дно которых находится ниже уровня моря. Результат упорядочить по названию.\nфайл: "lakes.txt":files/data/lakes.txt\n#(medium) Для каждого конкретного концерна, найти наиболее успешную модель самолета. Результат упорядочить по названию коцерна.\nфайл: "airplanes.txt":files/data/airplanes.txt\n#(medium) Для каждого конкретного года, найти группу с наибольшим составом. Результат упорядочить по году.\nфайл: "bands.txt":files/data/bands.txt\n#(medium) Для каждого конкретной страны, найти автомобиль с наибольшим количеством передач. Результат упорядочить по названию страны.\nфайл: "automobiles.txt":files/data/automobiles.txt\n#(medium) Для каждого конкретного года, найти книгу содержащую наибольшее кол-во страниц. Результат упорядочить по году.\nфайл: "books.txt":files/data/books.txt\n#(medium) Для каждого конкретного созвездия, найти наиболее близкую к земле галактику. Результат упорядочить по названию созвездия.\nфайл: "galaxy.txt":files/data/galaxy.txt\n#(medium) Для каждого конкретного года, найти игру получившую наивысшую оценку. Результат упорядочить по году.\nфайл: "games.txt":files/data/games.txt\n#(medium) Найти самый высокий вулкан извергающийся в каждом конкретном году. Результат упорядочить по году.\nфайл: "volcano.txt":files/data/volcano.txt\n\nnotextile. </div></div>\n', 1, 0, 0, 65, 0, 1383470105);
INSERT INTO `articles` (`id_`, `title`, `title_menu`, `title_page`, `description`, `category_id`, `text`, `enabled`, `ord`, `top`, `visits`, `date_create`, `date_update`) VALUES
(11, 'Регулярные выражения. Часть 1', 'Регулярные выражения. Часть 1', 'Регулярные выражения. Часть 1', '', 2, 'notextile.. \nНаверное вам хоть раз да приходилось файл в папке, удовлетворяющий\nмаске поиска типа <b>*.txt</b>. Такая форма записи позволяла найти всем файлы\nс расширением <b>txt</b>, возможно вы даже применяли что-то подобное при поиске по тексту.\nТак вот, регулярное выражение представляет из себя подобие такой маски, но с куда более широкими\nвозможностями.\n<p>\nЯ буду выделять регулярное выражение <span style="font-size:1.5em; color:#08E">голубым</span> цветом.<br>\nПоследовательности символов удовлетворяющие регулярному выражению выдею <span style="background-color: yellow">так</span> либо <span style="background-color: #BF0">так</span>.<p>\nРассмотрим простейшее регулярное выражение состоящие из трех символов <b>к</b>, <b>о</b> и <b>т</b>.\nТо бишь просто слово <b>кот</b>.<br> \n<div class="regex">\n<dt>кот</dt>\n<dd><b>кот</b>-окто<b>кот</b> киткоооткат толчет в <b>кот</b>ле мак</dd>\n</div>\n\nВ слове <b>киткоооткат</b>, то же имеется слово кот, только оно вместе одной буквы <b>о</b> содержит\nцелых <b>три</b>. Мы можем легко добавить к результату поиска и это слово если перепишем регулярное выражение\nследующим образом\n\n<div class="regex">\n<dt>ко+т</dt>\n<dd><b>кот</b>-окто<b>кот</b> кит<b>кооот</b>кат толчет в <b>кот</b>ле мак</dd>\n</div>\n\nДанное выражение можно прочитать как найти все подстроки начинающихся с <b>к</b>,\nза которой следует одна или более буква <b>о</b>, и которая заканчивается буквой <b>т</b>.\n<p>\nЗнак <b>+</b> после символа означает что символ может встречаться один и более раз.\nБывают ситуации когда присутствие или отсутствие символа не столь важно, для этого\nнам предлагают использовать символ <b>*</b>. Вот как поведет себя поиск если мы заменим <b>+</b> на <b>*</b>\n\n<div class="regex">\n<dt>ко*т</dt>\n<dd><b>кот</b>-о<b>кт</b>о<b>кот</b> кит<b>кооот</b>кат толчет в <b>кот</b>ле мак</dd>\n</div>\nТут у нас добавилась подстрока <b>кт</b>, которая начинается на <b>к</b>, заканчивается на <b>т</b>\nно не содержит букву <b>о</b>.\n<p>\nЕсли важно найти "котов" содержащие не более одной буквы <b>о</b>, то нужно использовать знак <b>?</b>  \n<div class="regex">\n<dt>ко?т</dt>\n<dd><b>кот</b>-о<b>кт</b>о<b>кот</b> киткоооткат толчет в <b>кот</b>ле мак</dd>\n</div>\nЕсли же нам хочется указать какое-то конкретное кол-во повторений того или иного символа,\nмы можем указать значение к фигурных скобках.\n<div class="regex">\n<dt>ко{3}т</dt>\n<dd>кот коот <b>кооот</b> коооот коооооот</dd>\n</div>\nНе меньше 3-х раз:\n<div class="regex">\n<dt>ко{3,}т</dt>\n<dd>кот коот <b>кооот</b> <b>коооот</b> <b>коооооот</b></dd>\n</div>\nНе больше 3-х раз:\n<div class="regex">\n<dt>ко{,3}т</dt>\n<dd><b>кот</b> <b>коот</b> <b>кооот</b> коооот коооооот </dd>\n</div>\nОт 3-х до 5-ти:\n<div class="regex">\n<dt>ко{3,5}т</dt>\n<dd>кот коот <b>кооот</b> <b>коооот</b> коооооот </dd>\n</div>\n\nА что если нам хочется найти не только "котов" но и "китов" и "катов", а может даже и "кытов".\nДля таких случаев в квадратных скобах можно указать какие именно буквы могут находится\nмежду <b>к</b> и <b>т</b> \n<div class="regex">\n<dt>к[оаыи]т</dt>\n<dd><b>кот</b>-окто<b>кот</b> <b>кит</b>кооот<b>кат</b> толчет в <b>кот</b>ле мак</dd>\n</div>\nАльтернативный вариант вместо фигурных скобок использовать прямую черту\n<div class="regex">\n<dt>к(о|а|ы|и)т</dt>\n<dd><b>кот</b>-окто<b>кот</b> <b>кит</b>кооот<b>кат</b> толчет в <b>кот</b>ле мак</dd>\n</div>\nДостоинство <b>|</b> заключается в том что позволяет указывать в качестве вариантов целый слова\nнапример:\n<div class="regex">\n<dt>к(о|ро|апо|и)т</dt>\n<dd>Такое регулярное выражение будет искать в тексте слова: <b>кот</b>, <b>крот</b>, <b>капот</b> и <b>кит</b></dd>\n</div>\n\nЧего-то я отвлекся. Снова пропал наш "кооот". Чтоы вернуть его надо разрешить повторения в регулярном выражении\n<div class="regex">\n<dt>к[оаыи]+т</dt>\n<dd><b>кот</b>-окто<b>кот</b> <b>кит</b><b><i>кооот</i></b><b>кат</b> толчет в <b>кот</b>ле мак</dd>\n</div>\n\nА если нас устроят всякие "к-ты", какая бы буква не была между <b>к</b> и <b>т</b>. Конечно можно в ручную\nпрописать все буквы, но можно сделать проще - указав допустимый диапазон букв\n<div class="regex">\n<dt>к[а-я]+т</dt>\n<dd><b>кот</b>-окто<b>кот</b> <b>кит</b><b><i>кооот</i></b><b>кат</b> толчет в <b>кот</b>ле мак</dd>\n</div>\n\nЛибо еще проще, если использовать класс <b>\\w</b> (с маленькой буквы) - который соответствует всякой букве или цифре.\nНе совсем правильно решение в данной ситуации (начнут вылезать всякие <b>к0ты</b>, <b>к1ро23ты</b>, <b>к_ты</b>, <b>к666ты</b> и прочая нечисть),\nно для учебных целей сойдет.\n<div class="regex">\n<dt>к\\w+т</dt>\n<dd><b>кот</b>-окто<b>кот</b> <b>кит</b><b><i>кооот</i></b><b>кат</b> толчет в <b>кот</b>ле мак</dd>\n</div>\n\nОчень часто, нам не будут интересовать различные вариации "котов", и нам захочется найти\nобыкновенного няшного кота. Как помним использование в качестве регулярного\nвыражения "кот" находило нам не только котов но и элементы котлов\nи октокотов. И если второе еще можно принять за кота, \nто котел уж совсем не кот. Проще говоря мы хотим найти просто слово "кот".\nДля таких целей регулярные выражения предлагают нам символ границы слова <b>\\b</b>. \nЧто найти точно слово "кот" можно использовать следующее выражение.\n<div class="regex">\n<dt>\\bкот\\b</dt>\n<dd><b>кот</b>-октокот киткоооткат толчет в котле мак</dd>\n</div>\n\nАга! Теперь мы можем найти слова содержащие котов на правой границы слова\n<div class="regex">\n<dt>\\w*кот\\b</dt>\n<dd><b>кот</b>-<b>октокот</b> киткоооткат толчет в котле мак</dd>\n</div>\nИли на левой\n<div class="regex">\n<dt>\\bкот\\w*</dt>\n<dd><b>кот</b>-октокот киткоооткат толчет в <b>котле</b> мак</dd>\n</div>\nЕсли не хотите включать слово "кот" в результат поиска, замените <b>*</b> на <b>+</b>.\n<p>\nОчевидно что на котах далеко не уедешь, и часто приходится искать более абстрактные вещи, например \nможет возникнуть необходимость просто найти все слова в тексте. На предыдущих занятиях\nприходилось использовать б-гомерзкий <b>Split()</b>. Теперь же у нас есть регулярные\nвыражения. Для того чтобы найти все слова подойдет такое выражение:\n<div class="regex">\n<dt>[А-Яа-я]+</dt>\n</div>\nПо умолчанию регулярные выражения являются регистро-зависимыми, поэтому приходится\nявно указывать строчные и прописные буквы. Если нужны еще и английские буквы то так\n<div class="regex">\n<dt>[A-Za-zА-Яа-я]+</dt>\n</div>\nКонечно можно использовать и класс <b>\\w</b>, но тогда к поиску добавятся еще и последовательности\nсодержащие цифры и подчеркивание <b>_</b>. То есть например так\n<div class="regex">\n<dt>\\w+</dt>\n<dd>Будет находить все последовательности символов содержащие исключительно\n<b>буквы</b>, <b>цифры</b> и <b>знак подчеркивания</b></dd>\n</div>\nЕсли вам нужны только цифры то можно использовать класс <b>\\d</b>:\n<div class="regex">\n<dt>\\d+</dt>\n<dd>Мне <b>15</b> лет, а мой IP <b>255</b>.<b>255</b>.<b>255</b>.<b>0</b></dd>\n</div>\nКстати, если указать в качестве регулярного выражения <b>\\w</b> без <b>*</b> или <b>+</b>\nполучим список всех букв, цифр и знаков подчеркиваний\n<div class="regex">\n<dt>\\w</dt>\n<dd><b>к</b><i>о</i><b>т</b>-<i>о</i><b>к</b><i>т</i><b>о</b><i>к</i><b>о</b><i>т</i> <b>к</b><i>и</i><b>т</b><i>к</i><b>о</b><i>о</i><b>о</b><i>т</i><b>к</b><i>а</i><b>т</b> <i>т</i><b>о</b><i>л</i><b>ч</b><i>е</i><b>т</b> <i>в</i> <b>к</b><i>о</i><b>т</b><i>л</i><b>е</b> <i>м</i><b>а</b><i>к</i></dd>\n</div>\n<p>\nМожет потребоваться найти все разделительные символы (пробелы, табуляции, переходы на новую строку и т.д).\nДля этого можно использовать класс <b>\\s</b>\n<div class="regex">\n<dt>\\s+</dt>\n<dd>кот-октокот<b> </b>киткоооткат<b> </b>толчет<b> </b>в<b> </b>котле<b> </b>мак</dd>\n</div>\nПрошу обратить внимания что знаки препинания не считаются за разделители.\nЕсли вам очень уж захочется пересчитать все разделители, включая знаки препинания\nбоюсь что придется перечислить их все в скобках. Примерно так:\n<div class="regex">\n<dt>[\\s,.;:?!]+</dt>\n<dd>кот<b>-</b>октокот<b> </b>киткоооткат<b> </b>толчет<b> </b>в<b> </b>котле<b> </b>мак</dd>\n</div>\nСначала я указываю класс всех пробельных разделителей, а потом дополняю его знаками препинания.\nЛибо если использовать класс обратный для класса <b>\\w</b>. Обратный класс пишется с заглавной буквы <b>\\W</b>:\n<div class="regex">\n<dt>\\W+</dt>\n<dd>кот<b>-</b>октокот<b> </b>киткоооткат<b> </b>толчет<b> </b>в<b> </b>котле<b> </b>мак</dd>\n</div>\n<p>\nА что если возникает ситуация когда надо найти любую последовательность символов, будь то\nпробелы буквы или что-то еще. Тут нам на помощь приходит символ <b>.</b> (\nточка, соответствует любому символу). Например следующее выражение \nсоответствует всему тексту:\n<div class="regex">\n<dt>.*</dt>\n<dd><b>кот-октокот киткоооткат толчет в котле мак</b></dd>\n</div>\nА если нам хочется найти все последовательности находящиеся между двумя <b>т</b>:\n<div class="regex">\n<dt>т.*т</dt>\n<dd>ко<b>т-октокот киткоооткат толчет в кот</b>ле мак</dd>\n</div>\nO__o? Чего-то много выделил. Ну уж точно не точно то, что я хотел.\nЭто называется жадностью, символы <b>+</b>, <b>*</b> при добавлении их после того или иного \nэлемента пытаются сформировать строку наибольшей длины соответствующей шаблону, часто\nэто приводит к неправильным результатом, чтобы избавить плюсик и звездочку от жадности,\nнадо добавлять после них знак вопроса. Вот так:\n<div class="regex">\n<dt>т.*?т</dt>\n<dd>ко<b>т-окт</b>око<b>т кит</b>кооо<b>ткат</b> <b>толчет</b> в котле мак</dd>\n</div>\nНу и наверное последнее что стоит отметить, что если вам вдруг захочется найти в тексте\nсимвол <b>*</b>, <b>+</b> или точку (<b>.</b>). Такие символы придется проэкранировать, путем добавления обратного \nслеша перед символом. Следующий пример находит в тексте все точки:\n<div class="regex">\n<dt>\\.+</dt>\n<dd>Вечереет<b>...</b> вот<b>.</b> и все<b>.</b></dd>\n</div>\n<hr>\n<h2>Регулярные выражения в C#	</h2>\nВ следующем консольном приложении регулярные выражения используются чтобы найти \nв тексте все слова начинающиеся на букву <b>a</b>.\n<pre class="brush: csharp">\nusing System;\nusing System.Collections.Generic;\nusing System.Text;\n\n// необходимо для считывания текста из файла\nusing System.IO; \n\n// необходимо для использования регулярных выражений\nusing System.Text.RegularExpressions; \n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n      static void Main (string[] args)\n		{\n		   /*\n		   	считываем текст из файла, и сохраняем его в переменную text,\n		   	Encoding.GetEncoding (1251) - использую чтобы явно указать кодировку,\n		   	в большинстве случаев, можно использовать просто Encoding.Default\n		   */			\n			string text = File.ReadAllText(\n				@"C:\\Алиса в Зазеркалье.txt",\n				Encoding.GetEncoding (1251)\n				);\n\n			/*\n			  Создаем регулярное выражения \n			  \\bА\\w+\n			  очевидно, оно распознает все слова начинающиеся на A\n			  \n			  устанавливаю флаг RegexOptions.IgnoreCase, \n			  чтобы не учитывать регистр букв			  \n			*/\n			Regex regEx = new Regex (@"\\bА\\w+", RegexOptions.IgnoreCase);\n			\n			/*\n			  Использую функцию Matches выше созданного регулярного выражения\n			  которая ищет в тексте последовательности символов \n			  удовлетворяющие регэкспу, \n			  и возвращает их в виде коллекции объектов типа Match \n			*/\n			MatchCollection matches = regEx.Matches (text);\n\n			/*\n			  Вывожу на экран все найденные слова (естественно, с повторениями).\n			  \n			  Стоит отметить что тип Match не просто строка, но также содержит \n			  информацию о расположении слова в тексте, его длине и некоторые\n			  другие плюшки.\n			*/\n			foreach (Match m in matches) \n			{\n				/*\n					напомню, что {0} заменяется на первый параметр \n					идущий после строки формата\n				*/\n				Console.WriteLine("Нашел на позиции {0}", m.Index);\n				Console.WriteLine("слово ''{0}''", m.Value);\n			}\n        }\n    }\n}\n</pre>', 1, 5, 0, 25, 0, 1382525668),
(12, 'Регулярные выражения. Часть 2', 'Регулярные выражения. Часть 2', 'Регулярные выражения. Часть 2', '', 2, 'h2. Группы\n\nКогда простого набора строк в качестве результата не достаточно, на помощь приходит возможность регулярных выражений возвращать результат разбитый на подгруппы. Чтобы разбить шаблон на группы используется обыкновенный скобки *(*, *)*.\n\nСледующее выражение можно использовать для поиска простых адресов e-mail.\n\n<div class="regex"><dt>\\w+@\\w+.\\w+</dt><dd>Очевидно, следующие строки будут удовлетворять регулярному выражения:<br>Мой почтовый адрес **bird@yandex.ru**</dd></div>\n\nТеперь добавим скобки вокруг каждого *\\w+*. \n<div class="regex"><dt>(\\w+)@(\\w+).(\\w+)</dt><dd>Таже строка:<br>Мой почтовый адрес **bird@yandex.ru**</dd></div>\n\nВроде бы ничего и не изменилось, однако теперь мы можем работать с подгруппами. В @Visual C#@ для этого у каждого объекта типа @Match@ есть свойство @Groups@, которое представляет массив подгрупп в выражении. Т.е например:\n\npre(brush:csharp).. \n/*\n Создадим регулярное выражения\n для поиска простых адресов e-mail:\n (\\w+)@(\\w+).(\\w+)\n\n ''@'' перед двойной кавычкой используется \n для экранирования обратного слеша \\,\n \n без символа @ пришлось бы писать:\n (\\\\w+)@(\\\\w+).(\\\\w+)\n*/\nRegex regEx = new Regex (@"(\\w+)@(\\w+).(\\w+)");\n\n/*\n Функция Match возвращает первый результат \n удовлетворяющий регулярному выражению\n*/\nMatch m = regEx.Match("Мой почтовый адрес bird@yandex.ru");\n\nConsole.WriteLine( m.Groups[0] ); // выведет на экран bird@yandex.ru"\nConsole.WriteLine( m.Groups[1] ); // выведет на экран bird\nConsole.WriteLine( m.Groups[2] ); // выведет на экран yandex\nConsole.WriteLine( m.Groups[3] ); // выведет на экран ru\n\np. Нумерация групп идет с @1@, нулевой группе соответствует все регулярное выражение.\n\nГруппы могут быть вложенными, например:\n<div class="regex"><dt>(\\w+)@((\\w+).(\\w+))</dt><dd>Мой почтовый адрес **bird@yandex.ru**<br></dd></div>\n\nРезультат все тот же, но группы теперь будут иметь следующие значения\n\n# bird\n# yandex.ru\n# yandex\n# ru\n\nВидно, что @вторая@ группа содержит результат @третьей@ и @четвертой@ вместе, плюс еще точку между ними. Нумерация групп идет в соответствии с порядком открывающих скобок.\n\nВообще говоря, обращаться к группам мы можем и внутри регулярного выражения, для этого используются обратные ссылки. Обратная ссылка имеет вид обратного слеша с следующим за ним номером группы: @\\1, \\2, \\3 .. \\9@.\n\nЗачем кому-то могут понадобиться обратные ссылки? Ну например если ему надо будет искать строки с повторяющимися элементами. Например:\n\n<div class="regex"><dt>(\\w+)\\1</dt><dd>Мой сосед <b>тото</b>о, не, не, <b>охох</b>о!<br></dd></div>\n\n@\\1@ - означает что мы хотим, чтобы стоящее в скобках повторилось еще один раз. Таки образом интерпретатор регэкспов находит строку @''то''@, видит что за ней снова идет точно такая строчка @''то''@, и отмечает результат как удовлетворяющий регулярному выражению. Продолжает поиск, пока не дойдет до @''хо''@. Строка @не, не,@ не удовлетворяет регулярному выражению так как в этой строке присутствуют запятые и пробелы, которые не входят в класс @\\w@.\n\nТакже группировку приходится использовать если необходимо найти в тексте строки с повторяющимися составными подстроками. Например чтобы найти в тексте простые предложения без знаков препинания можно использовать следующее выражение:\n\n<div class="regex"><dt>(\\w+\\s*)+</dt><dd>**Мой сосед Тоторо**. <i>А я люблю желуди</i>.</dd></div>\n\nВ результате получим две подстроки соответствующие первому и второму предложения. И хотя хотелось бы, чтобы в качестве групп у нас были слова предложения. На деле же у нас будет всего одна группа содержащая последнее найденной в предложении слово. Т.е.:\n\n# Мой сосед Тоторо\n## Тоторо\n# А я люблю желуди\n## желуди\n\nСкорее всего толку от этого последнего слова вам не будет, синтаксис регулярных выражений позволяет нам отключить группу. Т.е. она будет использоваться для поиска, но в результат как подгруппа не попадет. Делается это путем добавления @?:@ после открывающей скобки:\n\n<div class="regex"><dt>(?:\\w+\\s*)+</dt><dd><b>Мой сосед Тоторо</b>. <i>А я люблю желуди</i>.</dd></div>\n\nВ результате получим те же два предложения но уже без подгрупп.\n\n# Мой сосед Тоторо\n## --\n# А я люблю желуди\n## --\n\n<hr>\n\nh2. Просмотр вперед и назад\n\nИногда необходимо построить регулярное выражение, которое учитывает подстроки находящиеся до либо после результата, но в сам результат не попадающие. Для этого используются следующие конструкции:\n\n* @(?=шаблон)@ -- позитивный просмотр вперед\n* @(?!шаблон)@ -- негативный просмотр вперед\n* @(?<=шаблон)@ -- позитивный просмотр назад\n* @(?<!шаблон)@ -- негативный просмотр назад (ужас какой :O)\n\nНе знаю что сказать по этому поводу, так что вот лучше оставлю примеры здесь.\n\nСлово *два* справа от которого находится слово *три*\n\n<div class="regex"><dt>два(?=\\s+три)</dt><dd>один <b>два</b> три два один</i>.</dd></div>\n\nОбратите внимание что слово *три* не попадает в результат поиска но тем не менее влияет на исходный результат.\n\nСлово *два* справа от которого нет слова *три*\n\n<div class="regex"><dt>два(?!\\s+три)</dt><dd>один два три <b>два</b> один</i>.</dd></div>\n\nСлово *два* слева от которого находится слово *три*\n\n<div class="regex"><dt>(@?<@=три\\s+)два</dt><dd>один два три <b>два</b> один</i>.</dd></div>\n\nСлово *два* слева от которого нет слова *три*\n\n<div class="regex"><dt>(@?<@!три\\s+)два</dt><dd>один <b>два</b> три два один</i>.</dd></div>\n\n<hr>\n\nh2. Забыл упомянуть\n\nОперация инвертирования *^*, если вы вдруг захотите найти слово не начинающееся с какой-нибудь буквы, например буквы *а*:\n\n<div class="regex"><dt>\\b[^a]\\w+</dt><dd>апельсин, <b>яблоко</b>, <b>банан</b>, ананас</dd></div>\n\nНе начинающееся с нескольких букв буквы, например букв *а,б*:\n\n<div class="regex"><dt>\\b[^aб]\\w+</dt><dd>апельсин, <b>яблоко</b>, банан, ананас</dd></div>\n\nТут обязательно надо использовать символ границы слова *\\b* так как операция отрицания захватывает все символы в том числе и те, что не попадают в разряд букв.\n\nЗабыл упомянуть пару специальных символов:\n\n* ^ -- начало строки\n* $ -- конец строки\n\nСобственно и все.\n\nПотренироваться в написании можно тут "rextester.com":http://rextester.com/tester. В левом поле пишем регулярку, в правом текст для анализа, жмем F8.\n\nЕсли вы захотите узнать о регулярных выражения побольше, то начать можно с \n"википедии":http://ru.wikipedia.org/wiki/Регулярные_выражения, там вам расскажут что регулярные выражения бывают нескольких видов POSIX и PCRE, наши второго типа. Еще регулярные выражения бывают ревнивые и допускают использование условий.\n\nНу а если вы почувствуете себя гуру регулярных выражений, то вам сюда: "Regex Tuesday - Challenges":http://callumacrae.github.io/regex-tuesday/.', 1, 6, 0, 20, 0, 1383057016),
(13, 'Литература', '&nbsp;&#9632; Литература', 'Книги по Мат.Логике', '', 4, '* "Мальцев А.И. Алгебраические системы":files/Мальцев_Алгебраические_системы.djvu -- про отношения\n* "Мендельсон Э. Введение в математическую логику":files/Мендельсон_Э._Введение_в_математическую_логику.djvu -- формальная логика, предикаты, вывод и т.д\n* "Лорьер Системы искуственного интеллекта":files/Лорьер_-_Системы_искуственного_интеллекта.djvu -- сложность, NP-полнота и еще много чего\n', 1, 0, 0, 11, 0, 1382882924),
(17, 'Основы HTML', 'Основы HTML', 'Основы HTML', '', 2, '\n*HTML* есть, буквально, язык разметки гипертекстов (Hypertext Markup Language). Не является языком программирования и используется для форматирования текста и прочего содержимого html-страниц. Форматирование осуществляется за счет использования тегов. Всякий тег имеет вид @<some_tag_name>@. \n\nТеги бывают открывающие: @<body>@ и закрывающие: @</body>@. Как видно закрывающий тег отличается от открывающего наличием прямого слеша.\n\nПример простой HTML-страницы:\n\npre(brush:html).. \n<!DOCTYPE html>\n<html> \n<head> \n  <title>Страничка</title>\n</head> \n<body> \n  <h1>Моя страничка</h1>\n  <p>Привет!\n  Ура!\n  <br>Добра всем!!!\n  <p>Все работает!!! :D\n</body> \n</html> \n\np. На самом деле html-страница есть не что иное как обыкновенный текстовый документ. Как правило html-документы открываются браузером (chrome, firefox, opera и т.д.). Браузер же в свою очередь в соответствии с тем что в документе написано выдает нам то что мы привыкли называть веб-страницей. \n\nРазберем что же у нас написано на страничке:\n# @<!DOCTYPE html>@ -- первый тег, требование стандарта оформления html-страниц, сообщает о том, что все что находится ниже является элементами *HTML*. В принципе можно не писать.\n# @<html>@ и @</html>@ -- все что находится между @<html>@ и @</html>@ есть содержимое html-страницы.\n# @<head>@ и @</head>@ -- (head: голова). Служебная, непечатная информация об странице. Между двумя этими тегами как правило помещают другие подтеги: заголовок страницы, ключевые слова, ссылки на сторонние ресурсы, скрипты, стили и прочую информацию влияющую на поведение и отображение содержимого html-страницы. У нас внутри @<head>@ только название страницы\n# @<title>@ и @</title>@ -- (title: название). Между двумя тегами располагают название страницы, как он отображается во вкладке браузера.\n# @<body>@ и @</body>@ -- (body: тело). Собственно все содержимое страницы располагается между этими двумя тегами.\n# @<h1>@ и @</h1>@ -- текст расположенные между этими двумя и тегами будет отображен как заголовок 1-уровня, т.е. большими жирным буквами.\n# @<p>@ -- (paragrah: абзац). Используется для того, чтобы начать новый абзац.\n# @<br>@ -- (brake: тормозить). Используется для того, чтобы начать новую строку.\n\nПопробуйте создать пустой текстовый файл. Смените его расширение c *txt* на *html*, скопируйте в него текст из примера, и запустите файл. По идее он должен открыться в вашем браузере по умолчанию, и вы должны увидеть что-то вроде этого: !images/image_html_sample.png! Обратите внимание что несмотря на то, что в примере *Ура!* перенесено на новую строку, браузер это проигнорировал. Это так и должно быть. Наличие переходов на новую строку, а также попытка поставить более 1 пробела, будет проигнорирована интерпретатором html-разметки (то бишь браузером). В данной ситуации было бы правильнее написать:\n\npre(brush:html).. \n  ...\n  <p>Привет!\n  <br>Ура!\n  <br>Добра всем!!!\n  ...\n\np. либо так\n\npre(brush:html).. \n  ...\n  <p>Привет!<br>\n  Ура!\n  <br>Добра всем!!!\n  ...\n\np. В принципе можно явно указывать границы строк и абзацов:\n\npre(brush:html).. \n  ...\n  <p>\n  <br>Привет!</br>\n  <br>Ура!</br>\n  <br>Добра всем!!!</br>\n  </p>\n  ...\n\np.  но как правило в этом нет необходимости.\n<hr>\n\nh2. Ссылки\n\nГипертексты не были бы гипертекстами, если бы не возможность создавать гиперссылки. Гиперссылки позволяют перемещаться между html-документами.\n\nСоздать гиперссылку легко, для этого используется тег @<a>@. Однако одного тега не достаточно, необходимо дополнительно использовать атрибут @href@, которому присваивается адрес ссылки.\n\nДобавить атрибут к тегу очень легко. Общий синтаксис тега с атрибутом имеет следующий вид:\n\npre(brush:html).. \n<tag att1="value1" att2="value2" ... >\n\np. tag -- это имя тега; att1, att2 -- имена атрибутов; value1, value2 -- значения соотвествующих атрибутов.\n\nТаким образом чтобы создать ссылку например на википедию, надо добавить в тело html-страницы (тег @<body>@), следующий код:\n\npre(brush:html).. \n<a href="http://ru.wikipedia.org">кликни меня</a>\n\np. Текст содержащийся между открывающим и закрывающим тегом, и увидит пользователь. Можно продолжить предыдущий пример:\n\npre(brush:html).. \n  ...\n  <p>Все работает!!! :D\n  <br>\n  <a href="http://ru.wikipedia.org">кликни меня</a>\n  ...\n\np. Получится что-то в этом роде: !images/image_html_sample2.png!\n\nМожно соединить сколько угодно файлов с помощью ссылок. Создадим в одной папке два файла:\n<table width=100%><tr><th>first.html</th><th>second.html</th></tr><tr><td>\n\npre(brush:html).. \n<!DOCTYPE html>\n<html> \n<head> \n  <title>Первая</title>\n</head> \n<body> \n  <h1>Первая страничка</h1>\n  <a href="second.html">\n   перейти на вторую страничку\n  </a>\n</body> \n</html>\n\np. </td><td>\n\npre(brush:html).. \n<!DOCTYPE html>\n<html> \n<head> \n  <title>Вторая</title>\n</head> \n<body> \n  <h1>Вторая страничка</h1>\n  <a href="first.html">\n    назад на первую страничку\n  </a>\n</body> \n</html>\n\np. </td></tr></table> \nОткрыв один файл в браузере, мы сможем попадать на другой нажимая на ссылку.\n<hr>\n\nh2. Изображения\n\nЧтобы вставить изображение используется тег @<img>@. Главный атрибут у тега @src@, используется для указания пути к файлу изображения. В качестве файла можно использовать как локальный файл, указывая абсолютный адрес файла:\n\npre(brush:html).. \n<img src="D:/Изображения/happines.jpeg" >\n\np. относительный путь:\n\npre(brush:html).. \n<img src="images/happines.jpeg" >\n\np. В так случае, как правило, подразумевается что директория *images* находится в той же папке где и файл, в который вставлено изображения. \nНу и естественно можно использовать ссылку на файл в интернете:\n\npre(brush:html).. \n<img src="http://24.media.tumblr.com/21e90b1e647f020b1816be93ce7b1760/tumblr_mi1bc2h5Bs1rq8f6wo1_500.gif" >\n\np. Для тега @<img>@ не существует закрывающего тега. Ну то есть написать его конечно можно, но браузер его просто проигнорирует.\n<hr>\n\nh2. Списки\n\nСписки бывают двух типов: нумерованные и простые. \n\nДля простого списка используется тег @<ul>@, каждый элемент списка заключается в пару тегов @<li>@ и @</li>@\n<table width=100%><tr><th>Код</th><th>Отображение</th></tr><tr><td width=50%>\n\npre(brush:html).. \n<ul>\n  <li>Первый элемент</li>\n  <li>Второй элемент</li>\n  <li>Третий элемент</li>\n</ul>\n\np. </td><td style="background:white;"><ul>  <li>Первый элемент</li>  <li>Второй элемент</li>  <li>Третий элемент</li></ul></td></tr></table>\n\nДля нумерованного списка используется тег @<ol>@: <table width=100%><tr><th>Код</th><th>Отображение</th></tr><tr><td width=50%>\n\npre(brush:html).. \n<ol>\n  <li>Первый элемент</li>\n  <li>Второй элемент</li>\n  <li>Третий элемент</li>\n</ol>\n\np. </td><td style="background:white;"><ol>  <li>Первый элемент</li>  <li>Второй элемент</li>  <li>Третий элемент</li></ol></td></tr></table>\n<hr>\n\nh2. Таблицы\n\nТаблицы состоят из строка, каждая строка может содержать несколько ячеек. При необходимости ячейки и строки можно объединять. Таблица задается парой тегов @<table>@ и @</table>@.\n\nПример таблицы: <table width=100%><tr><th>Код</th><th>Отображение</th></tr><tr><td width=50%>\n\npre(brush:html).. \n<table>\n <tr>\n  <td>Элемент 1.1</td> \n  <td>Элемент 1.2</td> \n  <td>Элемент 1.3</td>\n </tr>\n\n <tr>\n  <td>Элемент 2.1</td>\n  <td>Элемент 2.2</td> \n  <td>Элемент 2.3</td>\n </tr>\n\n <tr>\n  <td>Элемент 3.1</td>\n  <td>Элемент 3.2</td> \n  <td>Элемент 3.3</td>\n </tr>\n</table>\n\np. </td><td align=center style="background:white;"><table><tr> <td>Элемент 1.1</td> <td>Элемент 1.2</td> <td>Элемент 1.3</td> </tr><tr><td>Элемент 2.1</td> <td>Элемент 2.2</td> <td>Элемент 2.3</td> </tr></tr><tr><td>Элемент 3.1</td> <td>Элемент 3.2</td> <td>Элемент 3.3</td> </tr></table></td></tr></table>\n\nТэги @<tr>@, @</tr>@ обозначает начало и конец строки. Тэги @<td>@, @</td>@ используется для обозначения ячейки в строке, и обязательно должны находится между тегами @<tr>@, @</tr>@. \n\nЗа объединение строк отвечает атрибут @rowspan@. В качестве значения атрибута указывается сколько строк должна занимать ячейка. Атрибут добавляется к тегу @<td>@. <table width=100%><tr><th>Код</th><th>Отображение</th></tr><tr><td width=50%>\n\npre(brush:html).. \n<table>\n <tr>\n  <td>Элемент 1.1</td> \n  <td rowspan=2>Элемент 1.2</td> \n  <td>Элемент 1.3</td>\n </tr>\n\n <tr>\n  <td>Элемент 2.1</td>\n  \n  <td>Элемент 2.3</td>\n </tr>\n</table>\n\np. <td align=center style="background:white;"><table><tr><td>Элемент 1.1</td> <td rowspan=2 >Элемент 1.2</td> <td>Элемент 1.3</td></tr><tr><td>Элемент 2.1</td><td>Элемент 2.3</td></tr></table> </td> </tr></table>\n\nЗа объединение столбцов отвечает атрибут @colspan@. В качестве значения атрибута указывается сколько столбцов должна занимать ячейка. Атрибут также добавляется к тегу @<td>@. <table width=100%><tr><th>Код</th><th>Отображение</th></tr><tr><td width=50%>\n\npre(brush:html).. \n<table>\n <tr>\n  <td colspan=2>Элемент 1.1</td> \n  \n  <td>Элемент 1.3</td>\n </tr>\n\n <tr>\n  <td>Элемент 2.1</td>\n  <td>Элемент 2.2</td> \n  <td>Элемент 2.3</td>\n </tr>\n</table>\n\np. <td align=center style="background:white;"><table><tr><td colspan=2>Элемент 1.1</td> <td>Элемент 1.3</td></tr><tr><td>Элемент 2.1</td><td>Элемент 2.2</td><td>Элемент 2.3</td></tr></table> </td> </tr></table>\n\nЕстественно никто не мешает использовать оба атрибута одновременно.<table width=100%><tr><th>Код</th><th>Отображение</th></tr><tr><td width=50%>\n\npre(brush:html).. \n<table>\n <tr>\n  <td colspan=2 rowspan=2>Элемент 1.1</td> \n  \n  <td>Элемент 1.3</td>\n </tr>\n <tr>\n \n\n  <td>Элемент 2.3</td>\n </tr>\n <tr>\n  <td>Элемент 3.1</td>\n  <td>Элемент 3.2</td> \n  <td>Элемент 3.3</td>\n </tr> \n</table>\n\np. <td align=center style="background:white;"><table><tr><td colspan=2 rowspan=2>Элемент 1.1</td> <td>Элемент 1.3</td></tr><tr><td>Элемент 2.3</td></tr><tr><td>Элемент 3.1</td><td>Элемент 3.2</td><td>Элемент 3.3</td></tr></table> </td> </tr></table>\n\n<hr>\n\nh2. Декорации\n\n<table width=100%><tr><th>Код</th><th>Отображение</th></tr><tr> <td width=50%>\n\npre(brush:html).. \n<b>Жирный текст</b>\n\n<i>Курсив</i>\n\n<u>Подчеркнутый</u>\n\n<s>Перечеркнутый</s>\n\n<q>В кавычках</q>\n\np. </td><td align=center style="background:white;"><b>Жирный текст</b><br>\n<i>Курсив</i><br>\n<u>Подчеркнутый</u><br>\n<s>Перечеркнутый</s><br>\n<q>В кавычках</q><br>\n</td></tr></table>\n\nАбзацы можно выравнивать <table width=100%><tr><th>Код</th><th>Отображение</th></tr><tr> <td width=50%>\n\npre(brush:html).. \n<p align=left>Выравненный влево\n\n<p align=center>Выравненный по центру\n\n<p align=right>Выравненный вправо\n\np. <td><p align=left style="background:white;">Выравненный влево<p align=center>Выравненный по центру<p align=right>Выравненный вправо</td></tr></table>\n\nЗаголовки:<table width=100%><tr><th>Код</th><th>Отображение</th></tr><tr> <td width=50%>\n\npre(brush:html).. \n<h1>Заголовок1</h1>\n\n<h2>Заголовок2</h2>\n\n<h3>Заголовок3</h3>\n\n<h4>Заголовок4</h4>\n\n<h5>Заголовок5</h5>\n\n<h6>Заголовок6</h6>\n\np. </td><td align=center style="background:white;"><h1>Заголовок1</h1><h2>Заголовок2</h2><h3>Заголовок3</h3><h4>Заголовок4</h4><h5>Заголовок5</h5><h6>Заголовок6</h6></td></tr></table>\n\nВерхний и нижний индексы:<table width=100%><tr><th>Код</th><th>Отображение</th></tr><tr> <td width=50%>\n\npre(brush:html).. \nиндекс<sup>верхний</sup> | индекс<sub>нижний</sub>\n\np. </td><td align=center style="background:white;">индекс<sup>верхний</sup> | индекс<sub>нижний</sub></td></tr></table>\n\n<hr>\n\nh2. PS\n\nВообще говоря про html-страницы можно еще ОЧЕНЬ много чего рассказать. Но так как цель данного урока ознакомить вас с основами языка форматирования текста, я больше ничего и не скажу :3', 1, 7, 0, 11, 1382458008, 1382718458);
INSERT INTO `articles` (`id_`, `title`, `title_menu`, `title_page`, `description`, `category_id`, `text`, `enabled`, `ord`, `top`, `visits`, `date_create`, `date_update`) VALUES
(18, 'Структуры. Форматированный текст.', 'Структуры. Форматированный текст.', 'Структуры. Форматированный текст.', '', 2, 'h2. Структуры (struct)\n\nОдним из наиболее эффективных способов повысить наглядность кода -- начать использовать структуры. Классический пример: вам надо хранить информацию о жителях города. Эта информацию включает в себя, допустим, имя, фамилию, возраст, адрес. Главное требование, это возможность по номеру жителя быстро узнать информацию о нем. Решение в лоб предлагает нам следующие альтернативы:\n\nПервый способ, хранить список строк, разделяя каждый элемент каким-нибудь разделителем (например *;*):\n\npre(brush:csharp).. \nList<string> infoList = new List<string>;\n\ninfoList.add("Вася; Пупкин; 21; Иркутск, ул. Байкальская 1-2");\ninfoList.add("Маша; Анюткина; 21; Иркутск, ул. Ангарская 3-4");\n\np. Если нам захочется получить доступ к фамилии 1 человека в списки, нам придется разбить строку функцией @Split@, и обратиться ко 2 элементу списка подстрок:\n\npre(brush:csharp).. \nstring[] human = infoList[0].Split(";");\nConsole.WriteLine(human[1]); // выведет на экран: Пупкин\n\np. Слишком много кода для, казалось бы, такой тривиальной операции, как обращение к подэлементу элемента списка.\n\nВторой способ, создать четыре списка, и в каждом списке хранить соответствующий элемент записи:\n\npre(brush:csharp).. \nList<string> names = new List<string>(); // список под имена\nList<string> families = new List<string>(); // список под фамилии\nList<int> ages = new List<string>(); // список под возраст\nList<string> adresses = new List<string>(); // список под адреса\n\n/*\n добавляем новую запись\n тут главное синхронизировать \n операцию добавления данных\n*/\nnames.Add("Вася");\nfamilies.Add("Пупкин");\nages.Add("21");\nadresses.Add("Иркутск, ул. Байкальская 1-2");\n\n// теперь чтобы узнать фамилию первого жителя достаточно написать так:\nConsole.WriteLine(families[0]);\n\np. В принципе неплохо, однако использование 4 отдельных списков сильно портит впечатление.\n\nЧтобы избавиться от такого набора списков, *C#* дает нам возможность создавать свои типы данных. Создадим структуру, которая объединит информацию о в один элемент жителе:\n\npre(brush:csharp).. \n\nstruct Settler \n{\n  public string Name;\n  public string Family;\n  public int Age;\n  public string Address;\n}\n\np. Мы создали свой тип данных. Теперь мы можем использовать его, точно так же как мы до этого использовали типы @int@, @string@, @List@, @Dictionary@ и т. д.\n\nОбъявлять свои типы можно в принципе где угодно, лишь бы не в теле функции:\n\npre(brush:csharp).. \nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1 \n{\n\n  // например тут\n  struct Settler \n  {\n    public string Name;\n    public string Family;\n    public int Age;\n    public string Address;\n  }\n  // до начала функции Main\n\n  static void Main(string[] args)\n  {\n    // тут нельзя\n    ...\n  }\n}\n\np. Теперь можно создать переменную типа Settler, и заполнить ее данными:\n\npre(brush:csharp).. \n// инициализируем переменную vasya\nSettler vasya = new Settler();\n\n// заполняем данные\nvasya.Name = "Вася";\nvasya.Family = "Пупкин";\nvasya.Age = 21;\nvasya.Address = "Иркутск, ул. Байкальская 1-2";\n\n// выведем на экран фамилию\nConsole.WriteLine(vasya.Family);\n\np. Кстати заполнить переменную можно сразу одновременно с инициализацией:\n\npre(brush:csharp).. \n\n// инициализируем и сразу заполняем\nSettler vasya = new Settler{\n  Name = "Вася",\n  Family = "Пупкин",\n  Age = 21,\n  Address = "Иркутск, ул. Байкальская 1-2",\n};\n\n// выведем на экран фамилию\nConsole.WriteLine(vasya.Family);\n\np. Теперь, если нам захочется хранить информацию о жителях города, достаточно будет создать один список:\n\npre(brush:csharp).. \n// создадим список\nList<Settler> settlers = new List<Settler>();\n\n// добавим пару записей в список\nsettlers.Add(new Settler {\n  Name = "Вася",\n  Family = "Пупкин",\n  Age = 21,\n  Address = "Иркутск, ул. Байкальская 1-2"\n});\n\nsettlers.Add(new Settler {\n  Name = "Маша",\n  Family = "Анюткина",\n  Age = 21,\n  Address = "Иркутск, ул. Байкальская 3-4"\n});\n\n// выведем на экран фамилию второго человека в списке\nConsole.WriteLine( settlers[1].Family );\n\np. Красота :D\n\n<hr>\n\nh2. Чтение форматированных данных\n\nЧасто данные для обработки вы будете получать в качестве некоторого строго отформатированого текста. Как правило это будет подобие таблички базы данных, где каждая строка текста будет соответствовать строке таблицы. Ну и одна колонка будет отделяться от другой каким-нибудь разделителем, например пробелом, точкой с запятой или знаком табуляции (@\\t@ в C#). Например:\n\npre(brush:csharp).. \n#name fullname english alpha2 alpha3 iso location location-precise\nАбхазия;Республика Абхазия;Abkhazia;AB;ABH;895;Азия;Закавказье\nАвстралия;;Australia;AU;AUS;036;Океания;Австралия и Новая Зеландия\nАвстрия;Австрийская Республика;Austria;AT;AUT;040;Европа;Западная Европа\nАзербайджан;Республика Азербайджан;Azerbaijan;AZ;AZE;031;Азия;Западная Азия\nАлбания;Республика Албания;Albania;AL;ALB;008;Европа;Южная Европа\nАлжир;Алжирская Народная Демократическая Республика;Algeria;DZ;DZA;012;Африка;Северная Африка\nАмериканское Самоа;;American Samoa;AS;ASM;016;Океания;Полинезия\nАнгилья;;Anguilla;AI;AIA;660;Америка;Карибский бассейн\nАнгола;Республика Ангола;Angola;AO;AGO;024;Африка;Центральная Африка\n\np. Тут у нас список стран. Первая строка содержит название столбцов, т.е. по сути поясняет нам какие столбики чему соответствуют, и по сути данными не является. И при считывании данных из файла ей можно пренебречь.\n\nСоздадим структуру которая будет соответствовать одной строчке данного файла:\n\npre(brush:csharp).. \nstruct Country \n{\n  public string Name;     // название страны\n  public string Fullname; // полное название страны\n  public string English;  // на английском\n  public string Alpha2;   // буквенный код 1\n  public string Alpha3;   // буквенный код 2\n  public string Iso;      // цифровой код\n  public string Location; // материк\n  public string LocationPrecise; // географическое местоположение\n}\n\np. Теперь считаем текст и сформируем список структур @Country@\n\npre(brush:csharp).. \n// читаем текст из файла\nstring fileText = File.ReadAllText("countries.txt");\n\n// разбиваем текст на строки\nstring[] lines = fileText.Split(new string[] { Environment.NewLine });\n\n// создаем список под страны\nList<Country> Countries = new List<Country>();\n\nforeach(var l in lines) \n{\n  /*\n   если первый символ в строке #, \n   то переходим  следующей строке\n  */\n  if (l[0] == ''#'') continue; \n\n  // разбиваем строку точками с запятыми\n  string[] words = l.Split(";");\n\n  //создаем новую переменную типа Country;\n  Country c = new Country();\n\n  // заполняем ее данными\n  c.Name = words[0];\n  c.Fullname = words[1];\n  c.English = words[2];\n  c.Alpha2 = words[3];\n  c.Alpha3 = words[4];\n  c.Iso = words[5];\n  c.Location = words[6];\n  c.LocationPrecise = words[7];\n\n  // добавляем в общий список данных\n  Countries.Add(c);\n\n}\n\np. После выполнения сей магической процедуры, нам будет очень удобно работать с данными:\n\npre(brush:csharp).. \n/*\n следующее заклинание выведет:\n Страна Албания находится в Европа\n*/\nConsole.WriteLine("Страна " + Countries[4].Name + " находится в " + Countries[4].Location);\n\np. Ну не то чтобы совсем удобно, но вполне ничего.', 1, 8, 0, 13, 1382950214, 1382959811);

-- --------------------------------------------------------

--
-- Table structure for table `categories`
--

DROP TABLE IF EXISTS `categories`;
CREATE TABLE IF NOT EXISTS `categories` (
  `id_` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(128) NOT NULL,
  `title_menu` varchar(128) NOT NULL,
  `title_page` varchar(128) NOT NULL,
  `description` text NOT NULL,
  `controller` tinytext NOT NULL,
  `parent_id` int(11) DEFAULT NULL,
  `ord` int(11) NOT NULL DEFAULT '0',
  `enabled` tinyint(4) NOT NULL DEFAULT '0',
  PRIMARY KEY (`id_`),
  UNIQUE KEY `id_` (`id_`),
  KEY `id__2` (`id_`),
  KEY `id__3` (`id_`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=12 ;

--
-- Dumping data for table `categories`
--

INSERT INTO `categories` (`id_`, `title`, `title_menu`, `title_page`, `description`, `controller`, `parent_id`, `ord`, `enabled`) VALUES
(2, 'Практикум по C#', '&#9632;&#9632;&#9632;', '', '', 'lessons/csharp', NULL, 3, 1),
(4, 'Математическая логика', '&#x25B2;&#x25B2;', '', '', 'lessons/mlogic', NULL, 2, 1),
(11, 'Главные страницы', 'Главные страницы', 'Главные страницы', 'Тут у меня все главные страницы. Категория по умолчанию должна быть отключена. И доступна для просмотра только для администратора.', '', NULL, 1, 0);

-- --------------------------------------------------------

--
-- Table structure for table `ci_sessions`
--

DROP TABLE IF EXISTS `ci_sessions`;
CREATE TABLE IF NOT EXISTS `ci_sessions` (
  `session_id` varchar(40) NOT NULL DEFAULT '0',
  `ip_address` varchar(45) NOT NULL DEFAULT '0',
  `user_agent` varchar(120) NOT NULL,
  `last_activity` int(10) unsigned NOT NULL DEFAULT '0',
  `user_data` text NOT NULL,
  PRIMARY KEY (`session_id`),
  KEY `last_activity_idx` (`last_activity`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

--
-- Dumping data for table `ci_sessions`
--

INSERT INTO `ci_sessions` (`session_id`, `ip_address`, `user_agent`, `last_activity`, `user_data`) VALUES
('ca5150193fb900b3b0b6164e2e0ba4ac', '85.21.245.106', 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/534.57.2 (KHTML, like Gecko) Version/5.1.7 Safari/534.57.2', 1383501461, 'a:3:{s:9:"user_data";s:0:"";s:5:"refer";s:27:"http://tealeaf.su/index.php";s:7:"entered";i:1;}'),
('49c7530e5606d50a3b168c7515aa7177', '31.47.181.82', 'Opera/9.80 (X11; Linux x86_64) Presto/2.12.388 Version/12.16', 1383498724, 'a:4:{s:9:"user_data";s:0:"";s:5:"refer";s:33:"http://tealeaf.su/index.php/admin";s:7:"entered";i:1;s:6:"logged";b:1;}'),
('bfe8835cca03fc8760a717f62cc7fd74', '92.126.17.191', 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:24.0) Gecko/20100101 Firefox/24.0', 1383504247, 'a:3:{s:9:"user_data";s:0:"";s:5:"refer";s:36:"http://tealeaf.su/index.php/page/2/4";s:7:"entered";i:1;}');

-- --------------------------------------------------------

--
-- Table structure for table `visitors`
--

DROP TABLE IF EXISTS `visitors`;
CREATE TABLE IF NOT EXISTS `visitors` (
  `id_` int(11) NOT NULL AUTO_INCREMENT,
  `ip` varchar(45) NOT NULL,
  `agent` varchar(512) NOT NULL DEFAULT '',
  `timestamp` int(11) NOT NULL,
  `browser` varchar(128) NOT NULL DEFAULT '',
  `browser_v` varchar(128) NOT NULL DEFAULT '',
  `platform` varchar(128) NOT NULL DEFAULT '',
  `mobile` varchar(128) NOT NULL DEFAULT '',
  `robot` varchar(128) NOT NULL DEFAULT '',
  `referrer` varchar(512) NOT NULL DEFAULT '',
  PRIMARY KEY (`id_`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=150 ;

--
-- Dumping data for table `visitors`
--

INSERT INTO `visitors` (`id_`, `ip`, `agent`, `timestamp`, `browser`, `browser_v`, `platform`, `mobile`, `robot`, `referrer`) VALUES
(12, '164.215.95.13', 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.101 Safari/537.36', 1382318710, 'Chrome', '30.0.1599.101', 'Unknown Windows OS', '0', '0', '0'),
(11, '188.168.153.179', 'Opera/9.80 (X11; Linux x86_64) Presto/2.12.388 Version/12.16', 1382297294, 'Opera', '9.80', 'Linux', '0', '0', 'http://tealeaf.su/index.php/admin'),
(10, '188.232.204.147', 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:20.0) Gecko/20100101 Firefox/20.0', 1382296966, 'Firefox', '20.0', 'Unknown Windows OS', '0', '0', '0'),
(8, '188.232.204.147', 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:20.0) Gecko/20100101 Firefox/20.0', 1382295161, 'Firefox', '20.0', 'Unknown Windows OS', '0', '0', '0'),
(9, '188.168.153.179', 'Opera/9.80 (X11; Linux x86_64) Presto/2.12.388 Version/12.16', 1382296676, 'Opera', '9.80', 'Linux', '0', '0', '0'),
(13, '188.168.153.179', 'Opera/9.80 (Windows NT 6.1; Win64; x64) Presto/2.12.388 Version/12.11', 1382327526, 'Opera', '9.80', 'Unknown Windows OS', '0', '0', '0'),
(14, '217.69.133.169', 'Mozilla/5.0 (X11; Linux x86_64; rv:18.0) Gecko/20100101 Firefox/18.0', 1382328037, 'Firefox', '18.0', 'Linux', '0', '0', '0'),
(15, '66.249.78.172', 'Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)', 1382347903, '0', '0', 'Unknown Platform', '0', 'Googlebot', '0'),
(16, '164.215.95.13', 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.101 Safari/537.36', 1382348739, 'Chrome', '30.0.1599.101', 'Unknown Windows OS', '0', '0', '0'),
(17, '188.168.153.179', 'Opera/9.80 (Windows NT 6.1; Win64; x64) Presto/2.12.388 Version/12.11', 1382351697, 'Opera', '9.80', 'Unknown Windows OS', '0', '0', '0'),
(18, '188.168.153.179', 'Opera/9.80 (X11; Linux x86_64) Presto/2.12.388 Version/12.16', 1382357656, 'Opera', '9.80', 'Linux', '0', '0', '0'),
(19, '164.215.95.13', 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.101 Safari/537.36', 1382362794, 'Chrome', '30.0.1599.101', 'Unknown Windows OS', '0', '0', '0'),
(20, '188.168.153.179', 'Opera/9.80 (X11; Linux x86_64) Presto/2.12.388 Version/12.16', 1382367392, 'Opera', '9.80', 'Linux', '0', '0', '0'),
(21, '66.249.78.54', 'Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)', 1382369171, '0', '0', 'Unknown Platform', '0', 'Googlebot', '0'),
(22, '188.168.153.179', 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/28.0.1500.52 Safari/537.36 OPR/15.0.1147.100 (Edition Next)', 1382382748, 'Chrome', '28.0.1500.52', 'Unknown Windows OS', '0', '0', 'http://tealeaf.su/index.php/login'),
(23, '164.215.95.13', 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.101 Safari/537.36', 1382400771, 'Chrome', '30.0.1599.101', 'Unknown Windows OS', '0', '0', '0'),
(24, '188.168.153.179', 'Opera/9.80 (X11; Linux x86_64) Presto/2.12.388 Version/12.16', 1382417799, 'Opera', '9.80', 'Linux', '0', '0', '0'),
(25, '188.168.153.179', 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.101 Safari/537.36', 1382419835, 'Chrome', '30.0.1599.101', 'Linux', '0', '0', '0'),
(26, '188.168.153.179', 'Opera/9.80 (Windows NT 6.1; Win64; x64) Presto/2.12.388 Version/12.11', 1382438592, 'Opera', '9.80', 'Unknown Windows OS', '0', '0', '0'),
(27, '188.168.153.179', 'Opera/9.80 (X11; Linux x86_64) Presto/2.12.388 Version/12.16', 1382441198, 'Opera', '9.80', 'Linux', '0', '0', '0'),
(28, '188.168.153.179', 'Opera/9.80 (Windows NT 6.1; Win64; x64) Presto/2.12.388 Version/12.16', 1382450422, 'Opera', '9.80', 'Unknown Windows OS', '0', '0', '0'),
(29, '188.168.153.179', 'Opera/9.80 (Windows NT 6.1; WOW64) Presto/2.12.388 Version/12.16', 1382452481, 'Opera', '9.80', 'Unknown Windows OS', '0', '0', '0'),
(30, '198.211.120.204', 'Mozilla/5.0 (Windows NT 6.1; rv:24.0) Gecko/20100101 Firefox/24.0', 1382479178, 'Firefox', '24.0', 'Unknown Windows OS', '0', '0', '0'),
(31, '95.189.39.211', 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:24.0) Gecko/20100101 Firefox/24.0', 1382491209, 'Firefox', '24.0', 'Unknown Windows OS', '0', '0', '0'),
(32, '94.137.194.10', 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.101 Safari/537.36', 1382494424, 'Chrome', '30.0.1599.101', 'Unknown Windows OS', '0', '0', '0'),
(33, '188.168.153.179', 'Opera/9.80 (X11; Linux x86_64) Presto/2.12.388 Version/12.16', 1382496043, 'Opera', '9.80', 'Linux', '0', '0', '0'),
(34, '194.190.233.219', 'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.101 Safari/537.36', 1382514783, 'Chrome', '30.0.1599.101', 'Unknown Windows OS', '0', '0', 'https://www.google.ru/'),
(35, '188.168.153.179', 'Opera/9.80 (X11; Linux x86_64) Presto/2.12.388 Version/12.16', 1382524275, 'Opera', '9.80', 'Linux', '0', '0', '0'),
(36, '164.215.86.172', 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.101 Safari/537.36', 1382528632, 'Chrome', '30.0.1599.101', 'Unknown Windows OS', '0', '0', '0'),
(37, '80.83.237.115', 'Mozilla/5.0 (Linux; U; Android 4.0.4; ru-ru; Surf Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30', 1382528647, 'Safari', '534.30', 'Linux', 'Generic Mobile', '0', '0'),
(38, '188.168.153.179', 'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/29.0.1547.76 Safari/537.36 OPR/16.0.1196.80', 1382532879, 'Chrome', '29.0.1547.76', 'Unknown Windows OS', '0', '0', '0'),
(39, '188.168.153.179', 'Opera/9.80 (X11; Linux x86_64) Presto/2.12.388 Version/12.16', 1382538247, 'Opera', '9.80', 'Linux', '0', '0', '0'),
(40, '178.154.164.250', 'Mozilla/5.0 (compatible; YandexBot/3.0; +http://yandex.com/bots)', 1382552141, 'Mozilla', '5.0', 'Unknown Platform', '0', '0', '0'),
(41, '188.168.153.179', 'Opera/9.80 (Windows NT 6.1; Win64; x64) Presto/2.12.388 Version/12.16', 1382553017, 'Opera', '9.80', 'Unknown Windows OS', '0', '0', '0'),
(42, '178.154.164.250', 'Mozilla/5.0 (compatible; YandexBot/3.0; +http://yandex.com/bots)', 1382560479, 'Mozilla', '5.0', 'Unknown Platform', '0', '0', '0'),
(43, '188.168.153.179', 'Opera/9.80 (Windows NT 6.1; Win64; x64) Presto/2.12.388 Version/12.16', 1382587755, 'Opera', '9.80', 'Unknown Windows OS', '0', '0', '0'),
(44, '222.66.117.50', 'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; InfoPath.1)', 1382595494, 'Internet Explorer', '8.0', 'Windows XP', '0', '0', '0'),
(45, '188.168.153.179', 'Opera/9.80 (X11; Linux x86_64) Presto/2.12.388 Version/12.16', 1382616447, 'Opera', '9.80', 'Linux', '0', '0', '0'),
(46, '95.189.32.84', 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:24.0) Gecko/20100101 Firefox/24.0', 1382623690, 'Firefox', '24.0', 'Unknown Windows OS', '0', '0', '0'),
(47, '188.168.153.179', 'Opera/9.80 (Windows NT 6.1; Win64; x64) Presto/2.12.388 Version/12.16', 1382686949, 'Opera', '9.80', 'Unknown Windows OS', '0', '0', '0'),
(48, '95.189.46.143', 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:24.0) Gecko/20100101 Firefox/24.0', 1382698463, 'Firefox', '24.0', 'Unknown Windows OS', '0', '0', '0'),
(49, '188.168.153.179', 'Opera/9.80 (Windows NT 6.1; Win64; x64) Presto/2.12.388 Version/12.16', 1382699384, 'Opera', '9.80', 'Unknown Windows OS', '0', '0', '0'),
(50, '195.54.213.174', 'Mozilla/5.0 (compatible; statdom.ru/Bot; +http://statdom.ru/bot.html)', 1382700243, 'Mozilla', '5.0', 'Unknown Platform', '0', '0', '0'),
(51, '164.215.93.9', 'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.101 Safari/537.36', 1382704395, 'Chrome', '30.0.1599.101', 'Unknown Windows OS', '0', '0', '0'),
(52, '94.137.196.192', 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.101 Safari/537.36', 1382705770, 'Chrome', '30.0.1599.101', 'Unknown Windows OS', '0', '0', '0'),
(53, '37.49.183.238', 'Opera/9.80 (Windows NT 6.1; Win64; x64) Presto/2.12.388 Version/12.16', 1382718222, 'Opera', '9.80', 'Unknown Windows OS', '0', '0', '0'),
(54, '37.49.183.238', 'Opera/9.80 (X11; Linux x86_64) Presto/2.12.388 Version/12.16', 1382760170, 'Opera', '9.80', 'Linux', '0', '0', '0'),
(55, '164.215.92.58', 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.101 Safari/537.36', 1382772929, 'Chrome', '30.0.1599.101', 'Unknown Windows OS', '0', '0', '0'),
(56, '37.49.183.238', 'Opera/9.80 (X11; Linux x86_64) Presto/2.12.388 Version/12.16', 1382782753, 'Opera', '9.80', 'Linux', '0', '0', '0'),
(57, '92.124.46.138', 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.101 Safari/537.36', 1382791177, 'Chrome', '30.0.1599.101', 'Unknown Windows OS', '0', '0', 'http://vk.com/im?peers=c54&q=in%3Ac54%20tealeaf'),
(58, '87.240.182.148', 'Mozilla/5.0 (compatible; vkShare; +http://vk.com/dev/Share)', 1382791199, 'Mozilla', '5.0', 'Unknown Platform', '0', '0', '0'),
(59, '171.33.254.190', 'Opera/9.80 (Windows NT 6.2) Presto/2.12.388 Version/12.16', 1382791233, 'Opera', '9.80', 'Unknown Windows OS', '0', '0', '0'),
(60, '164.215.92.58', 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.101 Safari/537.36', 1382794487, 'Chrome', '30.0.1599.101', 'Unknown Windows OS', '0', '0', 'http://tealeaf.su/index.php/page/2/3'),
(61, '37.49.183.238', 'Opera/9.80 (Windows NT 6.1; Win64; x64) Presto/2.12.388 Version/12.16', 1382807197, 'Opera', '9.80', 'Unknown Windows OS', '0', '0', '0'),
(62, '178.154.164.250', 'Mozilla/5.0 (compatible; YandexBot/3.0; +http://yandex.com/bots)', 1382821887, 'Mozilla', '5.0', 'Unknown Platform', '0', '0', '0'),
(63, '66.249.78.54', 'Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)', 1382825440, '0', '0', 'Unknown Platform', '0', 'Googlebot', '0'),
(64, '66.249.78.172', 'Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)', 1382845179, '0', '0', 'Unknown Platform', '0', 'Googlebot', '0'),
(65, '164.215.92.58', 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.101 Safari/537.36', 1382846548, 'Chrome', '30.0.1599.101', 'Unknown Windows OS', '0', '0', '0'),
(66, '37.49.183.238', 'Opera/9.80 (Windows NT 6.1; Win64; x64) Presto/2.12.388 Version/12.16', 1382849367, 'Opera', '9.80', 'Unknown Windows OS', '0', '0', '0'),
(67, '178.184.83.246', 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:24.0) Gecko/20100101 Firefox/24.0', 1382854491, 'Firefox', '24.0', 'Unknown Windows OS', '0', '0', '0'),
(68, '95.189.34.53', 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:24.0) Gecko/20100101 Firefox/24.0', 1382876471, 'Firefox', '24.0', 'Unknown Windows OS', '0', '0', '0'),
(69, '37.49.183.238', 'Opera/9.80 (X11; Linux x86_64) Presto/2.12.388 Version/12.16', 1382881352, 'Opera', '9.80', 'Linux', '0', '0', '0'),
(70, '94.137.195.50', 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.101 Safari/537.36', 1382882888, 'Chrome', '30.0.1599.101', 'Unknown Windows OS', '0', '0', '0'),
(71, '188.168.153.236', 'Opera/9.80 (Windows NT 6.1; Win64; x64) Presto/2.12.388 Version/12.16', 1382891954, 'Opera', '9.80', 'Unknown Windows OS', '0', '0', '0'),
(72, '178.154.164.250', 'Mozilla/5.0 (compatible; YandexBot/3.0; +http://yandex.com/bots)', 1382924355, 'Mozilla', '5.0', 'Unknown Platform', '0', '0', '0'),
(73, '84.244.7.48', 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.101 Safari/537.36', 1382925505, 'Chrome', '30.0.1599.101', 'Unknown Windows OS', '0', '0', '0'),
(74, '66.249.78.172', 'Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)', 1382925644, '0', '0', 'Unknown Platform', '0', 'Googlebot', '0'),
(75, '178.154.164.250', 'Mozilla/5.0 (compatible; YandexBot/3.0; +http://yandex.com/bots)', 1382931053, 'Mozilla', '5.0', 'Unknown Platform', '0', '0', '0'),
(76, '84.244.7.60', 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.101 Safari/537.36', 1382931683, 'Chrome', '30.0.1599.101', 'Unknown Windows OS', '0', '0', '0'),
(77, '188.168.153.236', 'Opera/9.80 (Windows NT 6.1; Win64; x64) Presto/2.12.388 Version/12.16', 1382934649, 'Opera', '9.80', 'Unknown Windows OS', '0', '0', '0'),
(78, '178.154.164.250', 'Mozilla/5.0 (compatible; YandexBot/3.0; +http://yandex.com/bots)', 1382942478, 'Mozilla', '5.0', 'Unknown Platform', '0', '0', '0'),
(79, '84.244.7.60', 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.101 Safari/537.36', 1382942653, 'Chrome', '30.0.1599.101', 'Unknown Windows OS', '0', '0', 'http://tealeaf.su/index.php/page/2/2'),
(80, '188.168.153.236', 'Opera/9.80 (Windows NT 6.1; Win64; x64) Presto/2.12.388 Version/12.16', 1382944306, 'Opera', '9.80', 'Unknown Windows OS', '0', '0', '0'),
(81, '188.168.153.236', 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:21.0) Gecko/20100101 Firefox/21.0', 1382944498, 'Firefox', '21.0', 'Unknown Windows OS', '0', '0', '0'),
(82, '84.244.7.60', 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.101 Safari/537.36', 1382952286, 'Chrome', '30.0.1599.101', 'Unknown Windows OS', '0', '0', '0'),
(83, '178.184.115.65', 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:24.0) Gecko/20100101 Firefox/24.0', 1382963858, 'Firefox', '24.0', 'Unknown Windows OS', '0', '0', '0'),
(84, '178.154.164.250', 'Mozilla/5.0 (compatible; YandexBot/3.0; +http://yandex.com/bots)', 1382967988, 'Mozilla', '5.0', 'Unknown Platform', '0', '0', '0'),
(85, '188.168.153.236', 'Opera/9.80 (Windows NT 6.1; Win64; x64) Presto/2.12.388 Version/12.16', 1382973449, 'Opera', '9.80', 'Unknown Windows OS', '0', '0', '0'),
(86, '66.249.64.5', 'Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)', 1382980368, '0', '0', 'Unknown Platform', '0', 'Googlebot', '0'),
(87, '188.168.153.236', 'Opera/9.80 (Windows NT 6.1; Win64; x64) Presto/2.12.388 Version/12.16', 1383042667, 'Opera', '9.80', 'Unknown Windows OS', '0', '0', '0'),
(88, '164.215.92.58', 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.101 Safari/537.36', 1383047791, 'Chrome', '30.0.1599.101', 'Unknown Windows OS', '0', '0', '0'),
(89, '92.126.31.193', 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.101 Safari/537.36', 1383051900, 'Chrome', '30.0.1599.101', 'Unknown Windows OS', '0', '0', '0'),
(90, '94.137.195.8', 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.101 Safari/537.36', 1383052690, 'Chrome', '30.0.1599.101', 'Unknown Windows OS', '0', '0', '0'),
(91, '92.126.33.106', 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:24.0) Gecko/20100101 Firefox/24.0', 1383103668, 'Firefox', '24.0', 'Unknown Windows OS', '0', '0', '0'),
(92, '141.105.50.44', 'Opera/9.80 (Windows NT 6.1; Win64; x64) Presto/2.12.388 Version/12.16', 1383107592, 'Opera', '9.80', 'Unknown Windows OS', '0', '0', '0'),
(93, '194.190.233.219', 'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.101 Safari/537.36', 1383119720, 'Chrome', '30.0.1599.101', 'Unknown Windows OS', '0', '0', '0'),
(94, '141.105.49.49', 'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.101 Safari/537.36', 1383125366, 'Chrome', '30.0.1599.101', 'Unknown Windows OS', '0', '0', '0'),
(95, '141.105.50.44', 'Mozilla/5.0 (X11; Linux x86_64; rv:19.0) Gecko/20100101 Firefox/19.0', 1383134318, 'Firefox', '19.0', 'Linux', '0', '0', '0'),
(96, '85.17.73.171', 'Mozilla/5.0 (compatible; SolomonoBot/1.05; +http://www.solomono.ru)', 1383136787, 'Mozilla', '5.0', 'Unknown Platform', '0', '0', '0'),
(97, '66.249.78.172', 'Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)', 1383142265, '0', '0', 'Unknown Platform', '0', 'Googlebot', '0'),
(98, '195.54.213.174', 'Mozilla/5.0 (compatible; statdom.ru/Bot; +http://statdom.ru/bot.html)', 1383143360, 'Mozilla', '5.0', 'Unknown Platform', '0', '0', '0'),
(99, '141.105.50.44', 'Opera/9.80 (X11; Linux x86_64) Presto/2.12.388 Version/12.16', 1383147325, 'Opera', '9.80', 'Linux', '0', '0', '0'),
(100, '92.126.36.133', 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:24.0) Gecko/20100101 Firefox/24.0', 1383149976, 'Firefox', '24.0', 'Unknown Windows OS', '0', '0', '0'),
(101, '141.105.50.44', 'Opera/9.80 (Windows NT 6.1; Win64; x64) Presto/2.12.388 Version/12.16', 1383158048, 'Opera', '9.80', 'Unknown Windows OS', '0', '0', '0'),
(102, '178.154.164.250', 'Mozilla/5.0 (compatible; YandexBot/3.0; +http://yandex.com/bots)', 1383193106, 'Mozilla', '5.0', 'Unknown Platform', '0', '0', '0'),
(103, '188.168.151.176', 'Opera/9.80 (X11; Linux x86_64) Presto/2.12.388 Version/12.16', 1383194996, 'Opera', '9.80', 'Linux', '0', '0', '0'),
(104, '178.154.164.250', 'Mozilla/5.0 (compatible; YandexBot/3.0; +http://yandex.com/bots)', 1383212703, 'Mozilla', '5.0', 'Unknown Platform', '0', '0', '0'),
(105, '64.246.178.34', 'Mozilla/5.0 (Windows; U; Windows NT 5.1; en; rv:1.9.0.13) Gecko/2009073022 Firefox/3.5.2 (.NET CLR 3.5.30729) SurveyBot/2.3 (DomainTools)', 1383214257, 'Firefox', '3.5.2', 'Windows XP', '0', '0', 'http://whois.domaintools.com/tealeaf.su'),
(106, '178.154.164.250', 'Mozilla/5.0 (compatible; YandexBot/3.0; +http://yandex.com/bots)', 1383215978, 'Mozilla', '5.0', 'Unknown Platform', '0', '0', '0'),
(107, '188.168.151.176', 'Opera/9.80 (X11; Linux x86_64) Presto/2.12.388 Version/12.16', 1383216315, 'Opera', '9.80', 'Linux', '0', '0', '0'),
(108, '66.249.16.211', 'Opera/9.80 (X11; Linux x86_64) Presto/2.12.388 Version/12.16', 1383216333, 'Opera', '9.80', 'Linux', '0', '0', 'http://whois.domaintools.com/tealeaf.su'),
(109, '66.249.93.172', 'Mozilla/5.0 (Windows NT 6.1; rv:6.0) Gecko/20110814 Firefox/6.0 Google (+https://developers.google.com/+/web/snippet/)', 1383216335, 'Firefox', '6.0', 'Unknown Windows OS', '0', '0', '0'),
(110, '178.154.164.250', 'Mozilla/5.0 (compatible; YandexBot/3.0; +http://yandex.com/bots)', 1383233973, 'Mozilla', '5.0', 'Unknown Platform', '0', '0', '0'),
(111, '178.184.93.74', 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:24.0) Gecko/20100101 Firefox/24.0', 1383234970, 'Firefox', '24.0', 'Unknown Windows OS', '0', '0', '0'),
(112, '79.143.187.164', 'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1', 1383237357, 'Firefox', '2.0.0.1', 'Windows XP', '0', '0', '0'),
(113, '178.154.164.250', 'Mozilla/5.0 (compatible; YandexBot/3.0; +http://yandex.com/bots)', 1383237969, 'Mozilla', '5.0', 'Unknown Platform', '0', '0', '0'),
(114, '188.168.151.176', 'Opera/9.80 (X11; Linux x86_64) Presto/2.12.388 Version/12.16', 1383238414, 'Opera', '9.80', 'Linux', '0', '0', '0'),
(115, '178.154.164.250', 'Mozilla/5.0 (compatible; YandexBot/3.0; +http://yandex.com/bots)', 1383273050, 'Mozilla', '5.0', 'Unknown Platform', '0', '0', '0'),
(116, '80.83.237.11', 'Opera/9.80 (Windows NT 6.2) Presto/2.12.388 Version/12.16', 1383273896, 'Opera', '9.80', 'Unknown Windows OS', '0', '0', '0'),
(117, '178.154.164.250', 'Mozilla/5.0 (compatible; YandexBot/3.0; +http://yandex.com/bots)', 1383292738, 'Mozilla', '5.0', 'Unknown Platform', '0', '0', '0'),
(118, '188.168.151.176', 'Opera/9.80 (X11; Linux x86_64) Presto/2.12.388 Version/12.16', 1383295098, 'Opera', '9.80', 'Linux', '0', '0', '0'),
(119, '178.154.164.250', 'Mozilla/5.0 (compatible; YandexBot/3.0; +http://yandex.com/bots)', 1383297883, 'Mozilla', '5.0', 'Unknown Platform', '0', '0', '0'),
(120, '193.169.234.5', 'Mozilla/5.0 (compatible; openstat.ru/Bot)', 1383298213, 'Mozilla', '5.0', 'Unknown Platform', '0', '0', '0'),
(121, '178.154.164.250', 'Mozilla/5.0 (compatible; YandexBot/3.0; +http://yandex.com/bots)', 1383302174, 'Mozilla', '5.0', 'Unknown Platform', '0', '0', '0'),
(122, '188.168.151.176', 'Opera/9.80 (X11; Linux x86_64) Presto/2.12.388 Version/12.16', 1383303987, 'Opera', '9.80', 'Linux', '0', '0', '0'),
(123, '193.169.234.5', 'Mozilla/5.0 (compatible; openstat.ru/Bot)', 1383309172, 'Mozilla', '5.0', 'Unknown Platform', '0', '0', '0'),
(124, '66.249.78.54', 'Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)', 1383323537, '0', '0', 'Unknown Platform', '0', 'Googlebot', '0'),
(125, '178.154.164.250', 'Mozilla/5.0 (compatible; YandexBot/3.0; +http://yandex.com/bots)', 1383330717, 'Mozilla', '5.0', 'Unknown Platform', '0', '0', '0'),
(126, '188.168.151.176', 'Opera/9.80 (X11; Linux x86_64) Presto/2.12.388 Version/12.16', 1383330889, 'Opera', '9.80', 'Linux', '0', '0', '0'),
(127, '66.249.78.54', 'Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)', 1383337218, '0', '0', 'Unknown Platform', '0', 'Googlebot', '0'),
(128, '66.249.78.172', 'Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)', 1383354733, '0', '0', 'Unknown Platform', '0', 'Googlebot', '0'),
(129, '95.189.63.146', 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:24.0) Gecko/20100101 Firefox/24.0', 1383366949, 'Firefox', '24.0', 'Unknown Windows OS', '0', '0', '0'),
(130, '141.105.36.64', 'Opera/9.80 (X11; Linux x86_64) Presto/2.12.388 Version/12.16', 1383371899, 'Opera', '9.80', 'Linux', '0', '0', '0'),
(131, '95.189.63.146', 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:24.0) Gecko/20100101 Firefox/24.0', 1383374964, 'Firefox', '24.0', 'Unknown Windows OS', '0', '0', '0'),
(132, '178.184.67.71', 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:24.0) Gecko/20100101 Firefox/24.0', 1383391976, 'Firefox', '24.0', 'Unknown Windows OS', '0', '0', '0'),
(133, '37.49.172.52', 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/28.0.1500.95 Safari/537.36 OPR/15.0.1147.153', 1383393824, 'Chrome', '28.0.1500.95', 'Unknown Windows OS', '0', '0', 'http://www.tealeaf.su/'),
(134, '87.240.182.172', 'Mozilla/5.0 (compatible; vkShare; +http://vk.com/dev/Share)', 1383394052, 'Mozilla', '5.0', 'Unknown Platform', '0', '0', '0'),
(135, '178.184.160.216', 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.101 Safari/537.36', 1383394064, 'Chrome', '30.0.1599.101', 'Unknown Windows OS', '0', '0', 'http://vk.com/im?peers=21243870_144379762&sel=189462483'),
(136, '87.240.182.172', 'Mozilla/5.0 (compatible; vkShare; +http://vk.com/dev/Share)', 1383394410, 'Mozilla', '5.0', 'Unknown Platform', '0', '0', '0'),
(137, '66.249.78.172', 'Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)', 1383396597, '0', '0', 'Unknown Platform', '0', 'Googlebot', '0'),
(138, '178.184.67.71', 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:24.0) Gecko/20100101 Firefox/24.0', 1383399422, 'Firefox', '24.0', 'Unknown Windows OS', '0', '0', 'http://tealeaf.su/index.php/page/2/3'),
(139, '66.249.78.172', 'Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)', 1383408202, '0', '0', 'Unknown Platform', '0', 'Googlebot', '0'),
(140, '178.184.67.71', 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:24.0) Gecko/20100101 Firefox/24.0', 1383412089, 'Firefox', '24.0', 'Unknown Windows OS', '0', '0', '0'),
(141, '193.169.234.5', 'Mozilla/5.0 (compatible; openstat.ru/Bot)', 1383438580, 'Mozilla', '5.0', 'Unknown Platform', '0', '0', 'http://tealeaf.su/'),
(142, '178.184.95.70', 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:24.0) Gecko/20100101 Firefox/24.0', 1383449520, 'Firefox', '24.0', 'Unknown Windows OS', '0', '0', '0'),
(143, '31.47.181.82', 'Opera/9.80 (X11; Linux x86_64) Presto/2.12.388 Version/12.16', 1383452743, 'Opera', '9.80', 'Linux', '0', '0', '0'),
(144, '31.47.181.82', 'Opera/9.80 (Windows NT 6.1; Win64; x64) Presto/2.12.388 Version/12.16', 1383460688, 'Opera', '9.80', 'Unknown Windows OS', '0', '0', '0'),
(145, '92.126.17.191', 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:24.0) Gecko/20100101 Firefox/24.0', 1383462895, 'Firefox', '24.0', 'Unknown Windows OS', '0', '0', '0'),
(146, '31.47.181.82', 'Opera/9.80 (Windows NT 6.1; Win64; x64) Presto/2.12.388 Version/12.16', 1383469923, 'Opera', '9.80', 'Unknown Windows OS', '0', '0', '0'),
(147, '92.126.17.191', 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:24.0) Gecko/20100101 Firefox/24.0', 1383485168, 'Firefox', '24.0', 'Unknown Windows OS', '0', '0', '0'),
(148, '31.47.181.82', 'Opera/9.80 (X11; Linux x86_64) Presto/2.12.388 Version/12.16', 1383494135, 'Opera', '9.80', 'Linux', '0', '0', '0'),
(149, '85.21.245.106', 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/534.57.2 (KHTML, like Gecko) Version/5.1.7 Safari/534.57.2', 1383501461, 'Safari', '534.57.2', 'Unknown Windows OS', '0', '0', '0');

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
